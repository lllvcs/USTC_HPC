%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,12pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother


\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{xeCJK}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjornstrup]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small,formatcom=\xeCJKVerbAddon}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


    \usepackage{xeCJK}
    \usepackage{fontspec}
    \usepackage{indentfirst} % 中文首行缩进
	\let\cleardoublepage\clearpage
    \setlength{\parindent}{2em}
    \setCJKmainfont{AR PL SungtiL GB}
    \setCJKmonofont[Scale=0.9]{AR PL SungtiL GB}
    \setCJKfamilyfont{song}{AR PL SungtiL GB}
    \setCJKfamilyfont{sf}{AR PL SungtiL GB}
    \XeTeXlinebreaklocale "zh"          % 设定中文
    \XeTeXlinebreakskip = 0pt plus 1pt  % 设定中文字距与英文字距
    

\title{中国科大超级计算中心用户使用文档}
\date{2022 年 12 月 17 日}
\release{2021\sphinxhyphen{}03}
\author{中国科大超级计算中心}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{发行版本}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{前言}
\label{\detokenize{preface:id1}}\label{\detokenize{preface::doc}}
\sphinxAtStartPar
本用户使用指南主要将对相关指示做一基本介绍，详细信息请参看相应的文档。

\sphinxAtStartPar
为了便于查看，主要排版约定如下：
\begin{itemize}
\item {} 
\sphinxAtStartPar
文件名：\sphinxtitleref{/path/file}

\item {} 
\sphinxAtStartPar
环境变量： \sphinxstyleemphasis{MKLROOT}

\item {} 
\sphinxAtStartPar
命令：\sphinxcode{\sphinxupquote{command parameters}}

\item {} 
\sphinxAtStartPar
脚本文件内容或长命令：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{export} \PYG{n+nv}{OPENMPI}\PYG{o}{=}/opt/openmpi/1.8.2\PYGZus{}intel\PYGZhy{}compiler\PYGZhy{}2015.1.133
\PYG{n+nb}{export} \PYG{n+nv}{PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}OPENMPI}/bin:\PYG{n+nv}{\PYGZdl{}PATH}
\PYG{n+nb}{export} \PYG{n+nv}{MANPATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}MANPATH}:\PYG{n+nv}{\PYGZdl{}OPENMPI}/share/man
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
命令输出：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QUEUE\PYGZus{}NAME}      \PYG{n}{PRIO} \PYG{n}{STATUS}          \PYG{n}{MAX} \PYG{n}{JL}\PYG{o}{/}\PYG{n}{U} \PYG{n}{JL}\PYG{o}{/}\PYG{n}{P} \PYG{n}{JL}\PYG{o}{/}\PYG{n}{H} \PYG{n}{NJOBS}  \PYG{n}{PEND}   \PYG{n}{RUN}  \PYG{n}{SUSP}
\PYG{n}{serial}           \PYG{l+m+mi}{50}  \PYG{n}{Open}\PYG{p}{:}\PYG{n}{Active}       \PYG{o}{\PYGZhy{}}   \PYG{l+m+mi}{16}    \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}
\PYG{n}{long}             \PYG{l+m+mi}{40}  \PYG{n}{Open}\PYG{p}{:}\PYG{n}{Active}       \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}
\PYG{n}{normal}           \PYG{l+m+mi}{30}  \PYG{n}{Open}\PYG{p}{:}\PYG{n}{Active}       \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
由于受水平和时间所限，错误和不妥之处在所难免，欢迎指出错误和改进意见，我们将尽力完善。

\sphinxstepscope


\chapter{现有超级计算系统}
\label{\detokenize{introduction/index:id1}}\label{\detokenize{introduction/index::doc}}
\sphinxstepscope


\section{瀚海22超级计算系统}
\label{\detokenize{introduction/hanhai22-introduction:id1}}\label{\detokenize{introduction/hanhai22-introduction::doc}}
\sphinxAtStartPar
瀚海22超级计算系统，含有2个管理节点、2个用户登录节点、25个8卡GPU计算节点（单节点64颗Intel Xeon Scale 8358 CPU核（2.6GHz，48MB L3 Cache）、1TB内存、8颗NVIDIA A100 Tensor Core GPU（80GB显存、SXM4、600GB/s NVLink卡间互联）），11PB可用容量高性能存储，采用Mellanox HDR 200Gbps InfiniBand高速互联。纯计算节点共1600颗CPU核及200颗A100 GPU，总双精度浮点计算能力：2.07PFLOPS（千万亿次/秒，CPU：0.13PFLOPS，GPU：1.94PFLOPS）；Tensor Float 32(TF32)AI算力：62.4PFLOPS。
\begin{itemize}
\item {} 
\sphinxAtStartPar
管理节点（2个）：

\sphinxAtStartPar
用于系统管理，普通用户无权登录。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
高速网络
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
admin22\sphinxhyphen{}{[}01 \sphinxhyphen{} 02{]}
&
\sphinxAtStartPar
2*Intel Xeon Scale 8358
（2.6GHz，32核，L3 Cache 48MB），64核/节点
&
\sphinxAtStartPar
256GB DDR4
3200MHz
&
\sphinxAtStartPar
2*1.6TB NVMe
&
\sphinxAtStartPar
HDR 100Gbps
InfiniBand
&
\sphinxAtStartPar
浪潮NF5280M6
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
用户登录节点（2个）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
用于用户登录、编译与通过作业调度系统提交管理作业等。

\item {} 
\sphinxAtStartPar
禁止在此节点上不通过作业调度系统直接运行作业。

\end{itemize}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
高速网络
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
hanhai22\sphinxhyphen{}{[}01 \sphinxhyphen{} 02{]}
&
\sphinxAtStartPar
2*Intel Xeon Scale 8358
（2.6GHz，32核，L3 Cache 48MB），64核/节点
&
\sphinxAtStartPar
256GB DDR4
3200MHz
&
\sphinxAtStartPar
2*1.6TB NVMe
&
\sphinxAtStartPar
HDR 100Gbps
InfiniBand
&
\sphinxAtStartPar
浪潮NF5280M6
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
GPU计算节点（25个）：

\sphinxAtStartPar
适合GPU应用，加速性能：\sphinxurl{https://developer.nvidia.com/hpc-application-performance}。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
GPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
高速网络
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
gnode{[}01 \sphinxhyphen{} 25{]}
&
\sphinxAtStartPar
2*Intel Xeon Scale 8358
（2.6GHz，48MB L3 Cache），64核/节点
&
\sphinxAtStartPar
1TB DDR4 3200MHz
&
\sphinxAtStartPar
8*NVIDIA A100
（SXM4，80GB显存）
&
\sphinxAtStartPar
3.84TB NVMe
&
\sphinxAtStartPar
HDR 200Gbps
InfiniBand
&
\sphinxAtStartPar
浪潮NF5688M6
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{单颗NVIDIA A100 Tensor Core GPU参数}\label{\detokenize{introduction/hanhai22-introduction:id2}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
指标
&\sphinxstyletheadfamily 
\sphinxAtStartPar
数值
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
FP64峰值性能
&
\sphinxAtStartPar
9.7TFLOPS
\\
\sphinxhline
\sphinxAtStartPar
FP64 Tensor Core峰值性能
&
\sphinxAtStartPar
19.5TFLOPS
\\
\sphinxhline
\sphinxAtStartPar
FP32峰值性能
&
\sphinxAtStartPar
19.5TFLOPS
\\
\sphinxhline
\sphinxAtStartPar
FP32 Tensor Core峰值性能
&
\sphinxAtStartPar
312TFLOPS
\\
\sphinxhline
\sphinxAtStartPar
BFLOAT16 Tensor Core峰值性能
&
\sphinxAtStartPar
624TFLOPS
\\
\sphinxhline
\sphinxAtStartPar
FP16 Tensor Core峰值性能
&
\sphinxAtStartPar
624TFLOPS
\\
\sphinxhline
\sphinxAtStartPar
INT8 Tensor Core峰值性能
&
\sphinxAtStartPar
1248TOPS
\\
\sphinxhline
\sphinxAtStartPar
GPU显存
&
\sphinxAtStartPar
80GB
\\
\sphinxhline
\sphinxAtStartPar
GPU显存带宽
&
\sphinxAtStartPar
1935GB/s
\\
\sphinxhline
\sphinxAtStartPar
互联
&
\sphinxAtStartPar
NVIDIA NVLink 600GB/s
\\
\sphinxhline
\sphinxAtStartPar
多实例GPU
&
\sphinxAtStartPar
最大7个MIG，每个10GB
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
存储系统：
\begin{itemize}
\item {} 
\sphinxAtStartPar
10台浪潮AS13000G6\sphinxhyphen{}HN12，每台8块3.2TB NVMe SSD硬盘，总可用容量194.6TB

\item {} 
\sphinxAtStartPar
30台浪潮AS13000G6\sphinxhyphen{}HN60，每台59块8TB NL\sphinxhyphen{}SAS 7.2K RPM硬盘，总可用容量11.56PB

\item {} 
\sphinxAtStartPar
文件系统：Spectrum Scale Advanced

\item {} 
\sphinxAtStartPar
默认用户磁盘配额：500GB

\item {} 
\sphinxAtStartPar
IO性能（通过IOR工具）：

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
1MB块读带宽：单流≥6GB/s，聚合≥160GB/s

\item {} 
\sphinxAtStartPar
1MB块写带宽：单流≥6GB/s，聚合≥100GB/s

\item {} 
\sphinxAtStartPar
8KB块IOPS，随机读≥205万，随机写≥80万

\end{itemize}

\item {} 
\sphinxAtStartPar
计算网络：Mellonax HDR 200Gbps InfiniBand

\item {} 
\sphinxAtStartPar
管理网络：千兆以太网

\item {} 
\sphinxAtStartPar
操作系统：Ubuntu Server 22.04 LTS

\item {} 
\sphinxAtStartPar
编译器：Intel、NVIDIA HPC SDK和GNU等C/C++ Fortran、GPU编译器

\item {} 
\sphinxAtStartPar
数值函数库：Intel MKL

\item {} 
\sphinxAtStartPar
并行环境：HPC\sphinxhyphen{}X、Intel MPI和Open MPI等，支持MPI并行程序；各节点内的CPU共享内存，节点内既支持分布式内存的MPI并行方式，也支持共享内存的OpenMP并行方式；同时支持在节点内部共享内存，节点间分布式内存的混合并行模式。

\item {} 
\sphinxAtStartPar
资源管理和作业调度：\sphinxhref{https://slurm.schedmd.com/}{Slurm} 22.05.3

\item {} 
\sphinxAtStartPar
常用公用软件安装目录：\sphinxcode{\sphinxupquote{/opt}}。请自己查看有什么软件，有些软件需要在自己等配置文件中设置后才可以使用。

\end{itemize}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{hanhai22-topo}.png}
\end{figure}

\sphinxstepscope


\section{瀚海20超级计算系统}
\label{\detokenize{introduction/hanhai20-introduction:id1}}\label{\detokenize{introduction/hanhai20-introduction::doc}}
\sphinxAtStartPar
\sphinxhref{https://scc.ustc.edu.cn/2019/1206/c435a407486/page.htm}{瀚海20超级计算系统}采用Mellonax HDR 100Gbps高速互联，具有Intel Xeon Scale 6248、华为鲲鹏920 5250等不同类型CPU及NVIDIA Tesla V100 GPU和华为Atlas 300 AI卡等协处理器，共计2个管理节点、2个用户登录节点、720个普通CPU计算节点（采用高效节能的板级液冷技术）、10个双V100 GPU计算节点、8个2TB Intel AEP大内存节点、20个华为鲲鹏CPU计算节点构成（其中10个各含6颗华为Atlas 300 AI加速卡），计算节点共30480颗CPU核心和20块NVIDIA V100 GPU卡，总双精度浮点计算能力：2.51PFlops（千万亿次/秒，CPU：2.37PFlops，GPU：0.14PFlops），Atlas计算能力：3840 TOPS INT8 + 15360T FLOPS FP16。
\begin{itemize}
\item {} 
\sphinxAtStartPar
管理节点（2个）：

\sphinxAtStartPar
用于系统管理，普通用户无权登录。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
admin{[}01 \sphinxhyphen{}02{]}
&
\sphinxAtStartPar
2*Intel Xeon Scale 6248
(2.5GHz，20核，27.5MB)，40核/节点
&
\sphinxAtStartPar
192GB DDR4
2933MHz
&
\sphinxAtStartPar
2*1TB NVMe
&
\sphinxAtStartPar
华为FusionServer 2288H V5
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
用户登录节点（3个）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
用于用户登录、编译与通过作业调度系统提交管理作业等。

\item {} 
\sphinxAtStartPar
禁止在此节点上不通过作业调度系统直接运行作业。

\end{itemize}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
login{[}01 \sphinxhyphen{} 02{]}
&
\sphinxAtStartPar
2*Intel Xeon Scale 6248(2.5GHz，20核，27.5MB)，40核/节点
&
\sphinxAtStartPar
192GB DDR4 2933MHz
&
\sphinxAtStartPar
2*1TB NVMe
&
\sphinxAtStartPar
华为FusionServer 2288H V5
\\
\sphinxhline
\sphinxAtStartPar
Taishan\sphinxhyphen{}Login
&
\sphinxAtStartPar
16*Hi1620 ARM CPU(2.6GHz)
&
\sphinxAtStartPar
64GB DDR4 2666MHz
&
\sphinxAtStartPar
50GB
&
\sphinxAtStartPar
华为泰山 2280H V2
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
Intel Xeon CPU普通计算节点（720个）：

\sphinxAtStartPar
用于多数作业。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
cnode{[}001 \sphinxhyphen{} 720{]}
&
\sphinxAtStartPar
2*Intel Xeon Scale 6248(2.5GHz，20核，27.5MB)，40核/节点
&
\sphinxAtStartPar
192GB DDR4 2933MHz
&
\sphinxAtStartPar
1*240GB SSD
&
\sphinxAtStartPar
\sphinxhref{http://e.huawei.com/cn/products/servers/x-series/xh321l-v5}{华为FusionServer XH321L V5}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
Intel Xeon CPU 2TB AEP内存计算节点（8个）：

\sphinxAtStartPar
\sphinxhref{https://www.intel.cn/content/www/cn/zh/architecture-and-technology/intel-optane-technology.html?erpm\_id=2040227}{AEP内存}性能低于普通内存，性价比高，适合大内存应用。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
普通内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
AEP内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
anode{[}01 \sphinxhyphen{} 08{]}
&
\sphinxAtStartPar
2*Intel Xeon Scale 6248(2.5GHz，20核，27.5MB)，40核/节点
&
\sphinxAtStartPar
384GB DDR4 2933MHz
&
\sphinxAtStartPar
2TB(8*256GB)
&
\sphinxAtStartPar
1TB NVMe
&
\sphinxAtStartPar
华为FusionServer 2288H V5
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
GPU计算节点（12个）：

\sphinxAtStartPar
适合GPU应用，加速性能：\sphinxurl{https://developer.nvidia.com/hpc-application-performance}。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
GPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
gnode{[}01 \sphinxhyphen{} 10{]}
&
\sphinxAtStartPar
2*Intel Xeon Scale 6248
(2.5GHz，20核，27.5MB)，
40核/节点
&
\sphinxAtStartPar
384GB DDR4 2933MHz
&
\sphinxAtStartPar
2*NVIDIA Tesla V100
&
\sphinxAtStartPar
1TB NVMe
&
\sphinxAtStartPar
华为FusionServer G530 V5
\\
\sphinxhline
\sphinxAtStartPar
gnode\sphinxhyphen{}a100\sphinxhyphen{}{[}1 \sphinxhyphen{} 2{]}
&
\sphinxAtStartPar
2*AMD Rome 7742
(2.25GHz, 64核)，
128核/节点
&
\sphinxAtStartPar
1TB DDR4 3200MHz
&
\sphinxAtStartPar
8*NVIDIA A100 Tensor Core,
40GB，NVLink
&
\sphinxAtStartPar
2*1.92TB+4*3.84TB NVME
&
\sphinxAtStartPar
融科联创RW\sphinxhyphen{}4124GO\sphinxhyphen{}NART
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{单颗NVIDIA Tesla V100 GPU参数}\label{\detokenize{introduction/hanhai20-introduction:id2}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxmultirow{2}{1}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{9}}
\sphinxstyletheadfamily \sphinxAtStartPar
GPU单元
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{2}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{9}}
\sphinxstyletheadfamily \sphinxAtStartPar
显存
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{3}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{9}}
\sphinxstyletheadfamily \sphinxAtStartPar
主频
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{9}}
\sphinxstyletheadfamily \sphinxAtStartPar
核数
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{9}}
\sphinxstyletheadfamily \sphinxAtStartPar
计算能力(TFlops)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxvlinecrossing{1}\sphinxvlinecrossing{2}\sphinxcline{4-9}\sphinxfixclines{9}\sphinxtablestrut{1}&\sphinxtablestrut{2}&\sphinxtablestrut{3}&\sphinxstyletheadfamily 
\sphinxAtStartPar
Tensor
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CUDA
&\sphinxstyletheadfamily 
\sphinxAtStartPar
深度学习
&\sphinxstyletheadfamily 
\sphinxAtStartPar
半精度
&\sphinxstyletheadfamily 
\sphinxAtStartPar
单精度
&\sphinxstyletheadfamily 
\sphinxAtStartPar
双精度
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
GV100
&
\sphinxAtStartPar
32GB HBM2
&
\sphinxAtStartPar
基准1230MHz，
加速1370MHz
&
\sphinxAtStartPar
640
&
\sphinxAtStartPar
5120
&
\sphinxAtStartPar
112
&
\sphinxAtStartPar
28
&
\sphinxAtStartPar
14
&
\sphinxAtStartPar
7
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{单颗NVIDIA A100 Tensor Core GPU参数}\label{\detokenize{introduction/hanhai20-introduction:id3}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
FP64 峰值性能
&
\sphinxAtStartPar
9.7TFLOPS
\\
\sphinxhline
\sphinxAtStartPar
FP64 Tensor Core 峰值性能
&
\sphinxAtStartPar
19.5TFLOPS
\\
\sphinxhline
\sphinxAtStartPar
FP32 峰值性能
&
\sphinxAtStartPar
19.5TFLOPS
\\
\sphinxhline
\sphinxAtStartPar
FP32 Tensor Core 峰值性能
&
\sphinxAtStartPar
312TF*LOPS
\\
\sphinxhline
\sphinxAtStartPar
BFLOAT16 Tensor Core 峰值性能
&
\sphinxAtStartPar
624TF*LOPS
\\
\sphinxhline
\sphinxAtStartPar
FP16 Tensor Core 峰值性能
&
\sphinxAtStartPar
624TF*LOPS
\\
\sphinxhline
\sphinxAtStartPar
INT8 Tensor Core 峰值性能
&
\sphinxAtStartPar
1248TOPS*
\\
\sphinxhline
\sphinxAtStartPar
INT4 Tensor Core 峰值性能
&
\sphinxAtStartPar
2496TOPS*
\\
\sphinxhline
\sphinxAtStartPar
GPU 内存
&
\sphinxAtStartPar
40GB
\\
\sphinxhline
\sphinxAtStartPar
GPU 内存带宽
&
\sphinxAtStartPar
1555GB/s
\\
\sphinxhline
\sphinxAtStartPar
互联
&
\sphinxAtStartPar
NVIDIA NVLink 600GB/s
\\
\sphinxhline
\sphinxAtStartPar
多实例 GPU
&
\sphinxAtStartPar
各种实例大小（最大为 7 MIG @10 GB）
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
鲲鹏计算节点（20个）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
华为ARM V8 CPU，参见：\sphinxurl{https://developer.nvidia.com/hpc-application-performance}。

\item {} 
\sphinxAtStartPar
华为Atlas AI卡，主要提供推理能力，参见：\sphinxurl{https://support.huawei.com/enterprise/zh/ai-computing-platform/atlas-300-pid-23464095}

\item {} 
\sphinxAtStartPar
注：使用华为Atlas卡，需特殊申请，加入HwHiAiUser组才可以（运行\sphinxcode{\sphinxupquote{id}}可以查看自己所在组）。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
计算网络
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
rnode{[}01 \sphinxhyphen{} 09{]}，
rnode{[}11 \sphinxhyphen{} 21{]}
&
\sphinxAtStartPar
2*鲲鹏920 5250
（48核, 2.6GHz）
，96核/节点
&
\sphinxAtStartPar
256GB DDR4
2666MHz
&
\sphinxAtStartPar
1*300GB SAS
&
\sphinxAtStartPar
100Gbps 以太网
（支持RoCE）
&
\sphinxAtStartPar
华为TaiShan 2280 V2
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\end{itemize}

\sphinxAtStartPar
其中：rnode{[}12\sphinxhyphen{}21{]}每台配置6颗Atlas 300 AI卡，rnode{[}01\sphinxhyphen{}11{]}未配置。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{单颗Atlas 300 AI卡参数}\label{\detokenize{introduction/hanhai20-introduction:id4}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{3}{\X{1}{3}|}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
AI算力
&\sphinxstyletheadfamily 
\sphinxAtStartPar
编解码能力
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
LPDDR4x 32 GB，
3200 Mbps
&
\sphinxAtStartPar
64TOPS INT8，
256TFLOPS FP16，
256TFLOPS FP16
&\begin{itemize}
\item {} 
\sphinxAtStartPar
支持H.264硬件解码，64路1080P
30FPS（2路 3840*2160 60FPS）

\item {} 
\sphinxAtStartPar
支持H.265硬件解码，64路1080P
30FPS（2路 3840*2160 60FPS）

\item {} 
\sphinxAtStartPar
支持H.264硬件编码，4路1080P
30FPS

\item {} 
\sphinxAtStartPar
支持H.265硬件编码，4路1080P
30FPS

\item {} 
\sphinxAtStartPar
JPEG解码能力4x 1080P
256FPS，编码能力4x 1080P 64FPS

\item {} 
\sphinxAtStartPar
PNG解码能力4x 1080P 48FPS

\end{itemize}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
存储系统：
\begin{itemize}
\item {} 
\sphinxAtStartPar
1台长虹DDN GS7990 GRID Scaler及2台DDN SS9012磁盘扩展柜，配置280块8TB SATA硬盘

\item {} 
\sphinxAtStartPar
并行文件系统：GRID Scaler

\item {} 
\sphinxAtStartPar
实际可用空间：1.5PB

\item {} 
\sphinxAtStartPar
默认用户磁盘配额：100GB

\end{itemize}

\item {} 
\sphinxAtStartPar
计算网络：Mellonax HDR 100Gbps

\item {} 
\sphinxAtStartPar
管理网络：千兆以太网

\item {} 
\sphinxAtStartPar
操作系统：CentOS Linux 7.7.1908

\item {} 
\sphinxAtStartPar
编译器：Intel、PGI和GNU等C/C++ Fortran编译器

\item {} 
\sphinxAtStartPar
数值函数库：Intel MKL

\item {} 
\sphinxAtStartPar
并行环境：Intel MPI和Open
MPI等，支持MPI并行程序；各节点内的CPU共享内存，节点内既支持分布式内存的MPI并行方式，也支持共享内存的OpenMP并行方式；同时支持在节点内部共享内存，节点间分布式内存的混合并行模式。

\item {} 
\sphinxAtStartPar
资源管理和作业调度：\sphinxhref{https://slurm.schedmd.com/}{Slurm} 19.05.5

\item {} 
\sphinxAtStartPar
常用公用软件安装目录：\sphinxcode{\sphinxupquote{/opt}}。请自己查看有什么软件，有些软件需要在自己等配置文件中设置后才可以使用。

\end{itemize}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{hanhai20-topo}.png}
\end{figure}

\sphinxstepscope


\section{曙光TC4600百万亿次超级计算系统}
\label{\detokenize{introduction/tc4600-introduction:tc4600}}\label{\detokenize{introduction/tc4600-introduction::doc}}
\sphinxAtStartPar
曙光TC4600百万亿次超级计算系统（519万亿次/秒），兼为安徽省教育科研网高性能计算平台，也为入网用户提供高性能计算服务。此套系统采用100Gbps和56Gbps高速互联，具有Intel Xeon E5 2600 v3、E5 2600 v4、E7 8800 v4、E3 1240 v5等不同类型CPU及Intel Xeon Phi和NVIDIA Tesla K80 GPU等处理器，共计1个管理节点、2个用户登录节点、7个存储节点、2个Lustre LNet路由节点及506个计算节点构成。计算节点共12200颗CPU核心，512颗Intel Xeon Phi融核（MIC）KNL核心和39936颗NVIDIA CUDA核心，总双精度峰值计算能力为每秒519万亿次（CPU：482.82万亿次/秒，GPU：14.96万亿次/秒，Intel Xeon Phi融核：21.28万亿次/秒）。
\begin{itemize}
\item {} 
\sphinxAtStartPar
管理节点：

\sphinxAtStartPar
用于系统管理，普通用户无权登录。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
计算网络
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
tcadmin
&
\sphinxAtStartPar
2*Intel
Xeon
E5\sphinxhyphen{}2620
v3
，共12核
&
\sphinxAtStartPar
32GB
DDR4
2133MHz
&
\sphinxAtStartPar
2*600GB
SAS
&
\sphinxAtStartPar
56Gbps
FDR
In
finiBand
&
\sphinxAtStartPar
曙光
I620\sphinxhyphen{}G10
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
用户登录节点（2个）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
用于用户登录、编译与通过作业调度系统提交管理作业等。

\item {} 
\sphinxAtStartPar
Intel Xeon E5 2600 v3、E5 2600 v4和 E7 8800
v4是同一架构CPU，编译时可以通用。

\item {} 
\sphinxAtStartPar
禁止在此节点上不通过作业调度系统直接运行作业。

\end{itemize}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
计算网络
&\sphinxstyletheadfamily 
\sphinxAtStartPar
型号
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
tc4600v3
&
\sphinxAtStartPar
2*Intel Xeon
E5\sphinxhyphen{}2620 v3
，共12核
&
\sphinxAtStartPar
32GB DDR4
2133MHz
&
\sphinxAtStartPar
2*600GB SAS
&
\sphinxAtStartPar
56Gbps FDR
InfiniBand
&
\sphinxAtStartPar
曙光
I620\sphinxhyphen{}G10
\\
\sphinxhline
\sphinxAtStartPar
tc4600v4
&
\sphinxAtStartPar
2*Intel Xeon
E5\sphinxhyphen{}2620 v4
，共16核
&
\sphinxAtStartPar
64GB DDR4
2133MHz
&
\sphinxAtStartPar
2*240GB SSD
&
\sphinxAtStartPar
100Gbps Intel
OPA
&
\sphinxAtStartPar
曙光
I620\sphinxhyphen{}G10
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
Intel Xeon CPU计算节点（494个）：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
数量
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
计算网络
&\sphinxstyletheadfamily 
\sphinxAtStartPar
备注
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
node{[}1 \sphinxhyphen{} 300{]}
&
\sphinxAtStartPar
300
&
\sphinxAtStartPar
2*Intel Xeon E5\sphinxhyphen{}2680v3
(2.5GHz，30MB L3 Cache)，
共24核
&
\sphinxAtStartPar
64GB DDR4
2133MHz
&
\sphinxAtStartPar
1*300GB
SAS
&
\sphinxAtStartPar
56Gbps FDR
InfiniBand
&
\sphinxAtStartPar
曙光CX50\sphinxhyphen{}G20
\\
\sphinxhline
\sphinxAtStartPar
node{[}301 \sphinxhyphen{} 450{]}
&
\sphinxAtStartPar
150
&
\sphinxAtStartPar
2*Intel Xeon E5\sphinxhyphen{}2680 v4
(2.4GHz, L3 Cache)，
共28核
&
\sphinxAtStartPar
128GB DDR4
2400MHz
&
\sphinxAtStartPar
1*240GB
SSD
&
\sphinxAtStartPar
100Gbps
Intel OPA
&
\sphinxAtStartPar
曙光CX50\sphinxhyphen{}G20
X50\sphinxhyphen{}G20
\\
\sphinxhline
\sphinxAtStartPar
node{[}451 \sphinxhyphen{} 490{]}
&
\sphinxAtStartPar
40
&
\sphinxAtStartPar
1*Intel Xeon E3\sphinxhyphen{}1240 v5
(3.5GHz, 8MB L3 Cache)
，共4核
&
\sphinxAtStartPar
32GB DDR4
2400MHz
&
\sphinxAtStartPar
1*240GB
SSD
&
\sphinxAtStartPar
25Gbps EDR
Infiniband
&
\sphinxAtStartPar
曙光CX50\sphinxhyphen{}G20，高主频，
每四个节点通过一块
Mellonax Multi\sphinxhyphen{}Host互联
\\
\sphinxhline
\sphinxAtStartPar
node{[}491 \sphinxhyphen{} 494{]}
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
8*Intel Xeon E7\sphinxhyphen{}8860 v4
(2.2GHz, 45MB L3 Cache)，
共144核
&
\sphinxAtStartPar
1TB DDR4
2400MHz
&
\sphinxAtStartPar
2*240GB
SSD
&
\sphinxAtStartPar
100Gbps
Intel OPA
&
\sphinxAtStartPar
曙光I980\sphinxhyphen{}G20，
大共享内存
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
Intel Xeon融核计算节点（8个）：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
数量
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
计算网络
&\sphinxstyletheadfamily 
\sphinxAtStartPar
备注
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
knl{[}1 \sphinxhyphen{} 8{]}
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
1*Intel Xeon Phi 7210
(64核，1.3GHz 16GB
MCDRAM，2.66万亿次/秒)
&
\sphinxAtStartPar
96GB DDR4
2133MHz
&
\sphinxAtStartPar
1*160GB
SSD
&
\sphinxAtStartPar
100Gbps
Intel OPA
&
\sphinxAtStartPar
曙光I620\sphinxhyphen{}T25
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
GPU计算节点（4个）：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
节点名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
数量
&\sphinxstyletheadfamily 
\sphinxAtStartPar
GPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CPU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
硬盘
&\sphinxstyletheadfamily 
\sphinxAtStartPar
计算网络
&\sphinxstyletheadfamily 
\sphinxAtStartPar
备注
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
k80{[}1 \sphinxhyphen{} 4{]}
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
2*NVIDIA
Tesla K80
&
\sphinxAtStartPar
2*Intel Xeon E5\sphinxhyphen{}2680 v4
(2.4GHz, 30MB L3 Cache)，
共28核
&
\sphinxAtStartPar
128GB DDR4
2400MHz
&
\sphinxAtStartPar
2*240GB
SSD
&
\sphinxAtStartPar
100Gbps
Intel OPA
&
\sphinxAtStartPar
曙光W740\sphinxhyphen{}G20
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
单颗NVIDIA Tesla K80 GPU参数


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
GPU单元
&\sphinxstyletheadfamily 
\sphinxAtStartPar
显存
&\sphinxstyletheadfamily 
\sphinxAtStartPar
主频
&\sphinxstyletheadfamily 
\sphinxAtStartPar
CUDA计算核心数
&\sphinxstyletheadfamily 
\sphinxAtStartPar
单精度计算能力
&\sphinxstyletheadfamily 
\sphinxAtStartPar
双精度计算能力
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
2*GK210
&
\sphinxAtStartPar
24GB GDDR5
&
\sphinxAtStartPar
562MHz, GPU Boost 875MHz
&
\sphinxAtStartPar
4992
&
\sphinxAtStartPar
5.6万亿次/秒
&
\sphinxAtStartPar
1.87万亿次/秒
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
存储系统：
\begin{itemize}
\item {} 
\sphinxAtStartPar
Lustre SATA并行存储系统：
\begin{itemize}
\item {} 
\sphinxAtStartPar
曙光DS800\sphinxhyphen{}G10机架式存储，34块4TB SATA硬盘，实际可用空间102TB

\item {} 
\sphinxAtStartPar
Lustre并行IO节点（io1\sphinxhyphen{}io4，曙光I620\sphinxhyphen{}G10机架式服务器4台）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
两颗64位主频2.1GHz的Intel Xeon E5\sphinxhyphen{}2620 v2 x86\_64
6核CPU，共12核

\item {} 
\sphinxAtStartPar
32GB DDR3 1600MHz内存

\item {} 
\sphinxAtStartPar
两块600GB SAS硬盘

\item {} 
\sphinxAtStartPar
一块56Gbps FDR InfiniBand卡

\item {} 
\sphinxAtStartPar
一块8Gbps FC卡

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
Lustre SSD闪存并行存储系统：
\begin{itemize}
\item {} 
\sphinxAtStartPar
高IO读写性能，仅提供有需要的特殊用户使用，需特殊申请

\item {} 
\sphinxAtStartPar
联想S3200机架式存储，24块4GB SSD硬盘，实际可用空间7TB

\item {} 
\sphinxAtStartPar
Lustre并行IO节点（io6、io7，联想System x3650
M5机架式服务器2台）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
两颗64位主频2.2GHz的Intel Xeon E5\sphinxhyphen{}2630 v4 x86\_64
10核CPU，共20核

\item {} 
\sphinxAtStartPar
64GB DDR4 2400MHz ECC REG内存

\item {} 
\sphinxAtStartPar
两块240GB SSD硬盘

\item {} 
\sphinxAtStartPar
一块56Gbps FDR InfiniBand卡

\item {} 
\sphinxAtStartPar
两块16Gbps 双口FC卡

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
Lustre LNet路由节点：
\begin{itemize}
\item {} 
\sphinxAtStartPar
用途：Intel
OPA高速计算网络节点通过此路由节点访问基于InifiniBand高速网络的Lustre存储

\item {} 
\sphinxAtStartPar
节点名：lnet1、lnet2

\item {} 
\sphinxAtStartPar
曙光I620\sphinxhyphen{}G20机架式服务器2台

\item {} 
\sphinxAtStartPar
各节点配置：
\begin{itemize}
\item {} 
\sphinxAtStartPar
两颗64位主频2.1GHz的Intel Xeon E5\sphinxhyphen{}2620 v4 x86\_64
8核CPU，共16核

\item {} 
\sphinxAtStartPar
64GB DDR4 2400MHz ECC REG内存

\item {} 
\sphinxAtStartPar
两块240GB SSD硬盘

\item {} 
\sphinxAtStartPar
一块100Gbps Intel OFI卡

\item {} 
\sphinxAtStartPar
一块56Gbps FDR InfiniBand卡

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
NFS普通IO节点：
\begin{itemize}
\item {} 
\sphinxAtStartPar
节点名：io5

\item {} 
\sphinxAtStartPar
曙光I620\sphinxhyphen{}G20机架式服务器，实际可用空间30TB：
\begin{itemize}
\item {} 
\sphinxAtStartPar
两颗主频2.6GHz的Intel Xeon E5\sphinxhyphen{}2640 v3 x86\_64 8核CPU，共16核

\item {} 
\sphinxAtStartPar
64GB DDR4 2133MHz ECC REG内存

\item {} 
\sphinxAtStartPar
12块4TB 3.5寸7.2K NL\sphinxhyphen{}SAS硬盘

\item {} 
\sphinxAtStartPar
1块2GB Cache RAID卡

\item {} 
\sphinxAtStartPar
1块56Gbps FDR InfiniBand双端口HCA卡

\end{itemize}

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
高速计算网络：
\begin{itemize}
\item {} 
\sphinxAtStartPar
100Gbps Intel Omni Path全线速高速网，Intel 100SWD06
192口交换机一台

\item {} 
\sphinxAtStartPar
100Gbps EDR InfiniBand高速网，Mellanox SB7800 36口交换机一台

\item {} 
\sphinxAtStartPar
56Gbps FDR InfiniBand准全线速高速网，Mellanox SX6512 216口、SX6506
108口交换机各一台

\end{itemize}

\item {} 
\sphinxAtStartPar
管理网络：千兆以太网

\item {} 
\sphinxAtStartPar
操作系统：CentOS 7.3 Linux

\item {} 
\sphinxAtStartPar
编译器：Intel、PGI和GNU等C/C++ Fortran编译器

\item {} 
\sphinxAtStartPar
数值函数库：Intel MKL

\item {} 
\sphinxAtStartPar
并行环境：Intel MPI和Open
MPI等，支持MPI并行程序；各节点内的CPU共享内存，节点内既支持分布式内存的MPI并行方式，也支持共享内存的OpenMP并行方式；同时支持在节点内部共享内存，节点间分布式内存的混合并行模式。

\item {} 
\sphinxAtStartPar
资源管理和作业调度：IBM Spectrum LSF

\item {} 
\sphinxAtStartPar
常用公用软件安装目录：。请自己查看有什么软件，有些软件需要在自己等配置文件中设置后才可以使用。

\end{itemize}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{tc4600-topo}.png}
\end{figure}

\sphinxstepscope


\chapter{用户登录与文件传输}
\label{\detokenize{login-ftp/login-ftp:id1}}\label{\detokenize{login-ftp/login-ftp::doc}}
\sphinxAtStartPar
本超算系统的操作系统为64位 \sphinxstylestrong{CentOS 7.x} 和 \sphinxstylestrong{Ubuntu Server 22.04 LTS Linux} ，用户需以 \sphinxstylestrong{SSH} 方式（在MS Windows下可利用PuTTY、Xshell等支持 \sphinxstylestrong{SSH} 协议的客户端软件 %
\begin{footnote}[1]\sphinxAtStartFootnote
客户端下载：\sphinxurl{http://scc.ustc.edu.cn/411/list.htm}
%
\end{footnote}，Windows的命令行也支持ssh及sftp命令）登录到用户登录节点后进行编译、提交作业等操作。用户数据可以利用 \sphinxstylestrong{SFTP} （不支持FTP）协议进行数据传输。

\sphinxAtStartPar
本超算系统禁止SSH密钥登录，并且采用google authenticator二次验证，用法参见：\sphinxurl{http://scc.ustc.edu.cn/2018/0926/c409a339006/page.htm}。

\sphinxAtStartPar
用户若10分钟内5次密码错误登录，那么登录时所使用IP将被自动封锁10分钟禁止登录，之后自动解封，可以等待10分钟后再尝试，或换个IP登录，或联系超算中心老师解封。

\sphinxAtStartPar
本超算系统可从校内IP登录，校外一般无法直接访问。如果需要从校外等登录，可以使用\sphinxhref{http://openvpn.ustc.edu.cn}{学校的VPN}（教师的\sphinxhref{http://wlt.ustc.edu.cn}{网络通}带有此功能，学生的不带），或者申请校超算中心VPN（\sphinxurl{http://scc.ustc.edu.cn/vpn/}）。

\sphinxAtStartPar
用户修改登录密码及shell，只能通过\sphinxurl{http://scc.ustc.edu.cn/user/chpasswd.php}修改密码，而不能通过\sphinxcode{\sphinxupquote{passwd}}和\sphinxcode{\sphinxupquote{chsh}}修改。请不要设置简单密码和向无关人员泄漏密码，以免给用户造成损失。如果忘记密码，请邮件（\sphinxhref{mailto:sccadmin@ustc.edu.cn}{sccadmin@ustc.edu.cn}）联系中心老师申请重置，并需提供帐号名、所在超算系统名称等必要信息。

\sphinxAtStartPar
用户登录进来的默认语言环境为zh\_CN.UTF\sphinxhyphen{}8中文 %
\begin{footnote}[2]\sphinxAtStartFootnote
SSH Secure Shell Client不支持UTF\sphinxhyphen{}8中文，不建议使用
%
\end{footnote}，以方便查看登录后的中文提示。如希望使用英文或GBK中文，可以在自己的中添加\sphinxcode{\sphinxupquote{export LC\_ALL=C}}或 \sphinxcode{\sphinxupquote{export LC\_ALL=zh\_CN.GBK}}。

\sphinxAtStartPar
登录进来后请注意登录后的中文提示，或运行\sphinxcode{\sphinxupquote{cat /etc/motd}}查看登录提示，也可以运行\sphinxcode{\sphinxupquote{faq}}命令查看常见问题的回答。

\sphinxAtStartPar
您可运行\sphinxcode{\sphinxupquote{du \sphinxhyphen{}hs}} 可以查看目录占用的空间。请及时清除不需要的文件，以释放空间。如需更大存储空间，请与超算中心老师联系，并说明充分理由及所需大小。

\sphinxAtStartPar
超算中心不提供数据备份服务，数据一但丢失或误删将无法恢复，\sphinxstylestrong{请务必及时下载保存自己的数据}。

\sphinxAtStartPar
\sphinxhref{http://www.centos.org/}{CentOS}(Community ENTerprise Operating System)是Linux主流发行版之一，它来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成；Ubuntu基于Debian开发而成。一般来说可以用\sphinxcode{\sphinxupquote{man 命令}}或命令加\sphinxcode{\sphinxupquote{\sphinxhyphen{}h}}或\sphinxcode{\sphinxupquote{–help}}等选项来查看该命令的详细用法，详细信息可参考CentOS、Red Hat Enterprise Linux、Ubuntu、Debian手册或通用Linux手册。

\sphinxstepscope


\chapter{设置编译及运行环境}
\label{\detokenize{module-environment/module-environment:module}}\label{\detokenize{module-environment/module-environment:id1}}\label{\detokenize{module-environment/module-environment::doc}}
\sphinxAtStartPar
本超算系统安装了多种编译环境及应用等，为方便用户使用，采用\sphinxhref{http://modules.sourceforge.net/}{Environment Modules}工具对其进行了封装，用户可以利用\sphinxcode{\sphinxupquote{module}}命令设置、查看所需要的环境等。编译和运行程序时在命令行可用\sphinxcode{\sphinxupquote{module load modulefile}}加载对应的模块（仅对该次登录生效），如不想每次都手动设置，可将其设置在 或 文件中：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textasciitilde{}/.bashrc}} ，只Bash启动时设置：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
module load intel/2020
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textasciitilde{}/.modulerc}} ，每次module命令启动时都设置：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}Module1.0}
module load intel/2020
\end{sphinxVerbatim}

\sphinxAtStartPar
注意第一行\#\%Module1.0是必需的。

\sphinxAtStartPar
module基本语法为：\sphinxcode{\sphinxupquote{module {[} switches {]} {[} sub\sphinxhyphen{}command {]} {[} sub\sphinxhyphen{}command\sphinxhyphen{}args {]}}}

\sphinxAtStartPar
常用开关参数(switches)：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}help, \sphinxhyphen{}H：显示帮助。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}force, \sphinxhyphen{}f：强制激活依赖解决。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}terse, \sphinxhyphen{}t：以短格式显示。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}long, \sphinxhyphen{}l：以长格式显示。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}human, \sphinxhyphen{}h：以易读方式显示。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}verbose, \sphinxhyphen{}v：显示module命令执行时的详细信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}silent, \sphinxhyphen{}s：静默模式，不显示出错信息等。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}icase, \sphinxhyphen{}i：搜索时不区分大小写。

\end{itemize}

\sphinxAtStartPar
常用子命令(sub\sphinxhyphen{}command)：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{avail {[}path...{]}}}：显示MODULEPATH环境变量中设置的目录中的某个目录下可用的模块，如有参数指定，则显示MODULEPATH中符合这个参数的路径。如\sphinxcode{\sphinxupquote{module avail}}：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{Modules}\PYG{o}{/}\PYG{n}{app} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{gaussian}\PYG{o}{/}\PYG{n}{g16}\PYG{o}{.}\PYG{n}{C01} \PYG{n}{vasp}\PYG{o}{/}\PYG{l+m+mf}{5.4}\PYG{l+m+mf}{.4}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2020} \PYG{n}{vasp}\PYG{o}{/}\PYG{l+m+mf}{5.4}\PYG{l+m+mf}{.4}\PYG{o}{/}\PYG{n}{vtst}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2020}
\PYG{n}{matlab}\PYG{o}{/}\PYG{l+m+mi}{2019}\PYG{n}{b} \PYG{n}{vasp}\PYG{o}{/}\PYG{l+m+mf}{5.4}\PYG{l+m+mf}{.4}\PYG{o}{/}\PYG{n}{intelmpimkl2018u4}
\PYG{n}{vasp}\PYG{o}{/}\PYG{l+m+mf}{5.4}\PYG{l+m+mf}{.4}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2019.}\PYG{n}{update5}\PYG{o}{\PYGZhy{}}\PYG{n}{novtst}
\PYG{n}{vasp}\PYG{o}{/}\PYG{l+m+mf}{5.4}\PYG{l+m+mf}{.4}\PYG{o}{/}\PYG{n}{vtst}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2019.}\PYG{n}{update5}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{Modules}\PYG{o}{/}\PYG{n}{compiler} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{cuda}\PYG{o}{/}\PYG{l+m+mf}{10.2}\PYG{l+m+mf}{.89} \PYG{n}{gcc}\PYG{o}{/}\PYG{l+m+mf}{7.5}\PYG{l+m+mf}{.0} \PYG{n}{gcc}\PYG{o}{/}\PYG{l+m+mf}{8.3}\PYG{l+m+mf}{.0} \PYG{n}{gcc}\PYG{o}{/}\PYG{l+m+mf}{9.2}\PYG{l+m+mf}{.0} \PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{2018.}\PYG{n}{update4}
\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mf}{2019.}\PYG{n}{update5} \PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{2020}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{Modules}\PYG{o}{/}\PYG{n}{lib} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{mkl}\PYG{o}{/}\PYG{l+m+mf}{2018.}\PYG{n}{update4} \PYG{n}{mkl}\PYG{o}{/}\PYG{l+m+mf}{2019.}\PYG{n}{update5} \PYG{n}{mkl}\PYG{o}{/}\PYG{l+m+mi}{2020}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{Modules}\PYG{o}{/}\PYG{n}{mpi} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{hpcx}\PYG{o}{/}\PYG{n}{hpcx} \PYG{n}{hpcx}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{mt} \PYG{n}{hpcx}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{prof}\PYG{o}{\PYGZhy{}}\PYG{n}{ompi} \PYG{n}{intelmpi}\PYG{o}{/}\PYG{l+m+mi}{2020}
\PYG{n}{openmpi}\PYG{o}{/}\PYG{l+m+mf}{4.0}\PYG{l+m+mf}{.2}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{2020} \PYG{n}{hpcx}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{debug} \PYG{n}{hpcx}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{mt}\PYG{o}{\PYGZhy{}}\PYG{n}{ompi}
\PYG{n}{hpcx}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{stack} \PYG{n}{openmpi}\PYG{o}{/}\PYG{l+m+mf}{3.0}\PYG{l+m+mf}{.5}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{/}\PYG{l+m+mf}{9.2}\PYG{l+m+mf}{.0} \PYG{n}{hpcx}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{debug}\PYG{o}{\PYGZhy{}}\PYG{n}{ompi}
\PYG{n}{hpcx}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{ompi} \PYG{n}{intelmpi}\PYG{o}{/}\PYG{l+m+mf}{2018.}\PYG{n}{update4} \PYG{n}{openmpi}\PYG{o}{/}\PYG{l+m+mf}{3.0}\PYG{l+m+mf}{.5}\PYG{o}{/}\PYG{n}{intel}\PYG{o}{/}\PYG{l+m+mi}{2020}
\PYG{n}{hpcx}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2019.}\PYG{n}{update5} \PYG{n}{hpcx}\PYG{o}{/}\PYG{n}{hpcx}\PYG{o}{\PYGZhy{}}\PYG{n}{prof} \PYG{n}{intelmpi}\PYG{o}{/}\PYG{l+m+mf}{2019.}\PYG{n}{update5}
\PYG{n}{openmpi}\PYG{o}{/}\PYG{l+m+mf}{4.0}\PYG{l+m+mf}{.2}\PYG{o}{/}\PYG{n}{gcc}\PYG{o}{/}\PYG{l+m+mf}{9.2}\PYG{l+m+mf}{.0}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{Modules}\PYG{o}{/}\PYG{n}{python} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{anaconda3} \PYG{n}{python}\PYG{o}{/}\PYG{l+m+mf}{3.8}\PYG{l+m+mf}{.1}
\end{sphinxVerbatim}

\sphinxAtStartPar
上面输出：
\begin{itemize}
\item {} 
\sphinxAtStartPar
/opt/Modules/mpi：模块所在的目录，由\sphinxcode{\sphinxupquote{MODULEPATH}}环境变量中设定。

\item {} 
\sphinxAtStartPar
openmpi/3.0.5/intel/2020：模块名或模块文件modulefile，此表示此为3.0.5版本Open
MPI，而且是采用2020版本Intel编译器编译的。

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{help {[}modulefile...{]}}}：显示每个子命令的用法，如给定modulefile参数，则显示modulefile中的帮助信息。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{add|load modulefile...}}：加载modulefile中设定的环境，如\sphinxcode{\sphinxupquote{module load openmpi/3.0.5/intel/2020}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rm|unload modulefile...}}：卸载已加载的环境modulefile，如\sphinxcode{\sphinxupquote{module unload openmpi/3.0.5/intel/2020}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{swap|switch {[}modulefile1{]} modulefile2}}：用modulefile2替换当前已加载的modulefile1，如modulefile1没指定，则交换与modulefile2同样根目录下的当前已加载modulefile。

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{show|display  modulefile...}}：显示modulefile环境变量信息。如
\item[] \sphinxcode{\sphinxupquote{module show openmpi/3.0.5/intel/2020}}
\end{DUlineblock}

\sphinxAtStartPar
上面输出：
\begin{itemize}
\item {} 
\sphinxAtStartPar
第一行是modulefile具体路径。

\item {} 
\sphinxAtStartPar
module\sphinxhyphen{}whatis：模块说明，后面可用子命令whatis、apropos、keyword等显示或搜索。

\item {} 
\sphinxAtStartPar
module load：表示自动加载的模块。

\item {} 
\sphinxAtStartPar
prepend\sphinxhyphen{}path：表示将对应目录加到对应环境变量的前面。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{clear}}：强制module软件相信当前没有加载任何modulefiles。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{purge}}：卸载所有加载的modulefiles。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refresh}}：强制刷新所有当前加载的不安定的组件。一般用于aliases需要重新初始化，但环境比那两已经被当前加载的模块设置了的派生shell中。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{whatis {[}modulefile...{]}}}：显示modulefile中module\sphinxhyphen{}whatis命令指明的关于此modulefile的说明，如果没有指定modulefile，则显示所有modulefile的。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{apropos|keyword string}}：在modulefile中module\sphinxhyphen{}whatis命令指明的关于此modulefile的说明中搜索关键字，显示符合的modulefile。

\end{itemize}

\sphinxAtStartPar
其它一些不常用命令及参数，请\sphinxcode{\sphinxupquote{man module}}查看。

\sphinxAtStartPar
用户也可自己生成自己所需要的modulefile文件，用\sphinxcode{\sphinxupquote{MODULEFILE}}和环境变量来指该modulefile文件所在目录，用\sphinxcode{\sphinxupquote{module}}来设置，具体请\sphinxcode{\sphinxupquote{man module}}及\sphinxcode{\sphinxupquote{man modulefile}}。

\sphinxstepscope


\chapter{串行及OpenMP程序编译及运行}
\label{\detokenize{serial-compiling/serial-compiling:openmp}}\label{\detokenize{serial-compiling/serial-compiling::doc}}
\sphinxAtStartPar
在本超算系统上可运行C/C++、Fortran的串行程序，以及与OpenMP和MPI结合的并行程序。编译程序时，用户只需在登录节点(login01、login02)上以相应的编译命令和选项进行编译即可（用户不应到其余节点上进行编译，以免影响系统效率。其它节点一般只设置了运行作业所需要的库路径等，未必设置了编译环境）。当前安装的编译环境主要为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
C/C++、Fortran编译器：Intel、PGI %
\begin{footnote}[1]\sphinxAtStartFootnote
目前尚未配置，等以后配置上
%
\end{footnote} 和GNU编译器，支持OpenMP并行。

\item {} 
\sphinxAtStartPar
MPI并行环境：HPC\sphinxhyphen{}X、Open MPI和Intel MPI并行环境。

\end{itemize}

\sphinxAtStartPar
安装目录为 \sphinxcode{\sphinxupquote{/opt}} 等，系统设置采用module进行管理（参见\sphinxhref{../module-environment/module-environment.html\#module}{{[}module{]}}），用户可以采用下述方式之一等需设置自己所需的编译环境运行，如：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{module load intel/2020}}

\item {} 
\sphinxAtStartPar
在中设置（设置完成后需要\sphinxcode{\sphinxupquote{source \textasciitilde{}/.bashrc}}或重新登录以便设置生效）：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
. /opt/intel/2020/bin/compilervars.sh intel64
\end{sphinxVerbatim}

\sphinxAtStartPar
注意：在中设置的级别有可能要高于使用\sphinxcode{\sphinxupquote{module load}}设置的，可以运行\sphinxcode{\sphinxupquote{icc \sphinxhyphen{}v}}或\sphinxcode{\sphinxupquote{which icc}}等命令查看实际使用的编译环境。

\sphinxAtStartPar
建议采用对一般程序来说性能较好的Intel编译器，用户也可以选择适合自己程序的编译器，以取得更好的性能。

\sphinxAtStartPar
本部分主要介绍串行C/C++
Fortran源程序和OpenMP并行程序的编译，MPI并行程序的编译将在后面介绍。


\section{串行C/C++程序的编译}
\label{\detokenize{serial-compiling/serial-compiling:c-c}}

\subsection{输入输出文件后缀与类型的关系}
\label{\detokenize{serial-compiling/serial-compiling:id2}}
\sphinxAtStartPar
编译器默认将按照输入文件的后缀判断文件类型，见下表。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{输入文件后缀与类型的关系}\label{\detokenize{serial-compiling/serial-compiling:id10}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
文件名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
解释
&\sphinxstyletheadfamily 
\sphinxAtStartPar
动作
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
filename.c
filename.C
filename.CC
&
\sphinxAtStartPar
C源文件
&
\sphinxAtStartPar
传给编译器
\\
\sphinxhline
\sphinxAtStartPar
filename.cc
filename.cpp
filename.cxx
&
\sphinxAtStartPar
C++源文件
&
\sphinxAtStartPar
传给编译器
\\
\sphinxhline
\sphinxAtStartPar
filename.a
filename.so
&
\sphinxAtStartPar
静态链接库文件
动态链接库文件
&
\sphinxAtStartPar
传递给链接器
\\
\sphinxhline
\sphinxAtStartPar
filename.i
&
\sphinxAtStartPar
已预处理的文件
&
\sphinxAtStartPar
传递给标准输出
\\
\sphinxhline
\sphinxAtStartPar
filename.o
&
\sphinxAtStartPar
目标文件
&
\sphinxAtStartPar
传递给链接器
\\
\sphinxhline
\sphinxAtStartPar
filename.s
&
\sphinxAtStartPar
汇编文件
&
\sphinxAtStartPar
传递给汇编器
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
编译器默认将输出按照文件类型与后缀相对应，见下表。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{输出文件后缀与文件类型的关系}\label{\detokenize{serial-compiling/serial-compiling:id11}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
文件名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
解释
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
filename.i
&
\sphinxAtStartPar
已预处理的文件，一般使用\sphinxhyphen{}p选项生成
\\
\sphinxhline
\sphinxAtStartPar
filename.o
&
\sphinxAtStartPar
目标文件，一般使用\sphinxhyphen{}c选项生成
\\
\sphinxhline
\sphinxAtStartPar
filename.s
&
\sphinxAtStartPar
汇编文件，一般使用\sphinxhyphen{}s选项生成
\\
\sphinxhline
\sphinxAtStartPar
a.out
&
\sphinxAtStartPar
默认生成的可执行文件
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{串行C/C++程序编译举例}
\label{\detokenize{serial-compiling/serial-compiling:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Intel C/C++编译器：
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog.c编译为可执行文件yourprog：
\item[] \sphinxcode{\sphinxupquote{icc \sphinxhyphen{}o yourprog yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将C++程序yourprog.cpp编译为可执行文件yourprog：
\item[] \sphinxcode{\sphinxupquote{icpc \sphinxhyphen{}o yourprog yourprog.cpp}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog.c编译为对象文件yourprog.o而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{icc \sphinxhyphen{}c yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog.c编译为汇编文件yourprog.s而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{icc \sphinxhyphen{}S yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 生成带有调试信息的可执行文件以用于调试：
\item[] \sphinxcode{\sphinxupquote{icc \sphinxhyphen{}g yourprog.c \sphinxhyphen{}o yourprog}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定头文件路径编译：
\item[] \sphinxcode{\sphinxupquote{icc \sphinxhyphen{}I/alt/include \sphinxhyphen{}o yourprog yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定库文件路径及库名编译：
\item[] \sphinxcode{\sphinxupquote{icc \sphinxhyphen{}L/alt/lib \sphinxhyphen{}lxyz \sphinxhyphen{}o yourprog yourprog.c}}
\end{DUlineblock}

\end{itemize}

\item {} 
\sphinxAtStartPar
PGI C/C++编译器：
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog.c编译为可执行文件yourprog：
\item[] \sphinxcode{\sphinxupquote{pgcc \sphinxhyphen{}o yourprog yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将C++程序yourprog.cpp编译为可执行文件yourprog：
\item[] \sphinxcode{\sphinxupquote{pgCC \sphinxhyphen{}o yourprog yourprog.cpp}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog.c编译为对象文件yourprog.o而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{pgcc \sphinxhyphen{}c yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog.c编译为汇编文件yourprog.s而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{pgcc \sphinxhyphen{}S yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 生成带有调试信息的可执行文件以用于调试：
\item[] \sphinxcode{\sphinxupquote{pgcc \sphinxhyphen{}g yourprog.c \sphinxhyphen{}o yourprog}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定头文件路径编译：
\item[] \sphinxcode{\sphinxupquote{pgcc \sphinxhyphen{}I/alt/include \sphinxhyphen{}o yourprog yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定库文件路径及库名(\sphinxhyphen{}l)编译：
\item[] \sphinxcode{\sphinxupquote{pgcc \sphinxhyphen{}L/alt/lib \sphinxhyphen{}lxyz \sphinxhyphen{}o yourprog yourprog.c}}
\end{DUlineblock}

\end{itemize}

\item {} 
\sphinxAtStartPar
GNU C/C++编译器：
\begin{itemize}
\item {} 
\sphinxAtStartPar
将C程序yourprog.c编译为可执行文件yourprog：
\sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}o yourprog yourprog.c}}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将C++程序yourprog.cpp编译为可执行文件yourprog：
\item[] \sphinxcode{\sphinxupquote{g++ \sphinxhyphen{}o yourprog yourprog.cpp}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog.c编译为对象文件yourprog.o而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}c yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog.c编译为汇编文件yourprog.s而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}S yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 生成带有调试信息的可执行文件以用于调试：
\item[] \sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}g yourprog.c \sphinxhyphen{}o yourprog}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定头文件路径编译：
\item[] \sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}I/alt/include \sphinxhyphen{}o yourprog yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定库文件路径及库名编译：
\item[] \sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}L/alt/lib \sphinxhyphen{}lxyz \sphinxhyphen{}o yourprog yourprog.c}}
\end{DUlineblock}

\end{itemize}

\end{itemize}


\section{串行Fortran程序的编译}
\label{\detokenize{serial-compiling/serial-compiling:fortran}}

\subsection{输入输出文件后缀与类型的关系}
\label{\detokenize{serial-compiling/serial-compiling:id4}}\label{\detokenize{serial-compiling/serial-compiling:id5}}
\sphinxAtStartPar
编译器默认将按照输入文件的后缀判断文件类型，见下表。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{输入文件后缀与文件类型的关系}\label{\detokenize{serial-compiling/serial-compiling:id12}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
文件名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
解释
&\sphinxstyletheadfamily 
\sphinxAtStartPar
动作
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
filename.a
&
\sphinxAtStartPar
静态链接库文件，多个.o
文件的打包集合
&
\sphinxAtStartPar
传给编译器
\\
\sphinxhline
\sphinxAtStartPar
filename.f
filename.for
filename.ftn
filename.i
&
\sphinxAtStartPar
固定格式的Fortran源文件
&
\sphinxAtStartPar
被Fortran编译器编译
\\
\sphinxhline
\sphinxAtStartPar
filename.fpp
filename.FPP
filename.F
filename.FOR
filename.FTN
&
\sphinxAtStartPar
固定格式的Fortran源文件
&
\sphinxAtStartPar
自动被Fortran编译器
预处理后再被编译
\\
\sphinxhline
\sphinxAtStartPar
filename.f90
filename.i90
&
\sphinxAtStartPar
自由格式的Fortran源文件
&
\sphinxAtStartPar
被Fortran编译器编译
\\
\sphinxhline
\sphinxAtStartPar
filename.F90
&
\sphinxAtStartPar
自由格式的Fortran源文件
&
\sphinxAtStartPar
自动被Fortran编译器
预处后再被编译
\\
\sphinxhline
\sphinxAtStartPar
filename.s
&
\sphinxAtStartPar
汇编文件
&
\sphinxAtStartPar
传递给汇编器
\\
\sphinxhline
\sphinxAtStartPar
filename.so
&
\sphinxAtStartPar
动态链接库文
件，多个.o文件的打包集合
&
\sphinxAtStartPar
传递给链接器
\\
\sphinxhline
\sphinxAtStartPar
filename.o
&
\sphinxAtStartPar
目标文件
&
\sphinxAtStartPar
传递给链接器
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
编译器默认将输出按照文件类型与后缀相对应，见下表。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{输出文件后缀与类型的关系}\label{\detokenize{serial-compiling/serial-compiling:id13}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
文件名
&\sphinxstyletheadfamily 
\sphinxAtStartPar
解释
&\sphinxstyletheadfamily 
\sphinxAtStartPar
生成方式
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
filename.o
&
\sphinxAtStartPar
目标文件
&
\sphinxAtStartPar
编译时添加\sphinxhyphen{}c选项生成
\\
\sphinxhline
\sphinxAtStartPar
filename.so
&
\sphinxAtStartPar
共享库文件
&
\sphinxAtStartPar
编译时指定为共享型，
如添加\sphinxhyphen{}shared，并不含\sphinxhyphen{}c
\\
\sphinxhline
\sphinxAtStartPar
filename.mod
&
\sphinxAtStartPar
模块文件
&
\sphinxAtStartPar
编译含有
MODULE声明时的源文件生成
\\
\sphinxhline
\sphinxAtStartPar
filename.s
&
\sphinxAtStartPar
汇编文件
&
\sphinxAtStartPar
编译时添加\sphinxhyphen{}S选项生成
\\
\sphinxhline
\sphinxAtStartPar
a.out
&
\sphinxAtStartPar
默认生成的可执行文件
&
\sphinxAtStartPar
编译时没有指定\sphinxhyphen{}c时生成
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{串行Fortran程序编译举例}
\label{\detokenize{serial-compiling/serial-compiling:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Intel Fortran编译器：
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran 77程序yourprog.for编译为可执行文件yourprog：
\item[] \sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}o yourprog yourprog.for}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran 90程序yourprog.f90编译为可执行文件yourprog：
\item[] \sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}o yourprog yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran
90程序yourprog.90编译为对象文件yourprog.o而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}c yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran程序yourprog.f90编译为汇编文件yourprog.s而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}S yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 生成带有调试信息的可执行文件以用于调试：
\item[] \sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}g yourprog.f90 \sphinxhyphen{}o yourprog}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定头文件路径编译：
\item[] \sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}I/alt/include \sphinxhyphen{}o yourprog yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定库文件路径及库名编译：
\item[] \sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}L/alt/lib \sphinxhyphen{}lxyz \sphinxhyphen{}o yourprog yourprog.f90}}
\end{DUlineblock}

\end{itemize}

\item {} 
\sphinxAtStartPar
PGI Fortran编译器：
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran 77程序yourprog.for编译为可执行文件yourprog：
\item[] \sphinxcode{\sphinxupquote{pgf77 \sphinxhyphen{}o yourprog yourprog.for}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran 90程序yourprog.f90编译为可执行文件yourprog：
\item[] \sphinxcode{\sphinxupquote{pgf90 \sphinxhyphen{}o yourprog yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran程序yourprog.f90编译为对象文件yourprog.o而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{pgf90 \sphinxhyphen{}c yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran程序yourprog.f90编译为汇编文件yourprog.s而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{pgf90 \sphinxhyphen{}S yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 生成带有调试信息的可执行文件以用于调试：
\item[] \sphinxcode{\sphinxupquote{pgf90 \sphinxhyphen{}g yourprog.f90 \sphinxhyphen{}o yourprog}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定头文件路径编译：
\item[] \sphinxcode{\sphinxupquote{pgf90 \sphinxhyphen{}I/alt/include \sphinxhyphen{}o yourprog yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定库文件路径及库名编译：
\item[] \sphinxcode{\sphinxupquote{pgf90 \sphinxhyphen{}L/alt/lib \sphinxhyphen{}lxyz \sphinxhyphen{}o yourprog yourprog.f90}}
\end{DUlineblock}

\end{itemize}

\item {} 
\sphinxAtStartPar
GNU Fortran编译器：
\begin{itemize}
\item {} 
\sphinxAtStartPar
将Fortran 77程序yourprog.for编译为可执行文件yourprog：
\begin{itemize}
\item {} 
\sphinxAtStartPar
gcc 4.x系列：\sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}o yourprog yourprog.for}}

\item {} 
\sphinxAtStartPar
gcc 3.x系列：\sphinxcode{\sphinxupquote{g77 \sphinxhyphen{}o yourprog yourprog.for}}

\end{itemize}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran 90程序yourprog.f90编译为可执行文件yourprog：
\item[] \sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}o yourprog yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran程序yourprog.f90编译为对象文件yourprog.o而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}c yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran程序yourprog.f90编译为汇编文件yourprog.s而不是可执行文件：
\item[] \sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}S yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 生成带有调试信息的可执行文件以用于调试：
\item[] \sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}g yourprog.f90 \sphinxhyphen{}o yourprog}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定头文件路径编译：
\item[] \sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}I/alt/include \sphinxhyphen{}o yourprog yourprog.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 指定库文件路径及库名编译：
\item[] \sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}L/alt/lib \sphinxhyphen{}lxyz \sphinxhyphen{}o yourprog yourprog.f90}}
\end{DUlineblock}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
注意：\sphinxcode{\sphinxupquote{g77}}既不支持OpenMP，也不支持Fortran 90及之后的标准。


\section{OpenMP程序的编译与运行}
\label{\detokenize{serial-compiling/serial-compiling:id7}}

\subsection{OpenMP程序的编译}
\label{\detokenize{serial-compiling/serial-compiling:id8}}
\sphinxAtStartPar
Intel、PGI和GNU编译器都支持OpenMP并行，只需利用相关编译命令结合必要的OpenMP编译选项编译即可。对应此三种编译器的OpenMP编译选项：
\begin{itemize}
\item {} 
\sphinxAtStartPar
Intel编译器：\sphinxhyphen{}qopenmp（2015及之后版）

\item {} 
\sphinxAtStartPar
PGI编译器：\sphinxhyphen{}mp

\item {} 
\sphinxAtStartPar
GNU编译器：\sphinxhyphen{}fopenmp

\end{itemize}

\sphinxAtStartPar
采用这三种编译器的OpenMP源程序编译例子如下：
\begin{itemize}
\item {} 
\sphinxAtStartPar
Intel编译器：
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog\sphinxhyphen{}omp.c编译为可执行文件yourprog\sphinxhyphen{}omp：
\item[] \sphinxcode{\sphinxupquote{icc \sphinxhyphen{}qopenmp \sphinxhyphen{}o yourprog\sphinxhyphen{}omp yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran 90程序yourprog\sphinxhyphen{}omp.f90编译为可执行文件yourprog\sphinxhyphen{}omp：
\item[] \sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}qopenmp \sphinxhyphen{}o yourprog\sphinxhyphen{}omp yourprog.f90}}
\end{DUlineblock}

\end{itemize}

\item {} 
\sphinxAtStartPar
PGI编译器：
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog\sphinxhyphen{}omp.c编译为可执行文件yourprog\sphinxhyphen{}omp：
\item[] \sphinxcode{\sphinxupquote{pgcc \sphinxhyphen{}mp \sphinxhyphen{}o yourprog\sphinxhyphen{}omp yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran 90程序yourprog\sphinxhyphen{}omp.f90编译为可执行文件yourprog\sphinxhyphen{}omp：
\item[] \sphinxcode{\sphinxupquote{pgf90 \sphinxhyphen{}mp \sphinxhyphen{}o yourprog\sphinxhyphen{}omp yourprog.f90}}
\end{DUlineblock}

\end{itemize}

\item {} 
\sphinxAtStartPar
GNU编译器：
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] 将C程序yourprog\sphinxhyphen{}omp.c编译为可执行文件yourprog\sphinxhyphen{}omp：
\item[] \sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}fopenmp \sphinxhyphen{}o yourprog\sphinxhyphen{}omp yourprog.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran 90程序yourprog\sphinxhyphen{}omp.f90编译为可执行文件yourprog\sphinxhyphen{}omp：
\item[] \sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}fopenmp \sphinxhyphen{}o yourprog\sphinxhyphen{}omp yourprog.f90}}
\end{DUlineblock}

\end{itemize}

\end{itemize}


\subsection{OpenMP程序的运行}
\label{\detokenize{serial-compiling/serial-compiling:id9}}
\sphinxAtStartPar
OpenMP程序的运行一般是通过在运行前设置环境变量\sphinxcode{\sphinxupquote{OMP\_NUM\_THREADS}}来控制线程数，比如在BASH中利用\sphinxcode{\sphinxupquote{export OMP\_NUM\_THREADS=40}}设置使用40个线程运行。

\sphinxAtStartPar
注意，本系统为节点内共享内存节点间分布式内存的架构，因此只能在一个节点上的CPU之间运行同一个OpenMP程序作业，在提交作业时需要使用相应选项以保证在同一个节点运行。

\sphinxstepscope


\chapter{Intel、PGI及GNU C/C++ Fortran编译器介绍}
\label{\detokenize{compiler/index:intelpgignu-c-c-fortran}}\label{\detokenize{compiler/index::doc}}
\sphinxstepscope


\section{Intel C/C++ Fortran编译器}
\label{\detokenize{compiler/intel:intel-c-c-fortran}}\label{\detokenize{compiler/intel::doc}}

\subsection{Intel C/C++ Fortran编译器简介}
\label{\detokenize{compiler/intel:id1}}
\sphinxAtStartPar
\sphinxhref{https://software.intel.com/en-us/parallel-studio-xe}{Intel Parallel Studio XE Cluster}版C/C++ Fortran编译器，是一种主要针对Inetl平台的高性能编译器，可用于开发复杂且要进行大量计算的C/C++、Fortran程序。

\sphinxAtStartPar
系统当前安装目录为，其下有多种年份版本。官方手册目录为 \sphinxcode{\sphinxupquote{/opt/intel}} 。用户可以采用molule命令来设置所需的环境，请参看 \sphinxhref{../module-environment/module-environment.html\#module}{{[}设置编译及运行环境{]}}。

\sphinxAtStartPar
Intel编译器编译C和C++源程序的编译命令分别为\sphinxcode{\sphinxupquote{icc}}和\sphinxcode{\sphinxupquote{icpc}}；编译Fortran源程序的命令为\sphinxcode{\sphinxupquote{ifort}}。\sphinxcode{\sphinxupquote{icpc}}命令使用与\sphinxcode{\sphinxupquote{icc}}命令相同的编译器选项，利用\sphinxcode{\sphinxupquote{icpc}}编译时将后缀为.c和.i的文件看作为C++文件；而利用\sphinxcode{\sphinxupquote{icc}}编译时将后缀为.c和.i的文件则看作为C文件。用\sphinxcode{\sphinxupquote{icpc}}编译时，总会链接C++库；而用\sphinxcode{\sphinxupquote{icc}}编译时，只有在编译命令行中包含C++源文件时才链接C++库。

\sphinxAtStartPar
编译命令格式为：\sphinxcode{\sphinxupquote{command {[}options{]} {[}@response\_file{]} file1 {[}file2...{]}}}，其中\sphinxcode{\sphinxupquote{response\_file}}为文件名，此文件包含一些编译选项，请注意调用时前面有个@。

\sphinxAtStartPar
在Intel数学库(Intelmath)中的许多函数针对Intel微处理器相比针对非Intel微处理器做了非常大的优化处理。

\sphinxAtStartPar
为了使用Intel数学库中的函数，需要在程序源文件中包含头文件，例如使用实函数：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// real\PYGZus{}math.c}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}mathimf.h\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{float}\PYG{+w}{ }\PYG{n}{fp32bits}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{fp64bits}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{long}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{fp80bits}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{long}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{pi\PYGZus{}by\PYGZus{}four}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{3.141592653589793238}\PYG{o}{/}\PYG{l+m+mf}{4.0}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// pi/4 radians is about 45 degrees}
\PYG{+w}{    }\PYG{n}{fp32bits}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{pi\PYGZus{}by\PYGZus{}four}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// float approximation to pi/4}
\PYG{+w}{    }\PYG{n}{fp64bits}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{pi\PYGZus{}by\PYGZus{}four}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// double approximation to pi/4}
\PYG{+w}{    }\PYG{n}{fp80bits}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pi\PYGZus{}by\PYGZus{}four}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// long double (extended) approximation to pi/4}

\PYG{+w}{    }\PYG{c+c1}{// The sin(pi/4) is known to be 1/sqrt(2) or approximately .7071067}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{When x = \PYGZpc{}8.8f, sinf(x) = \PYGZpc{}8.8f }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{fp32bits}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sinf}\PYG{p}{(}\PYG{n}{fp32bits}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{When x = \PYGZpc{}16.16f, sin(x) = \PYGZpc{}16.16f }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{fp64bits}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sin}\PYG{p}{(}\PYG{n}{fp64bits}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{When x = \PYGZpc{}20.20Lf, sinl(x) = \PYGZpc{}20.20f }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{fp80bits}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sinl}\PYG{p}{(}\PYG{n}{fp80bits}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
编译：\sphinxcode{\sphinxupquote{icc real\_math.c}}


\subsection{编译错误}
\label{\detokenize{compiler/intel:id2}}
\sphinxAtStartPar
C/C++程序编译时的出错信息类似以下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{netlog}\PYG{o}{.}\PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{140}\PYG{p}{)}\PYG{p}{:} \PYG{n}{error}\PYG{p}{:} \PYG{n}{identifier} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hhh}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o+ow}{is} \PYG{n}{undefined}
                    \PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{hhh}\PYG{o}{=}\PYG{n}{domain\PYGZus{}cnt}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{hhh}\PYG{o}{\PYGZgt{}}\PYG{n}{TMP}\PYG{p}{;}\PYG{n}{hhh}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                                             \PYG{o}{\PYGZca{}}
\PYG{n}{netlog}\PYG{o}{.}\PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{156}\PYG{p}{)}\PYG{p}{:} \PYG{n}{error}\PYG{p}{:} \PYG{n}{expected} \PYG{n}{an} \PYG{n}{expression}
\PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{32}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{k}{for}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{j}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{256}\PYG{p}{;}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{k}{if}\PYG{p}{(}\PYG{n}{ip1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{!=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{n}{fprintf}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{)}\PYG{p}{;}
    \PYG{o}{\PYGZca{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Fortran程序编译时的出错信息类似以下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NOlihm}\PYG{o}{.}\PYG{n}{f90}\PYG{p}{(}\PYG{l+m+mi}{146}\PYG{p}{)}\PYG{p}{:} \PYG{n}{error} \PYG{c+c1}{\PYGZsh{}6404: This name does not have a type, and must}
\PYG{n}{have} \PYG{n}{an} \PYG{n}{explicit} \PYG{n+nb}{type}\PYG{o}{.}   \PYG{p}{[}\PYG{n}{NPR}\PYG{p}{]}
  \PYG{n}{n2nd}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{n}{npr}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZca{}}
\PYG{n}{NOlihm}\PYG{o}{.}\PYG{n}{f90}\PYG{p}{(}\PYG{l+m+mi}{542}\PYG{p}{)}\PYG{p}{:} \PYG{n}{remark} \PYG{c+c1}{\PYGZsh{}8290: Recommended relationship between field width}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{and} \PYG{n}{the} \PYG{n}{number} \PYG{n}{of} \PYG{n}{fractional} \PYG{n}{digits} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{edit} \PYG{n}{descriptor} \PYG{o+ow}{is} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W\PYGZgt{}=D+3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}
\PYG{l+m+mi}{6060} \PYG{n+nb}{format}\PYG{p}{(}\PYG{o}{/}\PYG{n}{i2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}th layer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{i2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}th element: z=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{i3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ a=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{f9}\PYG{l+m+mf}{.5}\PYG{o}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ Ef=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{f7}\PYG{l+m+mf}{.5}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZca{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
编译错误的格式为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
源文件名(行数): 错误类型:具体说明

\item {} 
\sphinxAtStartPar
源代码，\textasciicircum{}指示出错位置

\end{itemize}

\sphinxAtStartPar
错误类型可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
Warning：警告，报告对编译有效但也许存在问题的语法，请根据信息及程序本身判断，不一定需要处理。

\item {} 
\sphinxAtStartPar
Error：存在语法或语义问题，必须要处理。

\item {} 
\sphinxAtStartPar
Fatal Error：报告环境错误，如磁盘空间没有了。

\end{itemize}


\subsection{Fortran程序运行错误}
\label{\detokenize{compiler/intel:fortran}}
\sphinxAtStartPar
根据运行时错误代码可以在\sphinxhref{https://software.intel.com/en-us/fortran-compiler-developer-guide-and-reference-list-of-run-time-error-messages}{官方手册}中查找对应错误解释。


\subsection{Intel Parallel Studio XE版重要编译选项}
\label{\detokenize{compiler/intel:intel-parallel-studio-xe}}
\sphinxAtStartPar
Intel编译器选项分为几类，可以用\sphinxcode{\sphinxupquote{icc \sphinxhyphen{}help 类别}}查看对应的选项，类别与选项对应关系如下：
\begin{description}
\sphinxlineitem{advanced}\begin{itemize}
\item {} 
\sphinxAtStartPar
Advanced Optimizations，高级优化

\end{itemize}

\sphinxlineitem{codegen}\begin{itemize}
\item {} 
\sphinxAtStartPar
Code Generation，代码生成

\end{itemize}

\sphinxlineitem{compatibility}\begin{itemize}
\item {} 
\sphinxAtStartPar
Compatibility，兼容性

\end{itemize}

\sphinxlineitem{component}\begin{itemize}
\item {} 
\sphinxAtStartPar
Component Control，组件控制

\end{itemize}

\sphinxlineitem{data}\begin{itemize}
\item {} 
\sphinxAtStartPar
Data，数据

\end{itemize}

\sphinxlineitem{deprecated}\begin{itemize}
\item {} 
\sphinxAtStartPar
Deprecated Options，过时选项

\end{itemize}

\sphinxlineitem{diagnostics}\begin{itemize}
\item {} 
\sphinxAtStartPar
Compiler Diagnostics，编译器诊断

\end{itemize}

\sphinxlineitem{float}\begin{itemize}
\item {} 
\sphinxAtStartPar
Floating Point，浮点

\end{itemize}

\sphinxlineitem{help}\begin{itemize}
\item {} 
\sphinxAtStartPar
Help，帮助

\end{itemize}

\sphinxlineitem{inline}\begin{itemize}
\item {} 
\sphinxAtStartPar
Inlining，内联

\end{itemize}

\sphinxlineitem{ipo}\begin{itemize}
\item {} 
\sphinxAtStartPar
Interprocedural Optimization (IPO)，过程间优化

\end{itemize}

\sphinxlineitem{language}\begin{itemize}
\item {} 
\sphinxAtStartPar
Language，语言

\end{itemize}

\sphinxlineitem{link}\begin{itemize}
\item {} 
\sphinxAtStartPar
Linking/Linker，链接/链接器

\end{itemize}

\sphinxlineitem{misc}\begin{itemize}
\item {} 
\sphinxAtStartPar
Miscellaneous，杂项

\end{itemize}

\sphinxlineitem{opt}\begin{itemize}
\item {} 
\sphinxAtStartPar
Optimization，优化

\end{itemize}

\sphinxlineitem{output}\begin{itemize}
\item {} 
\sphinxAtStartPar
Output，输出

\end{itemize}

\sphinxlineitem{pgo}\begin{itemize}
\item {} 
\sphinxAtStartPar
Profile Guided Optimization (PGO)，概要导向优化

\end{itemize}

\sphinxlineitem{preproc}\begin{itemize}
\item {} 
\sphinxAtStartPar
Preprocessor，预处理

\end{itemize}

\sphinxlineitem{reports}\begin{itemize}
\item {} 
\sphinxAtStartPar
Optimization Reports，优化报告

\end{itemize}

\sphinxlineitem{openmp}\begin{itemize}
\item {} 
\sphinxAtStartPar
OpenMP and Parallel Processing，OpenMP和并行处理

\end{itemize}

\end{description}

\sphinxAtStartPar
可以运行\sphinxcode{\sphinxupquote{icc \sphinxhyphen{}help help}}查看选项分类情况。


\subsubsection{优化选项}
\label{\detokenize{compiler/intel:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fast：最大化整个程序的速度，相当于设置\sphinxhyphen{}ipo、\sphinxhyphen{}O3、\sphinxhyphen{}no\sphinxhyphen{}prec\sphinxhyphen{}div、\sphinxhyphen{}static、\sphinxhyphen{}fp\sphinxhyphen{}model fast=2和\sphinxhyphen{}xHost。这里是所谓的最大化，还是需要结合程序本身使用合适的选项，默认不使用此选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}nolib\sphinxhyphen{}inline：取消标准库和内在函数的内联展开。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}O\sphinxstyleemphasis{n}：设定优化级别，默认为O2。O与O2相同，推荐使用；O3为在O2基础之上增加更激进的优化，比如包含循环和内存读取转换和预取等，但在有些情况下速度反而慢，建议在具有大量浮点计算和大数据处理的循环时的程序使用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Ofast：设定一定的优化选项提高程序性能，设定\sphinxhyphen{}O3, \sphinxhyphen{}no\sphinxhyphen{}prec\sphinxhyphen{}div和\sphinxhyphen{}fp\sphinxhyphen{}model fast=2。在Linux系统上提供与gcc的兼容。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Os：启用优化，但不增加代码大小，并且产生比\sphinxhyphen{}O2优化小的代码。它取消了一些优化不明显却增大了代码的优化选项。

\end{itemize}


\subsubsection{代码生成选项}
\label{\detokenize{compiler/intel:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ax\sphinxstyleemphasis{code}：在有性能提高时，生成针对Intel处理器的多特征面向的自动调度代码路径。\sphinxstyleemphasis{code}可为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
COMMON\sphinxhyphen{}AVX512：生成Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX\sphinxhyphen{}512)基础指令。

\item {} 
\sphinxAtStartPar
CORE\sphinxhyphen{}AVX2：生成IntelAdvanced Vector Extensions 2 (IntelAVX2)、IntelAVX、SSE4.2、SSE4.1、SSE3、SSE2、SSE和SSSE3指令。

\item {} 
\sphinxAtStartPar
CORE\sphinxhyphen{}AVX\sphinxhyphen{}I：生成Float\sphinxhyphen{}16转换指令和RDRND（随机数）指令、IntelAdvanced Vector Extensions (IntelAVX)、IntelSSE4.2、SSE4.1、SSE3、SSE2、SSE和SSSE3指令。

\item {} 
\sphinxAtStartPar
AVX：生成IntelAdvanced Vector Extensions (IntelAVX)、IntelSSE4.2、SSE4.1、SSE3、SSE2、SSE和SSSE3指令。

\item {} 
\sphinxAtStartPar
SSE4.2：生成IntelSSE4.2、SSE4.1、SSE3、SSE2、SSE和SSSE3指令。

\item {} 
\sphinxAtStartPar
SSE4.1：生成IntelSSE4.1、SSE3、SSE2、SSE和SSSE3指令

\item {} 
\sphinxAtStartPar
SSSE3：生成SSSE3指令和IntelSSE3、SSE2和SSE指令。

\item {} 
\sphinxAtStartPar
SSE3：生成IntelSSE3、SSE2和SSE指令。

\item {} 
\sphinxAtStartPar
SSE2：生成IntelSSE2和SSE指令。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fexceptions、\sphinxhyphen{}fno\sphinxhyphen{}exceptions：是否生成异常处理表。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}x\sphinxstyleemphasis{code}：设置启用编译目标的特征，包含采取何种指令集和优化。
\begin{itemize}
\item {} 
\sphinxAtStartPar
COMMON\sphinxhyphen{}AVX512

\item {} 
\sphinxAtStartPar
CORE\sphinxhyphen{}AVX2

\item {} 
\sphinxAtStartPar
CORE\sphinxhyphen{}AVX\sphinxhyphen{}I

\item {} 
\sphinxAtStartPar
AVX

\item {} 
\sphinxAtStartPar
SSE4.2

\item {} 
\sphinxAtStartPar
SSE4.1

\item {} 
\sphinxAtStartPar
SSSE3

\item {} 
\sphinxAtStartPar
SSE3

\item {} 
\sphinxAtStartPar
SSE2

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}m\sphinxstyleemphasis{code}：需要生成目标特征的指令集。\sphinxstyleemphasis{code}可为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
avx：生成IntelAdvanced Vector Extensions (IntelAVX)、IntelSSE4.2、SSE4.1、SSE3、SSE2、SSE和SSSE3指令。

\item {} 
\sphinxAtStartPar
sse4.2：生成IntelSSE4.2、SSE4.1、SSE3、SSE2、SSE和SSSE3指令。

\item {} 
\sphinxAtStartPar
sse4.1：生成IntelSSE4.1、SSE3、SSE2、SSE和SSSE3指令。

\item {} 
\sphinxAtStartPar
ssse3：生成SSSE3指令和IntelSSE3、SSE2和SSE指令。

\item {} 
\sphinxAtStartPar
sse3：生成IntelSSE3、SSE2和SSE指令。

\item {} 
\sphinxAtStartPar
sse2：生成IntelSSE2和SSE指令。

\item {} 
\sphinxAtStartPar
sse：已过时，现在与ia32一样。

\item {} 
\sphinxAtStartPar
ia32：生成与IA\sphinxhyphen{}32架构兼容的x86/x87通用代码。取消任何默认扩展指令集，任何之前的扩展指令集。并且取消所有面向特征的优化及指令。此值仅在Linux系统上使用IA\sphinxhyphen{}32架构时有效。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}m32和\sphinxhyphen{}m64：生成IA\sphinxhyphen{}32或Intel64位代码，默认由主机系统设定。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}march=\sphinxstyleemphasis{processor}：生成支持某种处理器特定特征的代码。\sphinxstyleemphasis{processor}可为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
generic

\item {} 
\sphinxAtStartPar
core\sphinxhyphen{}avx2

\item {} 
\sphinxAtStartPar
core\sphinxhyphen{}avx\sphinxhyphen{}i

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mtune=\sphinxstyleemphasis{processor}：针对特定处理器优化。\sphinxstyleemphasis{processor}可为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
generic（默认）

\item {} 
\sphinxAtStartPar
core\sphinxhyphen{}avx2

\item {} 
\sphinxAtStartPar
core\sphinxhyphen{}avx\sphinxhyphen{}i

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}xHost：生成编译主机处理器能支持的最高指令集。

\end{itemize}


\subsubsection{过程间优化(IPO)选项}
\label{\detokenize{compiler/intel:ipo}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ip：在单个文件中进行过程间优化(Interprocedural Optimizations\sphinxhyphen{}IPO)。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ip\sphinxhyphen{}no\sphinxhyphen{}inlining：禁止过程间优化时启用的全部和部分内联。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ip\sphinxhyphen{}no\sphinxhyphen{}pinlining：禁止过程间优化时启用的部分内联。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ipo\sphinxstyleemphasis{{[}n{]}}、\sphinxhyphen{}no\sphinxhyphen{}ipo：是否在多文件中进行过程间优化，非负整数\sphinxstyleemphasis{n}为可生成的对象文件数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ipo\sphinxhyphen{}c：在多文件中进行过程间优化，并生成一个对象文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ipo\sphinxhyphen{}jobs\sphinxstyleemphasis{n}：指定在过程间优化的链接阶段时的命令（作业）数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ipo\sphinxhyphen{}S：在多文件中进行过程间优化，并生成一个汇编文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ipo\sphinxhyphen{}separate：在多文件中进行过程间优化，并为每个文件分别生成一个对象文件。

\end{itemize}


\subsubsection{高级优化选项}
\label{\detokenize{compiler/intel:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}funroll\sphinxhyphen{}all\sphinxhyphen{}loops：即使在循环次数不确定的情况下也展开所有循环。默认为否。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}guide\sphinxstyleemphasis{{[}=n{]}}：设置自动向量化、自动并行及数据变换的指导级别。\sphinxstyleemphasis{n}为1到4，1为标准指导，4为最高指导，如果\sphinxstyleemphasis{n}忽略，则默认为4。默认为不启用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}guide\sphinxhyphen{}data\sphinxhyphen{}trans\sphinxstyleemphasis{{[}=n{]}}：设置数据变换时的指导级别。\sphinxstyleemphasis{n}为1到4，1为标准指导，4为最高指导，如果\sphinxstyleemphasis{n}忽略，则默认为4。默认为不启用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}guide\sphinxhyphen{}file\sphinxstyleemphasis{{[}=filename{]}}：将自动并行的结果输出到文件\sphinxstyleemphasis{filename}中。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}guide\sphinxhyphen{}file\sphinxhyphen{}append\sphinxstyleemphasis{{[}=filename{]}}：将自动并行的结果追加到文件\sphinxstyleemphasis{filename}中。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}guide\sphinxhyphen{}par\sphinxstyleemphasis{{[}=n{]}}：设置自动并行的指导级别。\sphinxstyleemphasis{n}为1到4，1为标准指导，4为最高指导，如果\sphinxstyleemphasis{n}忽略，则默认为4。默认为不启用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}guide\sphinxhyphen{}vec\sphinxstyleemphasis{{[}=n{]}}：设置自动向量化的指导级别。\sphinxstyleemphasis{n}为1到4，1为标准指导，4为最高指导，如果\sphinxstyleemphasis{n}忽略，则默认为4。默认为不启用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mkl\sphinxstyleemphasis{{[}=lib{]}}：链接时自动链接Intel MKL库，默认为不启用。\sphinxstyleemphasis{lib}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
parallel：采用线程化部分的MKL库链接，此为\sphinxstyleemphasis{lib}如果没指明时的默认选项。

\item {} 
\sphinxAtStartPar
sequential：采用未线程化的串行MKL库链接。

\item {} 
\sphinxAtStartPar
cluster：采用集群部分和串行部分MKL链接。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}simd、\sphinxhyphen{}no\sphinxhyphen{}simd：是否启用SIMD编译指示的编译器解释。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}unroll\sphinxstyleemphasis{{[}=n{]}}：设置循环展开的最大层级。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}unroll\sphinxhyphen{}aggressive、\sphinxhyphen{}no\sphinxhyphen{}unroll\sphinxhyphen{}aggressive：设置对某些循环执行激进展开。默认不启用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}vec、\sphinxhyphen{}no\sphinxhyphen{}vec：是否启用向量化。默认启用。

\end{itemize}


\subsubsection{概要导向优化(PGO)选项}
\label{\detokenize{compiler/intel:pgo}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}p：使用gprof编译和链接函数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}prof\sphinxhyphen{}dir \sphinxstyleemphasis{dir}：设定存储概要导向优化信息的文件目录。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}prof\sphinxhyphen{}file \sphinxstyleemphasis{filename}：设定概要摘要文件名。

\end{itemize}


\subsubsection{优化报告选项}
\label{\detokenize{compiler/intel:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopt\sphinxhyphen{}report\sphinxstyleemphasis{{[}=n{]}}：设定显示优化报告信息的级别，为每个对象文件生成一个对应的文件。\sphinxstyleemphasis{n}为0（不显示）到5（最详细）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopqopt\sphinxhyphen{}report\sphinxhyphen{}file\sphinxstyleemphasis{=keyword}：设定报告文件名。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
filename：保存输出的文件名。

\item {} 
\sphinxAtStartPar
stderr：输出到标准错误输出。

\item {} 
\sphinxAtStartPar
stdout：输出到标准输出。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopt\sphinxhyphen{}report\sphinxhyphen{}filter\sphinxstyleemphasis{=string}：设置报告的过滤器。\sphinxstyleemphasis{string}可以为filename、routine、range等。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopt\sphinxhyphen{}report\sphinxhyphen{}format\sphinxstyleemphasis{=keyword}：设置报告的格式。\sphinxstyleemphasis{keyword}可以为text和vs，分别对应纯文本和Visual Studio格式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopt\sphinxhyphen{}report\sphinxhyphen{}help：显示使用\sphinxhyphen{}qopt\sphinxhyphen{}report\sphinxhyphen{}phase选项时可用于报告生成的各优化阶段，并显示各级别报告的简短描述。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopt\sphinxhyphen{}report\sphinxhyphen{}per\sphinxhyphen{}object：为各对象文件生成独立的报告文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopt\sphinxhyphen{}report\sphinxhyphen{}phase：对生成的优化报告指明一个或多个优化阶段。\sphinxstyleemphasis{phase}可以为：cg、ipo、loop、openmp、par、pgo、tcollect、vec和all等。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopt\sphinxhyphen{}report\sphinxhyphen{}routine\sphinxstyleemphasis{=substring}：让编译器对含有\sphinxstyleemphasis{substring}的子程序生成优化报告。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopt\sphinxhyphen{}report\sphinxhyphen{}names\sphinxstyleemphasis{=keyword}：是否在优化报告中显示重整的或未重整的名字。\sphinxstyleemphasis{keyword}可以为：mangled和unmangled。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}tcheck：对线程应用启用分析。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}tcollect\sphinxstyleemphasis{{[}lib{]}}：插入测试探测调用Intel Trace Collector API。\sphinxstyleemphasis{lib}为一种Intel Trace Collector库，例如：VT、VTcs、VTmc或VTfs。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}tcollect\sphinxhyphen{}filter\sphinxstyleemphasis{filename}：对特定的函数启用或禁止测试。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}vec\sphinxhyphen{}report\sphinxstyleemphasis{{[}=n{]}}：设置向量化诊断信息详细程度。\sphinxstyleemphasis{n}为0（不显示）到7（最详细）。

\end{itemize}


\subsubsection{OpenMP和并行处理选项}
\label{\detokenize{compiler/intel:openmp}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fmpc\sphinxhyphen{}privatize、\sphinxhyphen{}fno\sphinxhyphen{}mpc\sphinxhyphen{}privatize：是否启用针对多处理器计算环境(MPC)所有静态数据私有。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}par\sphinxhyphen{}affinity=\sphinxstyleemphasis{{[}modifier,…{]}type{[},permute{]}{[},offset{]}}：设定线程亲和性。
\begin{itemize}
\item {} 
\sphinxAtStartPar
modifier：可以为以下值之一：granularity=fine|thread|core、{[}no{]}respect、{[}no{]}verbose、{[}no{]}warnings、proclist=proc\_list。默认为granularity=core, respect, noverbose。

\item {} 
\sphinxAtStartPar
type：指示线程亲和性。此选项是必需的，并且需为以下之一：compact、disabled、explicit、none、scatter、logical、physical。默认为none。logical和physical已经过时。分别使用compact和scatter，并且没有permute值。

\item {} 
\sphinxAtStartPar
permute：非负整数。当type设置为explicit、none或disabled时，不能使用此选项。默认为0。

\item {} 
\sphinxAtStartPar
offset：非负整数。当type设置为explicit、none或disabled时，不能使用此选项。默认为0。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}par\sphinxhyphen{}num\sphinxhyphen{}threads=\sphinxstyleemphasis{n}：设定并行区域内的线程数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}par\sphinxhyphen{}report\sphinxstyleemphasis{n}：设定自动并行时诊断信息的显示级别。\sphinxstyleemphasis{n}可以为0到5。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}par\sphinxhyphen{}runtime\sphinxhyphen{}control\sphinxstyleemphasis{n}、\sphinxhyphen{}no\sphinxhyphen{}par\sphinxhyphen{}runtime\sphinxhyphen{}control：设定是否对符号循环边界的循环执行运行时检查代码。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}par\sphinxhyphen{}schedule\sphinxstyleemphasis{\sphinxhyphen{}keyword{[}=n{]}}：设定循环迭代的调度算法。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
auto：由编译器或者运行时系统设定调度算法。

\item {} 
\sphinxAtStartPar
static：将迭代分割成连续块。

\item {} 
\sphinxAtStartPar
static\sphinxhyphen{}balanced：将迭代分割成偶数大小的块。

\item {} 
\sphinxAtStartPar
static\sphinxhyphen{}steal：将迭代分割成偶数大小的块，但允许线程从临近线程窃取部分块。

\item {} 
\sphinxAtStartPar
dynamic：动态获取迭代集。

\item {} 
\sphinxAtStartPar
guided：设定迭代的最小值。

\item {} 
\sphinxAtStartPar
guided\sphinxhyphen{}analytical：使用指数分布或动态分布分割迭代。

\item {} 
\sphinxAtStartPar
runtime：直到运行时才设定调度分割。

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{n}为每个迭代数或块大小。此设置，只能配合static、dynamic和guided使用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}par\sphinxhyphen{}threshold\sphinxstyleemphasis{n}：设定针对循环自动并行的阈值。\sphinxstyleemphasis{n}为一个在0到100间的整数，限定针对循环自动并行的阈值：
\begin{itemize}
\item {} 
\sphinxAtStartPar
如\sphinxstyleemphasis{n}为0，则循环总会被并行。

\item {} 
\sphinxAtStartPar
如\sphinxstyleemphasis{n}为100，则循环只有在基于编译器分析应用的数据能达到预期收益时才并行。

\item {} 
\sphinxAtStartPar
1到99为预期可能的循环加速百分比。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}parallel：让自动并行器针对可以安全并行执行的循环生成多线程代码。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}parallel\sphinxhyphen{}source\sphinxhyphen{}info\sphinxstyleemphasis{=n}、\sphinxhyphen{}no\sphinxhyphen{}parallel\sphinxhyphen{}source\sphinxhyphen{}info：设定当生成OpenMP或自动并行代码是否显示源位置。\sphinxstyleemphasis{n}为显示级别：
\begin{itemize}
\item {} 
\sphinxAtStartPar
0：禁止显示源位置信息。

\item {} 
\sphinxAtStartPar
1：显示子程序名和行信息。

\item {} 
\sphinxAtStartPar
2：显示路径、文件名、子程序名和行信息。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopenmp：编译OpenMP程序。注意：在一般只能在同一个节点内的CPU上运行OpenMP程序。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopenmp\sphinxhyphen{}lib\sphinxstyleemphasis{=type}：设定链接时使用的OpenMP运行时库。当前\sphinxstyleemphasis{type}只能设定为compat。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopenmp\sphinxhyphen{}link\sphinxstyleemphasis{=library}：设定采用动态还是静态链接OpenMP运行时库。\sphinxstyleemphasis{library}可以为static和dynamic，分别表示静态和动态链接OpenMP运行时库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopenmp\sphinxhyphen{}report\sphinxstyleemphasis{n}：设定OpenMP并行器的诊断信息的显示级别。\sphinxstyleemphasis{n}可以为0、1和2。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopenmp\sphinxhyphen{}simd、\sphinxhyphen{}no\sphinxhyphen{}qopenmp\sphinxhyphen{}simd：设定是否启用OpenMP SIMD编译。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopenmp\sphinxhyphen{}stubs：使用串行模式编译OpenMP程序。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopenmp\sphinxhyphen{}task\sphinxstyleemphasis{=model}：设定OpenMP的任务模型。\sphinxstyleemphasis{model}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
intel：让编译接受Intel任务序列指导指令（\#pragma intel\_omp\_taskq和\#pragma intel\_omp\_task）。OpenMP API 3.0将被忽略。

\item {} 
\sphinxAtStartPar
omp：让编译接受OpenMP API 3.0任务序列指导指令（\#pragma omp\_task）。Intel任务序列指导指令将被忽略。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopenmp\sphinxhyphen{}threadprivate\sphinxstyleemphasis{=type}：设定OpenMP线程私有的实现。\sphinxstyleemphasis{type}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
legacy：让编译器继承使用以前Intel编译器使用的OpenMP线程私有实现。

\item {} 
\sphinxAtStartPar
compat：让编译器使用基于对每个私有线程变量应用\_\_declspec(thread)属性的兼容OpenMP线程私有实现。

\end{itemize}

\end{itemize}


\subsubsection{浮点选项}
\label{\detokenize{compiler/intel:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fast\sphinxhyphen{}transcendentals：让编译器使用超越函数代替，超越函数是较快但精度较低的实现。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fimf\sphinxhyphen{}absolute\sphinxhyphen{}error\sphinxstyleemphasis{=value{[}:funclist{]}}：定义对于数学函数返回值允许的最大绝对误差的值。\sphinxstyleemphasis{value}为正浮点数，\sphinxstyleemphasis{funclist}为函数名列表。如：\sphinxhyphen{}fimf\sphinxhyphen{}absolute\sphinxhyphen{}error=0.00001:sin,sinf。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fimf\sphinxhyphen{}accuracy\sphinxhyphen{}bits=\sphinxstyleemphasis{bits{[}:funclist{]}}：定义数学函数返回值的相对误差，包含除法及开方。\sphinxstyleemphasis{bits}为正浮点数，指明编译器应该使用的正确位数，\sphinxstyleemphasis{funclist}为函数名列表。如：\sphinxhyphen{}fimf\sphinxhyphen{}accuracy\sphinxhyphen{}bits=23:sin,sinf。bits与ulps之间的变换关系为：\(ulps=2^{p-1-bits}\)，其中\(p\)为目标格式尾数\(bits\)的位数（对应单精度、双精度和长双精度分别为23、53和64）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fimf\sphinxhyphen{}max\sphinxhyphen{}error\sphinxstyleemphasis{=ulps{[}:funclist{]}}：定义对于数学函数返回值的最大允许相对误差，包含除法及开方。\sphinxstyleemphasis{value}为正浮点数，指定编译器可以使用的最大相对误差，\sphinxstyleemphasis{funclist}为函数名列表，如：\sphinxhyphen{}fimf\sphinxhyphen{}max\sphinxhyphen{}error=4.0:sin,sinf。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fimf\sphinxhyphen{}precision\sphinxstyleemphasis{{[}=value{[}:funclist{]}{]}}：当设定使用何种数学库函数时，定义编译器应该使用的精度。\sphinxstyleemphasis{value}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
high：等价于max\sphinxhyphen{}error = 0.6

\item {} 
\sphinxAtStartPar
medium：等价于max\sphinxhyphen{}error = 4

\item {} 
\sphinxAtStartPar
low：等价于accuracy\sphinxhyphen{}bits = 11（对单精度）和accuracy\sphinxhyphen{}bits = 26（对双精度）

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{funclist}为函数名列表，如： \sphinxhyphen{}fimf\sphinxhyphen{}precision=high:sin,sinf。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fma、\sphinxhyphen{}no\sphinxhyphen{}fma：是否对存在融合乘加(fused multiply\sphinxhyphen{}add\sphinxhyphen{}FMA)的目标处理器启用融合乘加。此选项只有在\sphinxhyphen{}x或\sphinxhyphen{}march参数设定CORE\sphinxhyphen{}AVX2或更高时才有效。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fp\sphinxhyphen{}model \sphinxstyleemphasis{keyword}：控制浮点计算的语义，\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
precise：取消浮点数据的非值安全优化。

\item {} 
\sphinxAtStartPar
fast{[}=1|2{]}：对浮点数据启用更加激进的优化。

\item {} 
\sphinxAtStartPar
strict：启用精度和异常，禁止收缩，启用编译指示stdc和fenv\_access。

\item {} 
\sphinxAtStartPar
source：四舍五入中间结果到源定义精度。

\item {} 
\sphinxAtStartPar
double：四舍五入中间结果到53\sphinxhyphen{}bit（双）精度。

\item {} 
\sphinxAtStartPar
extended：四舍五入中间结果到64\sphinxhyphen{}bit（扩展）精度。

\item {} 
\sphinxAtStartPar
{[}no\sphinxhyphen{}{]}except：定义严格浮点异常编译指令是否启用。

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{keyword}可以分成以下三组使用：
\begin{itemize}
\item {} 
\sphinxAtStartPar
precise, fast, strict

\item {} 
\sphinxAtStartPar
source, double, extended

\item {} 
\sphinxAtStartPar
except

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fp\sphinxhyphen{}port、\sphinxhyphen{}no\sphinxhyphen{}fp\sphinxhyphen{}port：是否对浮点操作启用四舍五入。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fp\sphinxhyphen{}speculation\sphinxstyleemphasis{=mode}：设定推测浮点操作时使用的模式。\sphinxstyleemphasis{mode}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
fast：让编译器推测浮点操作。

\item {} 
\sphinxAtStartPar
safe：让编译器在推测浮点操作有可能存在浮点异常时停止推测。

\item {} 
\sphinxAtStartPar
strict：让编译器禁止浮点操作时推测。

\item {} 
\sphinxAtStartPar
off：与strict相同。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fp\sphinxhyphen{}trap\sphinxstyleemphasis{=mode{[},mode,…{]}}：设置主函数的浮点异常捕获模式。\sphinxstyleemphasis{mode}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}no{]}divzero：是否启用被0除时的IEEE捕获。

\item {} 
\sphinxAtStartPar
{[}no{]}inexact：是否启用不精确结果时的IEEE捕获。

\item {} 
\sphinxAtStartPar
{[}no{]}invalid：是否启用无效操作时的IEEE捕获。

\item {} 
\sphinxAtStartPar
{[}no{]}overflow：是否启用上溢时的IEEE捕获。

\item {} 
\sphinxAtStartPar
{[}no{]}underflow：是否启用下溢时的IEEE捕获。

\item {} 
\sphinxAtStartPar
{[}no{]}denormal：是否启用非正规时的IEEE捕获。

\item {} 
\sphinxAtStartPar
all：启用上述所有的IEEE捕获。

\item {} 
\sphinxAtStartPar
none：禁止启用上述所有的IEEE捕获。

\item {} 
\sphinxAtStartPar
common：启用最常见的IEEE捕获：被0除、无效操作和上溢。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fp\sphinxhyphen{}trap\sphinxhyphen{}all\sphinxstyleemphasis{=mode{[},mode,…{]}}：设置所有函数的浮点异常捕获模式。\sphinxstyleemphasis{mode}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}no{]}divzero：是否启用被0除时的IEEE捕获。

\item {} 
\sphinxAtStartPar
{[}no{]}inexact：是否启用不精确结果时的IEEE捕获。

\item {} 
\sphinxAtStartPar
{[}no{]}invalid：是否启用无效操作时的IEEE捕获。

\item {} 
\sphinxAtStartPar
{[}no{]}overflow：是否启用上溢时的IEEE捕获。

\item {} 
\sphinxAtStartPar
{[}no{]}underflow：是否启用下溢时的IEEE捕获。

\item {} 
\sphinxAtStartPar
{[}no{]}denormal：是否启用非正规时的IEEE捕获。

\item {} 
\sphinxAtStartPar
all：启用上述所有的IEEE捕获。

\item {} 
\sphinxAtStartPar
none：禁止启用上述所有的IEEE捕获。

\item {} 
\sphinxAtStartPar
common：启用最常见的IEEE捕获：被0除、无效操作和上溢。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ftz：赋值非常规操作结果为0。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mp1：提高浮点操作的精度和一致性。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pc\sphinxstyleemphasis{n}：设定浮点尾数精度。\sphinxstyleemphasis{n}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
32：四舍五入尾数到24位（单精度）。

\item {} 
\sphinxAtStartPar
64：四舍五入尾数到53位（双精度）。

\item {} 
\sphinxAtStartPar
80：四舍五入尾数到64位（扩展精度）。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}prec\sphinxhyphen{}div、\sphinxhyphen{}no\sphinxhyphen{}prec\sphinxhyphen{}div：是否提高浮点除的精度。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}prec\sphinxhyphen{}sqrt、\sphinxhyphen{}no\sphinxhyphen{}prec\sphinxhyphen{}sqrt：是否提高开根的精度。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}rcd：启用快速浮点数到整数转换。

\end{itemize}


\subsubsection{内联选项}
\label{\detokenize{compiler/intel:id8}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}gnu89\sphinxhyphen{}inline：设定编译器在C99模式时使用C89定义处理内联函数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}finline、\sphinxhyphen{}fno\sphinxhyphen{}inline：是否对\_\_inline声明的函数进行内联，并执行C++内联。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}finline\sphinxhyphen{}functions、\sphinxhyphen{}fno\sphinxhyphen{}inline\sphinxhyphen{}functions：对单个文件编译时启用函数内联。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}finline\sphinxhyphen{}limit\sphinxstyleemphasis{=n}：设定内联函数的最大数。\sphinxstyleemphasis{n}为非负整数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}inline\sphinxhyphen{}calloc、\sphinxhyphen{}no\sphinxhyphen{}inline\sphinxhyphen{}calloc：是否设定编译器内联调用calloc()为调用malloc()和memset()。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}inline\sphinxhyphen{}factor、\sphinxhyphen{}no\sphinxhyphen{}inline\sphinxhyphen{}factor：是否设定适用于所有内联选项定义的上限的比例乘法器。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}inline\sphinxhyphen{}level\sphinxstyleemphasis{=n}：设定内联函数的展开级别。\sphinxstyleemphasis{n}可以为0、1、2.

\end{itemize}


\subsubsection{输出、调试及预编译头文件(PCH)选项}
\label{\detokenize{compiler/intel:pch}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}c：仅编译成对象文件（.o文件）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}debug \sphinxstyleemphasis{{[}keyword{]}}：设定是否生成调试信息。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
none：不生成调试信息。

\item {} 
\sphinxAtStartPar
full或all：生成完全调试信息。

\item {} 
\sphinxAtStartPar
minimal：生成最少调试信息。

\item {} 
\sphinxAtStartPar
{[}no{]}emit\_column：设定是否针对调试生成列号信息。

\item {} 
\sphinxAtStartPar
{[}no{]}expr\sphinxhyphen{}source\sphinxhyphen{}pos：设定是否在表达式粒度级别生成源位置信息。

\item {} 
\sphinxAtStartPar
{[}no{]}inline\sphinxhyphen{}debug\sphinxhyphen{}info：设定是否针对内联代码生成增强调试信息。

\item {} 
\sphinxAtStartPar
{[}no{]}macros：设定是否针对C/C++宏生成调试信息。

\item {} 
\sphinxAtStartPar
{[}no{]}pubnames：设定是否生成DWARF debug\_pubnames节。

\item {} 
\sphinxAtStartPar
{[}no{]}semantic\sphinxhyphen{}stepping：设定是否生成针对断点和单步的增强调试信息。

\item {} 
\sphinxAtStartPar
{[}no{]}variable\sphinxhyphen{}locations：设定是否编译器生成有助于寻找标量局部变量的增强型调试信息。

\item {} 
\sphinxAtStartPar
extended：设定关键字值semantic\sphinxhyphen{}stepping和variable\sphinxhyphen{}locations。

\item {} 
\sphinxAtStartPar
{[}no{]}parallel：设定是否编译器生成并行调试代码指令以有助于线程数据共享和可重入调用探测。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}g：包含调试信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}g0：禁止生成符号调试信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}gdwarf\sphinxhyphen{}\sphinxstyleemphasis{n}：设定生成调试信息时的DWARF版本，\sphinxstyleemphasis{n}可以为2、3、4。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}o file：指定生成的文件名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pch：设定编译器使用适当的预编译头文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pch\sphinxhyphen{}create \sphinxstyleemphasis{filename}：设定生成预编译头文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pch\sphinxhyphen{}dir \sphinxstyleemphasis{dir}：设定搜索预编译头文件的目录。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pch\sphinxhyphen{}use \sphinxstyleemphasis{filename}：设定使用的预编译头文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}print\sphinxhyphen{}multi\sphinxhyphen{}lib：打印哪里系统库文件应该被发现。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}S：设定编译器只是生成汇编文件但并不进行链接。

\end{itemize}


\subsubsection{预处理选项}
\label{\detokenize{compiler/intel:id9}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}B\sphinxstyleemphasis{dir}：设定头文件、库文件及可执行文件的搜索路径。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}D\sphinxstyleemphasis{name{[}=value{]}}：设定编译时的宏及其值。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dD：输出预处理的源文件中的\#define指令。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dM：输出预处理后的宏定义。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dN：与\sphinxhyphen{}dD类似，但只输出的\#define指令的宏名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}E：设定预处理时输出到标注输出。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}EP：设定预处理时输出到标注输出，忽略\#line指令。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}gcc、\sphinxhyphen{}no\sphinxhyphen{}gcc、\sphinxhyphen{}gcc\sphinxhyphen{}sys：判定确定的GNU宏(\_\_GNUC\_\_、\_\_GNUC\_MINOR\_\_和\_\_GNUC\_PATCHLEVEL\_\_)是否定义。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}gcc\sphinxhyphen{}include\sphinxhyphen{}dir、\sphinxhyphen{}no\sphinxhyphen{}gcc\sphinxhyphen{}include\sphinxhyphen{}dir：设定是否将gcc设定的头文件路径加入到头文件路径中。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}H：编译时显示头文件顺序并继续编译。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}I：设定头文件附加搜索路径。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}icc、\sphinxhyphen{}no\sphinxhyphen{}icc：设定Intel宏(\_\_INTEL\_COMPILER)是否定义。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}idirafter\sphinxstyleemphasis{dir}：设定\sphinxstyleemphasis{dir}路径到第二个头文件搜索路径中。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}imacros \sphinxstyleemphasis{filename}：允许一个头文件在编译时在其它头文件前面。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}iprefix \sphinxstyleemphasis{prefix}：指定包含头文件的参考目录的前缀。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}iquote \sphinxstyleemphasis{dir}：在搜索的头文件路径前面增加\sphinxstyleemphasis{dir}目录以供那些使用引号而不是尖括号的文件使用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}isystem\sphinxstyleemphasis{dir}：附加\sphinxstyleemphasis{dir}目录到系统头文件的开始。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}iwithprefix\sphinxstyleemphasis{dir}：附加\sphinxstyleemphasis{dir}目录到通过\sphinxhyphen{}iprefix引入的前缀后，并将其放在头文件目录末尾的头文件搜索路径中。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}iwithprefixbeforex\sphinxstyleemphasis{dir}：除头文件目录\sphinxstyleemphasis{dir}放置的位置与\sphinxhyphen{}I声明的一样外，与\sphinxhyphen{}iwithprefix类似。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}M：让编译器针对各源文件生成makefile依赖行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MD：预处理和编译，生成后缀为.d包含依赖关系的输出文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MF\sphinxstyleemphasis{filename}：让编译器在一个文件中生成makefile依赖信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MG：让编译器针对各源文件生成makefile依赖行。与\sphinxhyphen{}M类似，但将缺失的头文件作为生成的文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MM：让编译器针对各源文件生成makefile依赖行。与\sphinxhyphen{}M类似，但不包含系统头文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MMD：预处理和编译，生成后缀为.d包含依赖关系的输出文件。与\sphinxhyphen{}M类似，但不包含系统头文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MP：让编译器对每个依赖生成伪目标。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MQ\sphinxstyleemphasis{target}：对依赖生成改变默认目标规则。\sphinxstyleemphasis{target}是要使用的目标规则。与\sphinxhyphen{}MT类似，但引用特定Make字符。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MT\sphinxstyleemphasis{target}：对依赖生成改变默认目标规则。\sphinxstyleemphasis{target}是要使用的目标规则。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}nostdinc++：对C++不搜索标准目录下的头文件，而搜索其它标准目录。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}P：停止编译处理，并将结果写入文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pragma\sphinxhyphen{}optimization\sphinxhyphen{}level\sphinxstyleemphasis{=interpretation}：指定如没有前缀指定时，采用何种优化级别编译指令解释。\sphinxstyleemphasis{interpretation}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
Intel：Intel解释。

\item {} 
\sphinxAtStartPar
GCC：GCC解释。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}U\sphinxstyleemphasis{name}：取消某个宏的预定义。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}undef：取消所有宏的预定义。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}X：从搜索路径中去除标准搜索路径。

\end{itemize}


\subsubsection{C/C++语言选项}
\label{\detokenize{compiler/intel:c-c}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ansi：与gcc的\sphinxhyphen{}ansi选项兼容。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}check\sphinxstyleemphasis{=keyword{[}, keyword…{]}}：设定在运行时检查某些条件。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}no{]}conversions：设定是否在转换成较小类型时进行检查。

\item {} 
\sphinxAtStartPar
{[}no{]}stack：设定是否在堆栈帧检查。

\item {} 
\sphinxAtStartPar
{[}no{]}uninit：设定是否对未初始化变量进行检查。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fno\sphinxhyphen{}gnu\sphinxhyphen{}keywords：让编译器不将typeof作为一个关键字。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fpermissive：让编译器允许非一致性代码。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fsyntax\sphinxhyphen{}only：让编译器仅作语法检查，不生成目标代码。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}funsigned\sphinxhyphen{}char：将默认字符类型变为无符号类型。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}help\sphinxhyphen{}pragma：显示所有支持的编译指令。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}intel\sphinxhyphen{}extensions、\sphinxhyphen{}no\sphinxhyphen{}intel\sphinxhyphen{}extensions：是否启用Intel
C和C++语言扩展。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}restrict、\sphinxhyphen{}no\sphinxhyphen{}restrict：设定是否采用约束限定进行指针消岐。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}std\sphinxstyleemphasis{=val}：\sphinxstyleemphasis{val}可以为c89、c99、gnu89、gnu++89或c++0x，分别对应相应标准。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}stdlib\sphinxstyleemphasis{{[}=keyword{]}}：设定链接时使用的C++库。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
libstdc++：链接使用GNU libstdc++库。

\item {} 
\sphinxAtStartPar
libc++：链接使用libc++库。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}strict\sphinxhyphen{}ansi：让编译器采用严格的ANSI一致性语法。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}x \sphinxstyleemphasis{type}：\sphinxstyleemphasis{type}可以为c、c++、c\sphinxhyphen{}header、cpp\sphinxhyphen{}output、c++\sphinxhyphen{}cpp\sphinxhyphen{}output、assembler、assembler\sphinxhyphen{}with\sphinxhyphen{}cpp或none，分别表示c源文件等，以使所有源文件都被认为是此类型的。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Zp\sphinxstyleemphasis{{[}n{]}}：设定结构体在字节边界的对齐。n是字节大小边界，可以为1、2、4、8和16。

\end{itemize}


\subsubsection{Fortran语言选项}
\label{\detokenize{compiler/intel:id10}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}auto\sphinxhyphen{}scalar：INTEGER、REAL、COMPLEX和LOGICAL内在类型变量，如未声明有SAVE属性，将分配到运行时堆栈中，下次调用此函数时变量赋值。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}allow
\sphinxstyleemphasis{keyword}：设定编译器是否允许某些行为。\sphinxstyleemphasis{keyword}可以为{[}no{]}fpp\_comments，声明fpp预处理器如何处理在预处理指令行中的Fortran行尾注释。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}altparam、\sphinxhyphen{}noaltparam：设定是否允许不同的语法（不带括号）PARAMETER声明。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}assume \sphinxstyleemphasis{keyword{[}, keyword…{]}}：设定某些假设。\sphinxstyleemphasis{keyword}可以为：none、{[}no{]}bscc、{[}no{]}buffered\_io、{[}no{]}buffered\_stdout、{[}no{]}byterecl、{[}no{]}cc\_omp、{[}no{]}dummy\_aliases、{[}no{]}fpe\_summary、{[}no{]}ieee\_fpe\_flags、{[}no{]}minus0、{[}no{]}old\_boz、{[}no{]}old\_ldout\_format、{[}no{]}old\_logical\_ldio、{[}no{]}old\_maxminloc、{[}no{]}old\_unit\_star、{[}no{]}old\_xor、{[}no{]}protect\_constants、{[}no{]}protect\_parens、{[}no{]}realloc\_lhs、{[}no{]}source\_include、{[}no{]}std\_intent\_in、{[}no{]}std\_minus0\_rounding、{[}no{]}std\_mod\_proc\_name、{[}no{]}std\_value、{[}no{]}underscore、{[}no{]}2underscores、{[}no{]}writeable\sphinxhyphen{}strings等

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ccdefault \sphinxstyleemphasis{keyword}：设置文件显示在终端上时的回车类型。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
none：设定编译器使用无回车控制预处理。

\item {} 
\sphinxAtStartPar
default：设定编译器使用默认回车控制设定。

\item {} 
\sphinxAtStartPar
fortran：设定编译器使用通常的第一个字符的Fortran解释。如字符0使得在输出一个记录时先输出一个空行。

\item {} 
\sphinxAtStartPar
list：设定编译器记录之间出输出换行。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}check\sphinxstyleemphasis{=keyword{[}, keyword…{]}}：设定在运行时检查某些条件。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
none：禁止所有检查。

\item {} 
\sphinxAtStartPar
{[}no{]}arg\_temp\_created：设定是否在子函数调用前检查实参。

\item {} 
\sphinxAtStartPar
{[}no{]}assume：设定是否在测试在ASSUME指令中的标量布尔表达式为真，或在ASSUME\_ALIGNED指令中的地址对齐声明的类型边界时进行检查。

\item {} 
\sphinxAtStartPar
{[}no{]}bounds：设定是否对数组下标和字符子字符串表达式进行检查。

\item {} 
\sphinxAtStartPar
{[}no{]}format：设定是否对格式化输出的数据类型进行检查。

\item {} 
\sphinxAtStartPar
{[}no{]}output\_conversion：设定是否对在指定的格式描述域内的数据拟合进行检查。

\item {} 
\sphinxAtStartPar
{[}no{]}pointers：设定是否对存在一些分离的或未初始化的指针或为分配的可分配目标时进行检查。

\item {} 
\sphinxAtStartPar
{[}no{]}stack：设定是否在堆栈帧检查。

\item {} 
\sphinxAtStartPar
{[}no{]}uninit：设定是否对未初始化变量进行检查。

\item {} 
\sphinxAtStartPar
all：启用所有检查。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}cpp：对源代码进行预处理，等价于\sphinxhyphen{}fpp。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}extend\sphinxhyphen{}source\sphinxstyleemphasis{{[}size{]}}：指明固定格式的Fortran源代码宽度，\sphinxstyleemphasis{size}可为72、80和132。也可直接用\sphinxhyphen{}72、\sphinxhyphen{}80和\sphinxhyphen{}132指定，默认为72字符。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fixed：指明Fortran源代码为固定格式，默认由文件后缀设定格式类别。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}free：指明Fortran源程序为自由格式，默认由文件后缀设定格式类别。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}nofree：指明Fortran源程序为固定格式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}implicitnone：指明默认变量名为未定义。建议在写程序时添加implicit none语句，以避免出现由于默认类型造成的错误。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}names \sphinxstyleemphasis{keyword}：设定如何解释源代码的标志符和外部名。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
lowercase：让编译器忽略标识符的大小写不同，并转换外部名为小写。

\item {} 
\sphinxAtStartPar
uppercase：让编译器忽略标识符的大小写不同，并转换外部名为大写。

\item {} 
\sphinxAtStartPar
as\_is：让编译器区分标识符的大小写，并保留外部名的大小写。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pad\sphinxhyphen{}source、\sphinxhyphen{}nopad\sphinxhyphen{}source：对固定格式的源码记录是否采用空白填充行尾。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}stand \sphinxstyleemphasis{keyword}：以指定Fortran标准进行编译，编译时显示源文件中不符合此标准的信息。\sphinxstyleemphasis{keyword}可为f03、f90、f95和none，分别对应显示不符合Fortran
2003、90、95的代码信息和不显示任何非标准的代码信息，也可写为\sphinxhyphen{}std\sphinxstyleemphasis{keyword}，此时\sphinxstyleemphasis{keyword}不带f，可为03、90、95。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}standard\sphinxhyphen{}semantics：设定编译器的当前Fortran标准行为是否完全实现。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}syntax\sphinxhyphen{}only：仅仅检查代码的语法错误，并不进行其它操作。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}wrap\sphinxhyphen{}margin、\sphinxhyphen{}no\sphinxhyphen{}wrap\sphinxhyphen{}margin：提供一种在Fortran列表输出时禁止右边缘包装。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}us：编译时给外部用户定义的函数名添加一个下划线，等价于\sphinxhyphen{}assume
underscore，如果编译时显示\_函数找不到时也许添加此选项即可解决。

\end{itemize}


\subsubsection{数据选项}
\label{\detokenize{compiler/intel:id11}}\begin{itemize}
\item {} 
\sphinxAtStartPar
共有选项
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fcommon、\sphinxhyphen{}fno\sphinxhyphen{}common：设定编译器是否将common符号作为全局定义。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fpic、\sphinxhyphen{}fno\sphinxhyphen{}pic：是否生成位置无关代码。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fpie：类似\sphinxhyphen{}fpic生成位置无关代码，但生成的代码只能链接到可执行程序。
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}gcc：定义GNU宏。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}no\sphinxhyphen{}gcc：取消定义GNU宏。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}gcc\sphinxhyphen{}sys：只有在编译系统头文件时定义GNU宏。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mcmodel=\sphinxstyleemphasis{mem\_model}：设定生成代码和存储数据时的内存模型。\sphinxstyleemphasis{mem\_model}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
small：让编译器限制代码和数据使用最开始的2GB地址空间。对所有代码和数据的访问可以使用指令指针(IP)相对地址。

\item {} 
\sphinxAtStartPar
medium：让编译器限制代码使用最开始的2GB地址空间，对数据没有内存限制。对所有代码的访问可以使用指令指针（IP）相对地址，但对数据的访问必须采用绝对地址。

\item {} 
\sphinxAtStartPar
large：对代码和数据不做内存限制。所有访问都得使用绝对地址。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mlong\sphinxhyphen{}double\sphinxhyphen{}\sphinxstyleemphasis{n}：覆盖掉默认的长双精度数据类型配置。\sphinxstyleemphasis{n}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
64：设定长双精度数据为64位。

\item {} 
\sphinxAtStartPar
80：设定长双精度数据为80位。

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
C/C++专有选项
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}auto\sphinxhyphen{}ilp32：让编译器分析程序设定能否将64位指针缩成32位指针，能否将64位长整数缩成32位长整数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}auto\sphinxhyphen{}p32：让编译器分析程序设定能否将64位指针缩成32位指针。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}check\sphinxhyphen{}pointers=\sphinxstyleemphasis{keyword}：设定编译器是否检查使用指针访问的内存边界。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
none：禁止检查，此为默认选项。

\item {} 
\sphinxAtStartPar
rw：检查通过指针读写的内存边界。

\item {} 
\sphinxAtStartPar
write：只检查通过内存写的内存边界。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}check\sphinxhyphen{}pointers\sphinxhyphen{}dangling\sphinxstyleemphasis{keyword}：设定编译器是否对悬挂（dangling）指针参考进行检查。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
none：禁止检查悬挂指针参考，此为默认选项。

\item {} 
\sphinxAtStartPar
heap：检查heap的悬挂指针参考。

\item {} 
\sphinxAtStartPar
stack：检查stack的悬挂指针参考。

\item {} 
\sphinxAtStartPar
all：检查上述所有的悬挂指针参考。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fkeep\sphinxhyphen{}static\sphinxhyphen{}consts、\sphinxhyphen{}fno\sphinxhyphen{}keep\sphinxhyphen{}static\sphinxhyphen{}consts：设定编译器是否保留在源文件中没有参考的变量分配。

\end{itemize}

\item {} 
\sphinxAtStartPar
Fortran专有选项
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}convert \sphinxstyleemphasis{{[}keyword{]}}：转换无格式数据的类型，比如\sphinxstyleemphasis{keyword}为big\_endian和little\_endian时，分别表示无格式的输入输出为big\_endian和little\_endian格式，更多格式类型，请看编译器手册。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}double\sphinxhyphen{}size \sphinxstyleemphasis{size}：设定DOUBLE PRECISION和DOUBLE COMPLEX声明、常数、函数和内部函数的默认KIND。\sphinxstyleemphasis{size}可以为64或128，分别对应KIND=8和KIND=16。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dyncom \sphinxstyleemphasis{“common1,common2,…”}：对指定的common块启用运行时动态分配。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fzero\sphinxhyphen{}initialized\sphinxhyphen{}in\sphinxhyphen{}bss、\sphinxhyphen{}fno\sphinxhyphen{}zero\sphinxhyphen{}initialized\sphinxhyphen{}in\sphinxhyphen{}bss：设定编译器是否将数据显式赋值为0的变量放置在DATA块内。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}intconstant、\sphinxhyphen{}nointconstant：让编译器使用FORTRAN 77语法设定整型常数的KIND参数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}integer\sphinxhyphen{}size \sphinxstyleemphasis{size}：设定整型和逻辑变量的默认KIND。\sphinxstyleemphasis{size}可以为16、32或64，分别对应KIND=2、KIND=4或KIND=8。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}no\sphinxhyphen{}bss\sphinxhyphen{}init：让编译器将任何未初始化变量和显式初始化为0的变量放置在DATA块。默认不启用，放置在BSS块。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}real\sphinxhyphen{}size \sphinxstyleemphasis{size}：设定实型变量的默认KIND。\sphinxstyleemphasis{size}可以为32、64或18，分别对应KIND=4、KIND=8或KIND=16。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}save：强制变量值存储在静态内存中。此选项保存递归函数和用AUTOMATIC声明的所有变量（除本地变量外）在静态分配中，下次调用时可继续用。默认为\sphinxhyphen{}auto\sphinxhyphen{}scalar，内在类型INTEGER、REAL、COMPLEX和LOGICAL变量分配到运行时堆栈中。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}zero、\sphinxhyphen{}nozero：是否将所有保存的但未初始化的内在类型INTEGER、REAL、COMPLEX或LOGICAL的局部变量值初始为0。

\end{itemize}

\end{itemize}


\subsubsection{编译器诊断选项}
\label{\detokenize{compiler/intel:id12}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}diag\sphinxhyphen{}\sphinxstyleemphasis{type=diag\sphinxhyphen{}list}：控制显示的诊断信息。\sphinxstyleemphasis{type}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
enable：启用一个或一组诊断信息。

\item {} 
\sphinxAtStartPar
disable：禁用一个或一组诊断信息。

\item {} 
\sphinxAtStartPar
error：让编译器将诊断信息变为错误。

\item {} 
\sphinxAtStartPar
warning：让编译器将诊断信息变成警告

\item {} 
\sphinxAtStartPar
remark：让编译器将诊断信息变为备注。

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{diag\sphinxhyphen{}list}可为：driver、port\sphinxhyphen{}win、thread、vec、par 、openmp 、warn、error 、remark 、cpu\sphinxhyphen{}dispatch 、id{[},id,…{]} 、tag{[},tag,…{]}等。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}traceback、\sphinxhyphen{}notraceback：编译时在对象文件中生成额外的信息使得在运行出错时可以提供源文件回朔信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}w：编译时不显示任何警告，只显示错误。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}w\sphinxstyleemphasis{n}：设置编译器生成的诊断信息级别。\sphinxstyleemphasis{n}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
0：对错误生成诊断信息，屏蔽掉警告信息。

\item {} 
\sphinxAtStartPar
1：对错误和警告生成诊断信息。此为默认选项。

\item {} 
\sphinxAtStartPar
2：对错误和警告生成诊断信息，并增加些额外的警告信息。

\item {} 
\sphinxAtStartPar
3：对备注、错误和警告生成诊断信息，并在级别2的基础上再增加额外警告信息。建议对产品使用此级别。

\item {} 
\sphinxAtStartPar
4：在级别3的基础上再增加一些警告和备注信息，这些增加的信息一般可以安全忽略。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Wabi、\sphinxhyphen{}Wno\sphinxhyphen{}abi：设定生成的代码不是C++ ABI兼容时是否显示警告信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Wall：编译时显示警告和错误信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Wbrief：采用简短方式显示诊断信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Wcheck：让编译器在对特定代码在编译时进行检查。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Werror：将所有警告信息变为错误信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Werror\sphinxhyphen{}all将所有警告和备注信息变为错误信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Winline：设定编译器显示哪些函数被内联，哪些未被内联。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Wunused\sphinxhyphen{}function、\sphinxhyphen{}Wno\sphinxhyphen{}unused\sphinxhyphen{}functio：设定是否在声明的函数未使用时显示警告信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Wunused\sphinxhyphen{}variable、\sphinxhyphen{}Wno\sphinxhyphen{}unused\sphinxhyphen{}variable：设定是否在声明的变量未使用时显示警告信息。

\end{itemize}


\subsubsection{兼容性选项}
\label{\detokenize{compiler/intel:id13}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}f66：使用FORTRAN 66标准，默认为使用 Fortran 95标准。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}f77rtl、\sphinxhyphen{}nof77rtl： 是否使用FORTRAN 77运行时行为，默认为使用Intel Fortran运行时行为。控制以下行为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
当unit没有与一个文件对应时，一些INQUIRE说明符将返回不同的值：
\begin{itemize}
\item {} 
\sphinxAtStartPar
NUMBER= 返回0；

\item {} 
\sphinxAtStartPar
ACCESS= 返回’UNKNOWN’；

\item {} 
\sphinxAtStartPar
BLANK= 返回’UNKNOWN’；

\item {} 
\sphinxAtStartPar
FORM= 返回’UNKNOWN’。

\end{itemize}

\item {} 
\sphinxAtStartPar
PAD= 对格式化输入默认为”NO’。

\item {} 
\sphinxAtStartPar
NAMELIST和列表输入的字符串必需用单引号或双引号分隔。

\item {} 
\sphinxAtStartPar
当处理NAMELIST输入时：
\begin{itemize}
\item {} 
\sphinxAtStartPar
每个记录的第一列被忽略。

\item {} 
\sphinxAtStartPar
出现在组名前的’\$’或’\&’必须在输入记录的第二列。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fpscomp {[}keyword{[}, keyword…{]}{]}、\sphinxhyphen{}nofpscomp：设定是否某些特征与IntelFortran或Microsoft* Fortran PowerStation兼容。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
none：没有选项需要用于兼容性。

\item {} 
\sphinxAtStartPar
{[}no{]}filesfromcmd：设定当OPEN声明中FILE=说明符为空时的兼容性。

\item {} 
\sphinxAtStartPar
{[}no{]}general：设定当Fortran PowerStation和IntelFortran语法存在不同时的兼容性。

\item {} 
\sphinxAtStartPar
{[}no{]}ioformat：设定列表格式和无格式IO时的兼容性。

\item {} 
\sphinxAtStartPar
{[}no{]}libs：设定可移植性库是否传递给链接器。

\item {} 
\sphinxAtStartPar
{[}no{]}ldio\_spacing：设定是否在运行时在数值量后字符值前插入一个空白。

\item {} 
\sphinxAtStartPar
{[}no{]}logicals：设定代表LOGICAL值的兼容性。

\item {} 
\sphinxAtStartPar
all：设定所有选项用于兼容性。

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fabi\sphinxhyphen{}version=\sphinxstyleemphasis{n}：设定使用指定版本的ABI实现。\sphinxstyleemphasis{n}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
0：使用最新的ABI实现。

\item {} 
\sphinxAtStartPar
1：使用gcc 3.2和gcc 3.3使用的ABI实现。

\item {} 
\sphinxAtStartPar
2：使用gcc 3.4及更高的gcc中使用的ABI实现。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}gcc\sphinxhyphen{}name=\sphinxstyleemphasis{name}：设定使用的gcc编译器的名字。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}gxx\sphinxhyphen{}name\sphinxstyleemphasis{name}：设定使用的g++编译器的名字。

\end{itemize}


\subsubsection{链接和链接器选项}
\label{\detokenize{compiler/intel:id14}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Bdynamic：在运行时动态链接所需要的库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Bstatic ：静态链接用户生成的库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}cxxlib\sphinxstyleemphasis{{[}=dir{]}}、\sphinxhyphen{}cxxlib\sphinxhyphen{}nostd、\sphinxhyphen{}no\sphinxhyphen{}cxxlib：设定是否使用gcc提供的C++运行时库及头文件。\sphinxstyleemphasis{dir}为gcc二进制及库文件的顶层目录。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}I\sphinxstyleemphasis{dir}：指明头文件的搜索路径。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}L\sphinxstyleemphasis{dir}：指明库的搜索路径。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}l\sphinxstyleemphasis{string}：指明所需链接的库名，如库名为libxyz.a，则可用\sphinxhyphen{}lxyz指定。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}no\sphinxhyphen{}libgcc：禁止使用特定gcc库链接。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}nodefaultlibs：禁止使用默认库链接。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}nostartfiles：禁止使用标准启动文件链接。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}nostdlib：禁止使用标准启动和库文件链接。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pie、\sphinxhyphen{}no\sphinxhyphen{}pie：设定编译器是否生成需要链接进可执行程序的位置独立代码

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pthread：对多线程启用pthreads库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}shared：生成共享对象文件而不是可执行文件，必须在编译每个对象文件时使用\sphinxhyphen{}fpic选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}shared\sphinxhyphen{}intel：动态链接Intel库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}shared\sphinxhyphen{}libgcc：动态链接GNU libgcc库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}static：静态链接所有库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}static\sphinxhyphen{}intel：静态链接Intel库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}static\sphinxhyphen{}libgcc：静态链接GNU libgcc库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}static\sphinxhyphen{}libstdc++：静态链接GNU libstdc++库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}u \sphinxstyleemphasis{symbol}：设定指定的符号未定义。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}v：显示驱动工具编译信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Wa\sphinxstyleemphasis{,option1{[},option2,…{]}}：传递参数给汇编器进行处理。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Wl\sphinxstyleemphasis{,option1{[},option2,…{]}}：传递参数给链接器进行处理。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Wp\sphinxstyleemphasis{,option1{[},option2,…{]}}：传递参数给预处理器。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Xlinker \sphinxstyleemphasis{option}：将option信息传递给链接器。

\end{itemize}


\subsubsection{其它选项}
\label{\detokenize{compiler/intel:id15}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}help \sphinxstyleemphasis{{[}category{]}}：显示帮助。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}sox\sphinxstyleemphasis{{[}=keyword{[},keyword{]}{]}}、\sphinxhyphen{}no\sphinxhyphen{}sox：设定是否让编译时在生成的可执行文件中保存编译选项和版本等信息，也可以指定是否保存子程序等信息。
\begin{itemize}
\item {} 
\sphinxAtStartPar
inline：包含在各目标文件中的内联子程序名。

\item {} 
\sphinxAtStartPar
profile：包含编译时采用\sphinxhyphen{}prof\sphinxhyphen{}use的子程序列表，以及存储概要信息的.dpi文件名和指明使用的和忽略的概要信息。

\end{itemize}

\sphinxAtStartPar
存储的信息可以使用以下方法查看：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{objdump \sphinxhyphen{}sj .comment a.out}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{strings \sphinxhyphen{}a a.out | grep comment:}}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}V：显示版本信息。

\item {} 
\sphinxAtStartPar
–version：显示版本信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}watch\sphinxstyleemphasis{{[}=keyword{[}, keyword…{]}{]}}、\sphinxhyphen{}nowatch：设定是否在控制台显示特定信息。\sphinxstyleemphasis{keyword}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
none：禁止cmd和source。

\item {} 
\sphinxAtStartPar
{[}no{]}cmd：设定是否显示驱动工具命令及执行。

\item {} 
\sphinxAtStartPar
{[}no{]}source：设定是否显示编译的文件名。

\item {} 
\sphinxAtStartPar
all：启用cmd和source。

\end{itemize}

\end{itemize}

\sphinxstepscope


\section{PGI C/C++ Fortran编译器}
\label{\detokenize{compiler/pgi:pgi-c-c-fortran}}\label{\detokenize{compiler/pgi::doc}}

\subsection{PGI C/C++ Fortran编译器简介}
\label{\detokenize{compiler/pgi:id1}}
\sphinxAtStartPar
\sphinxhref{http://www.pgroup.com/products/pgiworkstation.htm}{PGI C/C++ Fortran编译器}是一种针对多种CPU与操作系统的高性能编译器，可用于开发复杂且要进行大量计算的程序。当前安装的版本为2016.7和2014.10，分别安装在、。安装在，可用\sphinxcode{\sphinxupquote{module avail}}查看，用\sphinxcode{\sphinxupquote{moudle load 模块名}}使用，或在自己的之类环境设置文件中添加以下代码设置：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{PATH}\PYG{o}{=}/opt/pgi/linux86\PYGZhy{}64/14.10/bin:\PYG{n+nv}{\PYGZdl{}PATH}
\PYG{n+nv}{MANPATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}MANPATH}:/opt/pgi/linux86\PYGZhy{}64/14.10/man
\PYG{n+nb}{export} PATH MANPATH
\end{sphinxVerbatim}

\sphinxAtStartPar
PGI编译器编译C、C++、Fortran 77源程序的命令分别为\sphinxcode{\sphinxupquote{pgcc}}、\sphinxcode{\sphinxupquote{pgCC|pgc++}} {[}1{]}\_和\sphinxcode{\sphinxupquote{pgf77}}，编译Fortran 90（为了描述方便，本手册中将Fortran 90、95、2003、2008标准统称为Fortran 90）的源程序的命令有\sphinxcode{\sphinxupquote{pgf90}}、\sphinxcode{\sphinxupquote{pgf901}}、\sphinxcode{\sphinxupquote{pgf902}}、\sphinxcode{\sphinxupquote{pgf90\_ex}}、\sphinxcode{\sphinxupquote{pgf95}}和\sphinxcode{\sphinxupquote{pgfortran}}。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
编译工具
&\sphinxstyletheadfamily 
\sphinxAtStartPar
语言或函数
&\sphinxstyletheadfamily 
\sphinxAtStartPar
命令
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
PGF77
&
\sphinxAtStartPar
ANSI FORTRAN 77
&
\sphinxAtStartPar
pgf77
\\
\sphinxhline
\sphinxAtStartPar
PGFORTRAN
&
\sphinxAtStartPar
ISO/ANSI Fortran 2003
&
\sphinxAtStartPar
pgfortran、pgf90、pgf95
\\
\sphinxhline
\sphinxAtStartPar
PGCC
&
\sphinxAtStartPar
ISO/ANSI C11 and K\&R C
&
\sphinxAtStartPar
pgcc
\\
\sphinxhline
\sphinxAtStartPar
PGC++
&
\sphinxAtStartPar
ISO/ANSI C++14 with GNU compatibility
&
\sphinxAtStartPar
pgc++
\\
\sphinxhline
\sphinxAtStartPar
PGDBG
&
\sphinxAtStartPar
Source code debugger
&
\sphinxAtStartPar
pgdbg
\\
\sphinxhline
\sphinxAtStartPar
PGPROF
&
\sphinxAtStartPar
Performance profiler
&
\sphinxAtStartPar
pgprof
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
官方手册目录：。


\subsection{编译错误}
\label{\detokenize{compiler/pgi:id2}}\label{\detokenize{compiler/pgi:id3}}
\sphinxAtStartPar
编译时的出错信息类似以下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PGF90}\PYG{o}{\PYGZhy{}}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{0034}\PYG{o}{\PYGZhy{}}\PYG{n}{Syntax} \PYG{n}{error} \PYG{n}{at} \PYG{o+ow}{or} \PYG{n}{near} \PYG{o}{*} \PYG{p}{(}\PYG{n}{NOlihm}\PYG{o}{.}\PYG{n}{f90}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
编译错误的格式为：

\sphinxAtStartPar
大写的编译命令\sphinxhyphen{}严重级别\sphinxhyphen{}错误编号\sphinxhyphen{}解释，含指明位置(文件名: 行号)

\sphinxAtStartPar
错误严重级别分为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
I：信息

\item {} 
\sphinxAtStartPar
W：警告

\item {} 
\sphinxAtStartPar
S：严重

\item {} 
\sphinxAtStartPar
F：致命

\item {} 
\sphinxAtStartPar
V：其它

\end{itemize}

\sphinxAtStartPar
Fortran程序编译错误解释，参见：\sphinxhref{http://scc.ustc.edu.cn/zlsc/tc4600/pgi/pgi14ref.pdf}{PGI Compiler Reference Guide}\sphinxhyphen{}>Chapter
9. MESSAGES\sphinxhyphen{}>9.3. Fortran Compiler Error Messages\sphinxhyphen{}>9.3.2. Message List


\subsection{Fortran程序运行错误}
\label{\detokenize{compiler/pgi:fortran}}\label{\detokenize{compiler/pgi:fortran-1}}
\sphinxAtStartPar
Fortran程序运行时错误解释，参见：\sphinxhref{http://scc.ustc.edu.cn/zlsc/tc4600/pgi/pgi14ref.pdf}{PGI Compiler Reference Guide}\sphinxhyphen{}>Chapter 9. MESSAGES\sphinxhyphen{}>9.4. Fortran Run\sphinxhyphen{}time Error Messages\sphinxhyphen{}>9.4.2. Message List


\subsection{PGI C/C++编译器重要编译选项}
\label{\detokenize{compiler/pgi:pgi-c-c}}
\sphinxAtStartPar
PGI编译器选项非常多，下面仅仅是列出一些本人认为常用的关于编译C程序的\sphinxcode{\sphinxupquote{pgcc}}命令的重要选项。编译C++程序的\sphinxcode{\sphinxupquote{pgc++|pgCC}}命令有稍微不同，建议仔细查看PGI相关资料。建议仔细查看编译器手册中关于程序优化的部分，多加测试，选择适合自己程序的编译选项以提高性能。


\subsubsection{一般选项}
\label{\detokenize{compiler/pgi:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\#：显示编译器、汇编器、链接器的调用信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}c：仅编译成对象文件（.o文件）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}defaultoptions和\sphinxhyphen{}nodefaultoptions：是否使用默认选项，默认为使用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}flags：显示所有可用的编译选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}help\sphinxstyleemphasis{{[}=option{]}}：显示帮助信息，optio\sphinxstyleemphasis{n}可以为groups、asm、debug、language、linker、opt、other、overall、phase、phase、prepro、suffix、switch、target和variable。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Minform\sphinxstyleemphasis{=level}：控制编译时错误信息的显示级别。level可以为fatal、file、severe、warn、inform，默认为\sphinxhyphen{}Minform=warn。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}noswitcherror：显示警告信息后，忽略未知命令行参数并继续进行编译。默认显示错误信息并且终止编译。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}o file：指定生成的文件名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}show：显示现有pgcc命令的配置信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}silent：不显示警告信息，与\sphinxhyphen{}Minform=severe等同。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}v：详细模式，在每个命令执行前显示其命令行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}V：显示编译器版本信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}w：编译时不显示任何警告，只显示错误。

\end{itemize}


\subsubsection{优化选项}
\label{\detokenize{compiler/pgi:id5}}\label{\detokenize{compiler/pgi:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fast：编译时选择针对目标平台的普通优化选项。用\sphinxcode{\sphinxupquote{pgcc \sphinxhyphen{}fast \sphinxhyphen{}help}}可以查看等价的开关。优化级别至少为O2，参看\sphinxhyphen{}O选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fastsse：对支持SSE和SSE2指令的CPU（如Intel Xeon CPU）编译时选择针对目标平台的优化选项。用\sphinxcode{\sphinxupquote{pgcc \sphinxhyphen{}fastsse \sphinxhyphen{}help}}可以查看等价的开关，优化级别至少为O2，参看\sphinxhyphen{}O选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fpic或\sphinxhyphen{}fPIC：编译器生成地址无关代码，以便可用于生成共享对象文件（动态链接库）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Kpic或\sphinxhyphen{}KPIC：与\sphinxhyphen{}fpic或\sphinxhyphen{}fPIC相同，为了与其余编译器兼容。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Minfo\sphinxstyleemphasis{{[}=option{[},option,…{]}{]}}：显示有用信息到标准错误输出，选项可为all、autoinline、inline、ipa、loop或opt、mp、time或stat。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mipa\sphinxstyleemphasis{{[}=option{[},option,…{]}{]}}和\sphinxhyphen{}Mnoipa：启用指定选项的过程间分析优化，默认为\sphinxhyphen{}Mnoipa。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mneginfo\sphinxstyleemphasis{=option{[},option…{]}}：使编译器显示为什么特定优化没有实现的信息。选项包括concur、loop和all。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mnoopenmp：当使用\sphinxhyphen{}mp选项时，忽略OpenMP并行指令。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mnosgimp：当使用\sphinxhyphen{}mp选项时，忽略SGI并行指令。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mpfi：生成概要导向工具，此时将会包含特殊代码收集运行时的统计信息以用于子序列编译。\sphinxhyphen{}Mpfi必须在链接时也得使用。当程序运行时，会生成概要导向文件pgfi.out。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mpfo：启用概要导向优化，此时必须在当前目录下有概要文件pgfi.out。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mprof\sphinxstyleemphasis{{[}=option{[},option,…{]}{]}}：设置性能功能概要选项。此选项可使得结果执行生成性能概要，以便PGPROF性能概要器分析。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mp\sphinxstyleemphasis{{[}=option{]}}：打开对源程序中的OpenMP并行指令的支持。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}O\sphinxstyleemphasis{{[}level{]}}：设置优化级别。level可设为0、1、2、3、4，其中4与3相同。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pg：使用gprof风格的基于抽样的概要刨析。

\end{itemize}


\subsubsection{调试选项}
\label{\detokenize{compiler/pgi:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}g：包含调试信息。

\end{itemize}


\subsubsection{预处理选项}
\label{\detokenize{compiler/pgi:id8}}\label{\detokenize{compiler/pgi:id9}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}C：预处理时保留C源文件中的注释。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}D\sphinxstyleemphasis{name{[}=def{]}}：预处理时定义宏name为def。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dD：打印源文件中已定义的宏及其值到标准输出。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dI：打印预处理中包含的所有文件信息，含文件名和定义时的行号。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dM：打印预处理时源文件已定义的宏及其值，含定义时的文件名和行号。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dN：与\sphinxhyphen{}dD类似，但只打印源文件已定义的宏，而不打印宏值。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}E：预处理每个.c文件，将结果发送给标准输出，但不进行编译、汇编或链接等操作。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}I\sphinxstyleemphasis{dir}：指明头文件的搜索路径。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}M：打印make的依赖关系到标准输出。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MD：打印make的依赖关系到文件file.d，其中file是编译文件的根名字。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MM：打印make的依赖关系到标准输出，但忽略系统头文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MMD：打印make的依赖关系到文件file.d，其中file是编译的文件的根名字，但忽略系统头文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}P：预处理每个文件，并保留每个file.c文件预处理后的结果到file.i。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}U\sphinxstyleemphasis{name}：去除预处理中的任何name的初始定义。

\end{itemize}


\subsubsection{链接选项}
\label{\detokenize{compiler/pgi:id10}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Bdynamic：在运行时动态链接所需的库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Bstatic：静态链接所需的库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Bstatic\_pgi ：动态链接系统库时静态链接PGI库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}g77libs：允许链接GNU \sphinxcode{\sphinxupquote{g77}}或\sphinxcode{\sphinxupquote{gcc}}命令生成的库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}l\sphinxstyleemphasis{string}：指明所需链接的库名。如库为libxyz.a，则可用\sphinxhyphen{}lxyz指定。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}L\sphinxstyleemphasis{dir}：指明库的搜索路径。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}m：显示链接拓扑。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mrpath和\sphinxhyphen{}Mnorpath：默认为\sphinxhyphen{}rpath，以给出包含PGI共享对象的路径。用\sphinxhyphen{}Mnorpath可以去除此路径。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pgf77libs：链接时添加pgf77运行库，以允许混合编程。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}r：生成可以重新链接的对象文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}R\sphinxstyleemphasis{directory}：对共享对象文件总搜索directory目录。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pgf90libs：链接时添加pgf90运行库，以允许混合编程。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}shared：生成共享对象而不是可执行文件，必须在编译每个对象文件时使用\sphinxhyphen{}fpic选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}soname\sphinxstyleemphasis{name}：生成共享对象时，用内在的DT\_SONAME代替指定的name。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}u\sphinxstyleemphasis{name}：传递给链接器，以生成未定义的引用。

\end{itemize}


\subsubsection{C/C++语言选项}
\label{\detokenize{compiler/pgi:c-c}}\label{\detokenize{compiler/pgi:cc-1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}B：源文件中允许C++风格的注释，指的是以//开始到行尾内容为注释。除非指定\sphinxhyphen{}C选项，否则这些注释被去除。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}c8x或\sphinxhyphen{}c89：对C源文件采用C89标准。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}c9x或\sphinxhyphen{}c99：对C源文件采用C99标准。

\end{itemize}


\subsubsection{Fortran语言选项}
\label{\detokenize{compiler/pgi:id11}}\label{\detokenize{compiler/pgi:id12}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}byteswapio或\sphinxhyphen{}Mbyteswapio：对无格式Fortran数据文件在输入输出时从大端（big\sphinxhyphen{}endian）到小端（little\sphinxhyphen{}endian）交换比特，或者相反。此选项可以用于读写Sun或SGI等系统中的无格式的Fortran数据文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}i2：将INTEGER变量按照2比特处理。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}i4：将INTEGER变量按照4比特处理。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}i8：将默认的INTEGER和LOGICAL变量按照4比特处理。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}i8storage：对INTEGER和LOGICAL变量分配8比特。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mallocatable\sphinxstyleemphasis{{[}=95|03{]}}：按照Fortran 95或2003标准分配数组。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mbackslash和\sphinxhyphen{}Mnobackslash：将反斜线()当作正常字符（非转义符）处理，默认为\sphinxhyphen{}Mnobackslash。\sphinxhyphen{}Mnobackslash导致标准的C反斜线转义序列在引号包含的字串中重新解析。\sphinxhyphen{}Mbackslash则导致反斜线被认为和其它字符一样。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mextend：设置源代码的行宽为132列。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mfixed、\sphinxhyphen{}Mnofree和\sphinxhyphen{}Mnofreeform：强制对源文件按照固定格式进行语法分析，默认.f或.F文件被认为固定格式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mfree和\sphinxhyphen{}Mfreeform：强制对源文件按照自由格式进行语法分析，默认.f90、.F90、.f95或.F95文件被认为自由格式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mi4和\sphinxhyphen{}Mnoi4：将INTEGER看作INTEGER*4。\sphinxhyphen{}Mnoi4将INTEGER看作INTEGER*2。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mnomain：当链接时，不包含调用Fortran主程序的对象文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mr8和\sphinxhyphen{}Mnor8：将REAL看作DOUBLE PRECISION，将实(REAL)常数看作双精度(DOUBLE PRECISION)常数。默认为否。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mr8intrinsics \sphinxstyleemphasis{{[}=float{]}}和\sphinxhyphen{}Mnor8intrinsics：将CMPLX看作DCMPLX，将REAL看作DBLE。添加float选项时，将FLOAT看作DBLE。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Msave和\sphinxhyphen{}Mnosave：是否将所有局部变量添加SAVE声明，默认为否。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mupcase和\sphinxhyphen{}Mnoupcase：是否保留名字的大小写。\sphinxhyphen{}Mnoupcase导致所有名字转换成小写。注意，如果使用\sphinxhyphen{}Mupcase，那么变量名X与变量名x不同，并且关键字必须为小写。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Mcray\sphinxstyleemphasis{=pointer}：支持Cray指针扩展。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}module \sphinxstyleemphasis{directory}：指定编译时保存生成的模块文件的目录。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}r4：将DOUBLE PRECISION变量看作REAL。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}r8：将REAL变量看作DOUBLE PRECISION。

\end{itemize}


\subsubsection{平台相关选项}
\label{\detokenize{compiler/pgi:id13}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Kieee和\sphinxhyphen{}Knoieee：浮点操作是否严格按照IEEE
754标准。使用\sphinxhyphen{}Kieee时一些优化处理将被禁止，并且使用更精确的数值库。默认为\sphinxhyphen{}Knoieee，将使用更快的但精确性低的方式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Ktrap=\sphinxstyleemphasis{{[}option,{[}option{]}…{]}}：控制异常发生时CPU的操作。选项可为divz、fp、align、denorm、inexact、inv、none、ovf、unf，默认为none。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Msecond\_underscore和\sphinxhyphen{}Mnosecond\_underscore：是否对已有\_的Fortran函数名添加第二个\_。与\sphinxcode{\sphinxupquote{g77}}编译命令兼容时使用，因为\sphinxcode{\sphinxupquote{g77}}默认符号后添加第二个\_ 。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mcmodel\sphinxstyleemphasis{=small:math:`|`medium}：使内存模型是否限制对象小于2GB(small)或允许数据块大于2GB(medium)。medium时暗含\sphinxhyphen{}Mlarge\_arrays选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}tp \sphinxstyleemphasis{target}：target可以为haswell等，默认与编译时的平台一致。

\end{itemize}

\sphinxstepscope


\section{GNU C/C++ Fortran编译器}
\label{\detokenize{compiler/gnu:gnu-c-c-fortran}}\label{\detokenize{compiler/gnu::doc}}

\subsection{GNU C/C++ Fortran编译器简介}
\label{\detokenize{compiler/gnu:id1}}
\sphinxAtStartPar
\sphinxhref{http://gcc.gnu.org/}{GNU C/C++ Fortran(GCC)编译器} 为系统自带的编译器，当前自带的版本为4.8.5，还装有9.2.0等。默认为4.8.5版本，用户无需特殊设置即可使用。GNU编译器编译C、C++源程序的命令分别 \sphinxcode{\sphinxupquote{gcc}} 和 \sphinxcode{\sphinxupquote{g++}} ； \sphinxcode{\sphinxupquote{gfortran}} 可以直接编译Fortran 77、90源程序。


\subsection{编译错误}
\label{\detokenize{compiler/gnu:id2}}
\sphinxAtStartPar
C/C++程序编译时错误信息类似：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{netlog}\PYG{o}{.}\PYG{n}{c}\PYG{p}{:} \PYG{n}{In} \PYG{n}{function} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{main}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{n}{netlog}\PYG{o}{.}\PYG{n}{c}\PYG{p}{:}\PYG{l+m+mi}{84}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{:} \PYG{n}{error}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{for}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n}{loop} \PYG{n}{initial} \PYG{n}{declarations} \PYG{n}{are} \PYG{n}{only} \PYG{n}{allowed} \PYG{o+ow}{in} \PYG{n}{C99} \PYG{n}{mode}
\PYG{n}{netlog}\PYG{o}{.}\PYG{n}{c}\PYG{p}{:}\PYG{l+m+mi}{84}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{:} \PYG{n}{note}\PYG{p}{:} \PYG{n}{use} \PYG{n}{option} \PYG{o}{\PYGZhy{}}\PYG{n}{std}\PYG{o}{=}\PYG{n}{c99} \PYG{o+ow}{or} \PYG{o}{\PYGZhy{}}\PYG{n}{std}\PYG{o}{=}\PYG{n}{gnu99} \PYG{n}{to} \PYG{n+nb}{compile} \PYG{n}{your} \PYG{n}{code}
\end{sphinxVerbatim}

\sphinxAtStartPar
编译错误的格式为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
源文件名: 函数中

\item {} 
\sphinxAtStartPar
源文件名:行数:列数:错误类型:具体说明

\item {} 
\sphinxAtStartPar
源文件名:行数:列数:注解:解决办法

\end{itemize}

\sphinxAtStartPar
Fortran程序编译时错误信息类似：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NOlihm}\PYG{o}{.}\PYG{n}{f90}\PYG{p}{:}\PYG{l+m+mf}{146.14}\PYG{p}{:}

  \PYG{n}{n2nd}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{n}{npr}\PYG{o}{=}\PYG{l+m+mi}{0}
           \PYG{l+m+mi}{1}
\PYG{n}{Error}\PYG{p}{:} \PYG{n}{Symbol} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{npr}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n}{at} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{has} \PYG{n}{no} \PYG{n}{IMPLICIT} \PYG{n+nb}{type}
\end{sphinxVerbatim}

\sphinxAtStartPar
编译错误的格式为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
源文件名:行数:列数:

\item {} 
\sphinxAtStartPar
源文件代码

\item {} 
\sphinxAtStartPar
1指示出错位置

\item {} 
\sphinxAtStartPar
错误类型: 具体说明

\end{itemize}


\subsection{GNU C/C++编译器GCC重要编译选项}
\label{\detokenize{compiler/gnu:gnu-c-c-gcc}}
\sphinxAtStartPar
GNU编译器GCC是Linux系统自带的编译器，系统自带的版本为4.8.5，另外还装有9.2.0等，选项非常多，下面仅仅是列出一些针对4.8.5本人认为常用的重要选项，建议仔细看GCC相关资料。

\sphinxAtStartPar
建议仔细查看编译器手册中关于程序优化的部分，多加测试，选择适合自己程序的编译选项以提高性能。


\subsubsection{控制文件类型的选项}
\label{\detokenize{compiler/gnu:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}x language：明确指定而非让编译器判断输入文件的类型。language可为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
c、c\sphinxhyphen{}header、c\sphinxhyphen{}cpp\sphinxhyphen{}output

\item {} 
\sphinxAtStartPar
c++、c++\sphinxhyphen{}header、c++\sphinxhyphen{}cpp\sphinxhyphen{}output

\item {} 
\sphinxAtStartPar
objective\sphinxhyphen{}c、objective\sphinxhyphen{}c\sphinxhyphen{}header、objective\sphinxhyphen{}c\sphinxhyphen{}cpp\sphinxhyphen{}output

\item {} 
\sphinxAtStartPar
objective\sphinxhyphen{}c++、objective\sphinxhyphen{}c++\sphinxhyphen{}header、objective\sphinxhyphen{}c++\sphinxhyphen{}cpp\sphinxhyphen{}output

\item {} 
\sphinxAtStartPar
assembler、assembler\sphinxhyphen{}with\sphinxhyphen{}cpp

\item {} 
\sphinxAtStartPar
ada

\item {} 
\sphinxAtStartPar
f95、f95\sphinxhyphen{}cpp\sphinxhyphen{}input

\item {} 
\sphinxAtStartPar
java

\item {} 
\sphinxAtStartPar
treelang

\end{itemize}

\sphinxAtStartPar
当language为none时，禁止任何明确指定的类型，其类型由文件名后缀设定。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}c：仅编译成对象文件（.o文件），并不进行链接。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}o file：指定生成的文件名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}v：详细模式，显示在每个命令执行前显示其命令行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\#\#\#：显示编译器、汇编器、链接器的调用信息但并不进行实际编译，在脚本中可以用于捕获驱动器生成的命令行。

\item {} 
\sphinxAtStartPar
–help：显示帮助信息。

\item {} 
\sphinxAtStartPar
–target\sphinxhyphen{}help：显示目标平台的帮助信息。

\item {} 
\sphinxAtStartPar
–version：显示编译器版本信息。

\end{itemize}


\subsubsection{C/C++语言选项}
\label{\detokenize{compiler/gnu:c-c}}\label{\detokenize{compiler/gnu:cc-2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ansi：C模式时，支持所有ISO C90指令。在C++模式时，去除与ISO
C++冲突的GNU扩展。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}std\sphinxstyleemphasis{=val}：控制语言标准，可以为c89、iso9899:1990、iso9899:199409、c99、c9x、iso9899:1999、iso9899:199x、gnu89、gnu99、gnu9x、c++98、gnu++98。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}B：在源文件中允许C++风格的注释，指的是以//开始到行尾内容为注释。除非指定\sphinxhyphen{}C选项，否则这些注释被去除。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}c8x或\sphinxhyphen{}c89：对C源文件采用C89标准。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}c9x或\sphinxhyphen{}c99：对C源文件采用C99标准。

\end{itemize}


\subsubsection{Fortran语言选项}
\label{\detokenize{compiler/gnu:fortran}}\label{\detokenize{compiler/gnu:fortran-2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fconvert\sphinxstyleemphasis{=conversion}：指定对无格式Fortran数据文件表示方式，其值可以为：native，默认值；swap，在输入输出时从大端（big\sphinxhyphen{}endian）到小端（little\sphinxhyphen{}endian）交换比特，或者相反；big\sphinxhyphen{}endian，用大端方式读写；little\sphinxhyphen{}endian，用小端方式读写。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ff2c：与\sphinxcode{\sphinxupquote{g77}}和\sphinxcode{\sphinxupquote{f2c}}命令生成的代码兼容。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ffree\sphinxhyphen{}form和\sphinxhyphen{}ffixed\sphinxhyphen{}form：声明源文件是自由格式还是固定格式，默认从Fortran
90起的源文件为自由格式，之前的Fortran 77等的源文件为固定格式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fdefault\sphinxhyphen{}double\sphinxhyphen{}8：设置DOUBLE PRECISION类型为8比特。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fdefault\sphinxhyphen{}integer\sphinxhyphen{}8：设置INTEGER和LOGICAL类型为8比特。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fdefault\sphinxhyphen{}real\sphinxhyphen{}8：设置REAL类型为8比特。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fno\sphinxhyphen{}backslash：将反斜线()当作正常字符（非转义符）处理。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fno\sphinxhyphen{}underscoring：不在名字后添加\_。注意：\sphinxcode{\sphinxupquote{gfortran}}默认行为与\sphinxcode{\sphinxupquote{g77}}和\sphinxcode{\sphinxupquote{f2c}}不兼容，为了兼容需要加\sphinxhyphen{}ff2c选项。除非使用者了解与现有系统环境的集成，否则不建议使用\sphinxhyphen{}fno\sphinxhyphen{}underscoring选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ffixed\sphinxhyphen{}line\sphinxhyphen{}length\sphinxhyphen{}\sphinxstyleemphasis{n}：设置固定格式源代码的行宽为n。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ffree\sphinxhyphen{}line\sphinxhyphen{}length\sphinxhyphen{}\sphinxstyleemphasis{n}：设置自由格式源代码的行宽为n。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fimplicit\sphinxhyphen{}none：禁止变量的隐式声明，所有变量都需要显式声明。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fmax\sphinxhyphen{}identifier\sphinxhyphen{}length=\sphinxstyleemphasis{n}：设置名称的最大字符长度为n，Fortran 95和200x的长度分别为31和65。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fno\sphinxhyphen{}automatic：将每个程序单元的本地变量和数组声明具有SAVE属性。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fcray\sphinxhyphen{}pointer：支持Cray指针扩展。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fopenmp：编译OpenMP并行程序。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}M\sphinxstyleemphasis{dir}和\sphinxhyphen{}J\sphinxstyleemphasis{dir}：指定编译时保存生成的模块文件目录。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fsecond\sphinxhyphen{}underscore：默认\sphinxcode{\sphinxupquote{gfortran}}对外部函数名添加一个\_，如果使用此选项，那么将添加两个\_。此选项当使用\sphinxhyphen{}fno\sphinxhyphen{}underscoring选项时无效。此选项当使用\sphinxhyphen{}ff2c时默认启用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}std\sphinxstyleemphasis{=val}：指明Fortran标准，val可以为f95、f2003、legacy。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}funderscoring：对外部函数名没有\_的加\_，以与一些Fortran编译器兼容。

\end{itemize}


\subsubsection{警告选项}
\label{\detokenize{compiler/gnu:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fsyntax\sphinxhyphen{}only：仅仅检查代码的语法错误，并不进行其它操作。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}w：编译时不显示任何警告，只显示错误。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Wfatal\sphinxhyphen{}errors：遇到第一个错误就停止，而不尝试继续运行显示更多错误信息。

\end{itemize}


\subsubsection{调试选项}
\label{\detokenize{compiler/gnu:id5}}\label{\detokenize{compiler/gnu:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}g：包含调试信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ggdb：包含利用gbd调试时所需要的信息。

\end{itemize}


\subsubsection{优化选项}
\label{\detokenize{compiler/gnu:id7}}\label{\detokenize{compiler/gnu:id8}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}O\sphinxstyleemphasis{{[}level{]}}：设置优化级别。优化级别level可以设置为0、1、2、3、s。

\end{itemize}


\subsubsection{预处理选项}
\label{\detokenize{compiler/gnu:id9}}\label{\detokenize{compiler/gnu:id10}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}C：预处理时保留C源文件中的注释。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}D \sphinxstyleemphasis{name}：预处理时定义宏name的值为1。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}D \sphinxstyleemphasis{name=def}：预处理时定义name为def。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}U \sphinxstyleemphasis{name}：预处理时去除的任何name初始定义。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}undef：不预定义系统或GCC声明的宏，但标准预定义的宏仍旧被定义。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dD：显示源文件中定义的宏及其值到标准输出。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dI：显示预处理中包含的所有文件，包括文件名和定义时的行号信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dM：显示预处理时源文件中定义的宏及其值，包括定义时文件名和行号。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dN：与\sphinxhyphen{}dD类似，但只显示源文件中定义的宏，而不显示宏值。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}E：预处理各.c文件，将结果发给标准输出，不进行编译、汇编或链接。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}I\sphinxstyleemphasis{dir}：指明头文件的搜索路径。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}M：打印make的依赖关系到标准输出。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MD：打印make的依赖关系到文件file.d，其中file是编译文件的根名字。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MM：打印make的依赖关系到标准输出，但忽略系统头文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}MMD：打印make的依赖关系到文件file.d，其中file是编译的文件的根名字，但忽略系统头文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}P：预处理每个文件，并保留每个file.c文件预处理后的结果到file.i。

\end{itemize}


\subsubsection{链接选项}
\label{\detokenize{compiler/gnu:id11}}\label{\detokenize{compiler/gnu:id12}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pie：在支持的目标上生成地址无关的可执行文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}s：从可执行文件中去除所有符号表。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}rdynamic：添加所有符号表到动态符号表中。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}static：静态链接所需的库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}shared：生成共享对象文件而不是可执行文件，必须在编译每个对象文件时使用\sphinxhyphen{}fpic选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}shared\sphinxhyphen{}libgcc：使用共享libgcc库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}static\sphinxhyphen{}libgcc：使用静态libgcc库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}u \sphinxstyleemphasis{symbol}：确保符号symbol未定义，强制链接一个库模块来定义它。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}I\sphinxstyleemphasis{dir}：指明头文件的搜索路径。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}l\sphinxstyleemphasis{string}：指明所需链接的库名，如库为libxyz.a，则可用\sphinxhyphen{}lxyz指定。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}L\sphinxstyleemphasis{dir}：指明库的搜索路径。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}B\sphinxstyleemphasis{dir}：设置寻找可执行文件、库、头文件、数据文件等路径。

\end{itemize}


\subsubsection{i386和x86\sphinxhyphen{}64平台相关选项}
\label{\detokenize{compiler/gnu:i386x86-64}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mtune\sphinxstyleemphasis{=cpu\sphinxhyphen{}type}：设置优化针对的CPU类型，可为：generic、core2、opteron、opteron\sphinxhyphen{}sse3、bdver1、bdver2等，bdver1为针对本系统AMD
Opteron CPU的。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}march\sphinxstyleemphasis{=cpu\sphinxhyphen{}type}：设置指令针对的CPU类型，CPU类型与上行中一样。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mieee\sphinxhyphen{}fp和\sphinxhyphen{}mno\sphinxhyphen{}ieee\sphinxhyphen{}fp：浮点操作是否严格按照IEEE标准。

\end{itemize}


\subsubsection{约定成俗选项}
\label{\detokenize{compiler/gnu:id13}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fpic：生成地址无关的代码以用于共享库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fPIC：如果目标机器支持，将生成地址无关的代码。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fopenmp：编译OpenMP并行程序。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fpie和\sphinxhyphen{}fPIE：与\sphinxhyphen{}fpic和\sphinxhyphen{}fPIC类似，但生成的地址无关代码，只能链接到可执行文件中。

\end{itemize}

\sphinxstepscope


\chapter{GPU异构计算和CUDA程序简介}
\label{\detokenize{gpu-computing/gpu-computing:gpucuda}}\label{\detokenize{gpu-computing/gpu-computing::doc}}\begin{quote}\begin{description}
\sphinxlineitem{Author}
\sphinxAtStartPar
吴超，中国科大超级计算中心

\end{description}\end{quote}


\section{背景}
\label{\detokenize{gpu-computing/gpu-computing:id1}}
\sphinxAtStartPar
近年来，随着人工智能、高性能数据分析和金融分析等计算密集型领域的兴起，传统通用计算已经无法满足对计算性能的需求，异构计算越来越引起学术界和产业界的重视。

\sphinxAtStartPar
异构计算是指采用不同类型的指令集和体系架构的计算单元组成系统的计算方式。相比传统CPU，异构计算可以实现更高的效率和更低的延迟。目前的异构计算引擎主要有图形处理器（GPU，Graphics Processing Unit）、现场可编程门阵列（FPGA，Field Programming Gate Array）、专用集成电路（ASIC）等。

\sphinxAtStartPar
当前的通用CPU设计得已经很复杂，配有几十个核心，运行频率高达几GHz，每个核心有自己的独立缓存。通常CPU已具备一级、二级、三级缓存。而GPU是目前科研领域比较常用的硬件计算工具。GPU的计算核心数通常是CPU的上百倍，运行频率尽管比CPU的低，但是核心数量多，整体性能好。所以，GPU比较适合计算密集型应用，比如视频处理、人工智能等，现在传统的科学计算、工程计算等也开始越来越适合在GPU上运行。相比来说，CPU的缺点就是太通用了，数据读写、计算、逻辑等各种功能都得照顾，反而影响了计算性能。


\section{GPGPU}
\label{\detokenize{gpu-computing/gpu-computing:gpgpu}}
\sphinxAtStartPar
通用图形处理器（GPGPU，General Purpose Graphics Processing Unit）最早由NVIDIA公司的Mark J. Harris于2002年提出。基于图形渲染管线的流水线特征，GPU本质上是一个可同时处理多个计算任务的硬件加速器。由于GPU中包含了大量的计算资源，Mark J. Harris自2002年就开始尝试在GPU上做通用并行计算方面的研究。在此阶段，由于架构及编程平台的限制，研究人员采用将目标计算算法转换为图形运算算法的方式，使用GPU来实现通用并行计算需求。

\sphinxAtStartPar
NVIDIA公司提出Tesla统一渲染架构以及CUDA（Compute Unified Device Architecture，计算统一设备架构）编程模型后，NVIDIA公司的GPU开始了对通用并行计算的全面支持。在CUDA提出近两年之后，开放计算语言标准OpenCL 1.0发布，这标志着利用GPU进行通用并行计算已基本成熟。目前市场上应用甚广的GPU芯片除了完成高质量的图形渲染之外，通用并行计算也已经成为一个主流应用。GPGPU在各个方面得到了不同GPU厂家为GPU通用计算提供的编程模型与平台，如CUDA和OpenCL，这些编程模型在C/C++基础之上做了面向大规模通用并行计算的语法扩展，为程序员提供了更好的、面向GPU的编程接口。

\sphinxAtStartPar
GPGPU通常由成百上千个架构相对简易的基本运算单元组成。在这些基本运算单元中，一般不提供复杂的诸如分支预测、寄存器重命名、乱序执行等处理器设计技术来提高单个处理单元性能，而是采用极简的流水线进行设计。每个基本运算单元可同时执行一至多个线程，并由GPGPU中相应的调度器控制。GPGPU作为一个通用的众核处理器，凭借着丰富的高性能计算资源以及高带宽的数据传输能力在通用计算领域占据了重要的席位。虽然各个GPGPU厂商的芯片架构各不相同，但几乎都是采用众核处理器阵列架构，在一个GPU芯片中包含成百上千个处理核心，以获得更高的计算性能和更大的数据带宽。

\sphinxAtStartPar
GPU中执行的线程对应的程序通常成为内核（kernel），这与操作系统中的内核是完全不同的两个概念。除此之外，GPU中执行的线程与CPU或者操作系统中定义的线程也有所区别，GPU中的线程相对而言更为简单，所包含的内容也更为简洁。在GPU众核架构中，多个处理核心通常被组织成一个线程组调度执行单位，线程以组的方式被调度在执行单元中执行，如NVIDIA的流多处理器、AMD的SIMD执行单元。同一个线程组中的线程执行相同的程序指令，并以同步的方式执行，每个线程处理不同的数据，实现数据级并行处理。不同GPU架构对线程组的命名各不一样，如NVIDIA将线程组称为warp，AMD将线程组称为wavefront。线程组中包含的线程数量各不相同，从4个到128个不等。除此以为，线程组的组织执行模式也各不相同，常见的执行模式有SIMT（Single Instruction Multiple Threads，单指令多线程）执行模式和SIMD（Single Instruction Multiple Data，单指令流多数据流）执行模式两种。

\sphinxAtStartPar
在一个GPU程序中，避免不了对数据的加载和存储，同时也避免不了条件分支跳转指令。这两类指令通常会引起程序以不可预测的情况执行。对于前者，在第一级高速缓存命中缺失的情况下，指令的执行周期将不可预测。为了避免执行单元因为数据加载或者存储原因而造成运算资源的浪费，GPU的每个执行单元通常设置线程组缓冲区，以支持同时执行多个线程组。线程组之间的调度由线程组硬件调度器承担，与软件调度器不同的是，硬件调度过程一般为零负载调度。在执行单元中，即将执行的线程组首先被调度到缓冲区中，以队列的方式组织，当线程组被调度执行时，调度器从线程组队列中选择一个准备好的线程组启动执行。采用这种线程调度执行方式，可有效解决指令之间由于长延时操作所引起的停顿问题，更高效的应用执行单元中的计算资源。对于后者，在线程级并行执行过程中，条件分支指令的执行特点决定了程序执行的实际效率。无论是SIMD执行模式或是SIMT执行模式，当一组线程均执行相同的代码路径时可获得最佳性能。若一组线程中的每个线程各自执行不同的代码路径，为了确保所有线程执行的正确性，线程组中的多线程指令发送单元将串行地发送所有的指令代码，代码的执行效率将受到严重的影响。GPU架构采用各种控制方法来提高条件分支指令的执行效率。

\sphinxAtStartPar
背景知识大部分内容引自 %
\begin{footnote}[1]\sphinxAtStartFootnote
陈国良, 吴俊敏. 并行计算机体系结构（第2版）{[}M{]}. 北京: 高等教育出版社, 2021.
%
\end{footnote}。


\section{GPU异构计算}
\label{\detokenize{gpu-computing/gpu-computing:gpu}}
\sphinxAtStartPar
CPU\sphinxhyphen{}GPU协同是实现高性能计算的必要条件，称为CPU\sphinxhyphen{}GPU异构计算（HC，Heterogeneous Computing）。它通过将应用程序的计算密集型部分卸载到GPU来提供更高的性能，而其余代码仍然在CPU上运行，能智能地结合CPU和GPU的最佳特性以实现高计算增益，旨在将每个应用程序的需求与CPU/GPU架构的优势相匹配，并避免两个处理单元的空闲时间。需要新的优化技术来充分发挥HC的潜力并朝着百亿级性能的目标迈进。

\sphinxAtStartPar
了解CPU和GPU之间差异的一种简单方法是比较它们处理任务的方式。CPU由几个针对顺序串行处理优化的内核组成，而GPU具有大规模并行架构，由数千个更小、更高效的内核组成，旨在同时处理多个任务。

\sphinxAtStartPar
在GPU上解决计算问题原则上类似于使用多个CPU解决问题。手头的任务必须拆分为小任务，其中每个任务由单个GPU内核执行。GPU内核之间的通信由GPU芯片上的内部寄存器和内存处理。CUDA或OpenCL等特殊编程语言不是使用消息传递进行编程，而是提供主机CPU之间的数据交换和同步GPU内核的机制。

\sphinxAtStartPar
一个现代超级计算系统实际上可能由大量节点组成，每个节点包含2到32颗常规CPU以及1到16个GPU。通常还会有一个高速网络和一个数据存储系统。该系统的软件可以使用传统编程语言（如C/C++、Fortran等）的组合编写，结合用于CPU并行化的消息传递系统以及用于GPU的CUDA或OpenCL。所有这些组件都必须进行调整和优化，以实现整个系统的最佳性能。


\section{CUDA编程框架}
\label{\detokenize{gpu-computing/gpu-computing:cuda}}
\sphinxAtStartPar
CUDA是由NVIDIA公司推行的一套并行编程框架，目前只有NVIDIA的GPU支持该框架，其开发语言主要为CUDA C。作为一种GPU的并行开发语言，CUDA的API涉及设备管理、存储管理、数据传输、线程管理、事件管理等功能。

\sphinxAtStartPar
CUDA的存储模型主要分为全局存储（global memory）、局部存储（local memory）、共享存储（shared memory）、常量存储（constant memory）和纹理存储（texture memory）等存储类型。不同的存储类型，其存储容量、可见程度、读写速度差异巨大，需要在程序设计中根据各自特点和应用问题的需求合理调配。

\sphinxAtStartPar
CUDA的编程模型和执行模型按照层次结构分层设计。CUDA的执行模型由3个层级组成，最基础的执行单位是线程（thread），多个线程组成一个线程块（block），多个线程块形成线程网格（grid）。

\sphinxAtStartPar
CUDA编程模型作为一个异构模型，其中使用了CPU和GPU。在CUDA中，主机（host）指的是CPU及其存储器，设备（device）是指GPU及其存储器。在主机上运行的代码可以管理主机和设备上的内存，还可以启动在设备上执行的内核函数（kernel）。这些内核由许多GPU线程并行执行。

\sphinxAtStartPar
鉴于CUDA编程模型的异构性， CUDA C程序的典型操作序列是：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
声明并分配主机和设备内存。

\item {} 
\sphinxAtStartPar
初始化主机数据。

\item {} 
\sphinxAtStartPar
将数据从主机传输到设备。

\item {} 
\sphinxAtStartPar
执行一个或多个内核。

\item {} 
\sphinxAtStartPar
将结果从设备传输到主机。

\end{enumerate}

\sphinxAtStartPar
对于更多的CUDA编程细节可以在NVIDIA官网CUDA开发者页面 %
\begin{footnote}[2]\sphinxAtStartFootnote
cuda\sphinxhyphen{}toolkit
网址：\sphinxurl{https://developer.nvidia.com/cuda-toolkit}
%
\end{footnote} 找到详细的资料，读者可以自行查阅。


\section{NVCC编译引擎}
\label{\detokenize{gpu-computing/gpu-computing:nvcc}}
\sphinxAtStartPar
CUDA应用程序的源代码由传统的C++主机代码和GPU设备函数混合组成。CUDA编译过程将设备函数与主机代码分开，使用专有的NVIDIA编译器和汇编器编译设备函数，使用可用的C++主机编译器编译主机代码，之后将编译过的GPU函数嵌入到主机对象（object）文件。在链接阶段，向最终生成的可运行二进制文件添加特定的CUDA运行时库函数，如支持远程SPMD过程调用的运行时库函数、显式GPU操作的运行时库函数（如分配GPU内存缓冲区，主机与设备之间的数据传输等）。

\sphinxAtStartPar
编译过程涉及每个CUDA源文件的拆分、编译、预处理和合并步骤。为了将上述复杂的编译过程向开发人员隐藏，NVIDIA公司设计了CUDA编译器引擎程序nvcc。nvcc接受一系列常规编译器选项，例如宏定义和头文件、函数库路径设置，支持编译过程的组合。所有非CUDA编译步骤都被转发到nvcc支持的主机C++编译器，编译选项到主机C++编译选项的转换也由nvcc自动完成。


\subsection{nvcc预定义宏}
\label{\detokenize{gpu-computing/gpu-computing:id4}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
预定义宏
&\sphinxstyletheadfamily 
\sphinxAtStartPar
含义
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\_\_NVCC\_\_
&
\sphinxAtStartPar
编译C/C++/CUDA源文件时预定义
\\
\sphinxhline
\sphinxAtStartPar
\_\_CUDACC\_\_
&
\sphinxAtStartPar
编译CUDA源文件时预定义
\\
\sphinxhline
\sphinxAtStartPar
\_\_CUDACC\_VER\_MAJOR\_\_
&
\sphinxAtStartPar
NVCC主版本号
\\
\sphinxhline
\sphinxAtStartPar
\_\_CUDACC\_VER\_MINOR\_\_
&
\sphinxAtStartPar
NVCC次版本号
\\
\sphinxhline
\sphinxAtStartPar
\_\_CUDACC\_VER\_BUILD\_\_
&
\sphinxAtStartPar
NVCC编译版本号
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{支持的输入文件后缀}
\label{\detokenize{gpu-computing/gpu-computing:id5}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
输入文件后缀
&\sphinxstyletheadfamily 
\sphinxAtStartPar
描述
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
.cu
&
\sphinxAtStartPar
CUDA源文件，包含主机代码和设备函数
\\
\sphinxhline
\sphinxAtStartPar
.c
&
\sphinxAtStartPar
C源文件
\\
\sphinxhline
\sphinxAtStartPar
.cc, .cxx, .cpp
&
\sphinxAtStartPar
C++源文件
\\
\sphinxhline
\sphinxAtStartPar
.o, .obj
&
\sphinxAtStartPar
目标文件（object file）
\\
\sphinxhline
\sphinxAtStartPar
.a, .lib
&
\sphinxAtStartPar
库文件（library file）
\\
\sphinxhline
\sphinxAtStartPar
.res
&
\sphinxAtStartPar
资源文件（resource file）
\\
\sphinxhline
\sphinxAtStartPar
.so
&
\sphinxAtStartPar
共享目标文件（shared object file）
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{常用编译选项}
\label{\detokenize{gpu-computing/gpu-computing:id6}}
\sphinxAtStartPar
1.文件和路径配置


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
选项
&\sphinxstyletheadfamily 
\sphinxAtStartPar
描述
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxhyphen{}o file
&
\sphinxAtStartPar
配置输出文件名和路径
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}l library,…
&
\sphinxAtStartPar
配置链接阶段链接的库文件
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}D def,…
&
\sphinxAtStartPar
定义预处理阶段使用的宏
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}U def,…
&
\sphinxAtStartPar
取消宏定义
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}I path,…
&
\sphinxAtStartPar
配置头文件搜索路径
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}L path,…
&
\sphinxAtStartPar
配置库文件搜索路径
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}cudart \{none|shared|static\}
&
\sphinxAtStartPar
配置CUDA运行时库的类型，默认使用静态（static）
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}cudadevrt \{none|static\}
&
\sphinxAtStartPar
配置CUDA设备运行时库的类型，默认使用静态（static）
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
编译器/链接器选项

\end{enumerate}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
选项
&\sphinxstyletheadfamily 
\sphinxAtStartPar
描述
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxhyphen{}pg
&
\sphinxAtStartPar
生成供gprof使用的可执行代码
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}g
&
\sphinxAtStartPar
编译带调试信息的主机代码
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}G
&
\sphinxAtStartPar
编译带调试信息的设备代码
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}O level
&
\sphinxAtStartPar
指定主机代码的优化级别
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}dopt kind
&
\sphinxAtStartPar
允许设备端代码优化。当不指定\sphinxhyphen{}G选项时，设备端代码优化是默认的行为
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}shared
&
\sphinxAtStartPar
生成共享库
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}x \{c|c++|cu\}
&
\sphinxAtStartPar
显式指定待编译的输入文件的编程语言，而不是由编译器根据文件后缀自动判断
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}std \{c++03|c++11|c++14|c++17\}
&
\sphinxAtStartPar
指定c++标准的版本
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
特定阶段编译选项

\end{enumerate}

\sphinxAtStartPar
下表列举了可以直接传递给nvcc封装的内部编译工具的编译选项。通过这些选项的应用，nvcc不需要具备对内部编译工具的过多细节的了解。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
选项
&\sphinxstyletheadfamily 
\sphinxAtStartPar
描述
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxhyphen{}Xcompiler options,…
&
\sphinxAtStartPar
指定直接传递给编译器/预处理器的编译选项
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}Xlinker options,…
&
\sphinxAtStartPar
指定直接传递给链接器的编译选项
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}Xarchive options,…
&
\sphinxAtStartPar
指定直接传递给库管理器的编译选项
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}Xptxas options,…
&
\sphinxAtStartPar
指定直接传递给ptxas（PTX优化汇编器）的编译选项
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}Xnvlink options,…
&
\sphinxAtStartPar
指定直接传递给nvlink（设备链接器）的编译选项
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
GPU代码生成选项

\end{enumerate}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
选项
&\sphinxstyletheadfamily 
\sphinxAtStartPar
描述
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxhyphen{}arch \{arch|native|all|allmajor\}
&
\sphinxAtStartPar
指定编译阶段使用的虚拟GPU类型
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}code code,…
&
\sphinxAtStartPar
指定汇编优化使用的具体GPU类型
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}use\_fast\_math
&
\sphinxAtStartPar
使用快速数学计算库
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
为了实现架构演进，NVIDIA的GPU以不同的世代（generation）发布。新一代产品在功能和/或芯片架构方面进行重大改进，同时同一代产品中的GPU型号仅在配置方面存在次要差别，对功能、性能的影响适中。不同代的GPU其应用程序的二进制兼容性是没有保证的。例如，为Fermi GPU编译的CUDA应用程序很可能无法在Kepler GPU上运行（反之亦然）。这是因为每一代的指令集和指令编码与其他世代的指令编码都不相同。同一代的GPU由于共享相同的指令集，在满足特定条件下其二进制兼容性可以得到保证。特定条件通常是指两个没有功能差异的GPU版本之间的情况（例如，当一个版本是另一个版本的缩减版），或者当一个版本在功能上完全包含在另一个版本中。后者的一个例子是基础Maxwell版本sm\_52，其功能是所有其他Maxwell版本的一个子集：任何为sm\_52编译的代码将可以在所有Maxwell GPU上运行。

\sphinxAtStartPar
nvcc编译命令总是使用两个架构：一个虚拟的中间架构，加上一个真实的GPU架构（指定代码将运行的平台）。要使nvcc命令有效，真实架构必须是虚拟架构的实现。

\sphinxAtStartPar
虚拟GPU完全由提供给应用程序的能力和特征定义。虚拟架构提供了一个通用的指令集合，并且不涉及二进制编码格式。虚拟架构列表如下：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
虚拟架构（\sphinxhyphen{}arch参数）
&\sphinxstyletheadfamily 
\sphinxAtStartPar
特征描述
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\begin{DUlineblock}{0em}
\item[] compute\_35
\item[] compute\_37
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] Kepler架构支持
\item[] 统一内存编程
\item[] 支持动态并行
\end{DUlineblock}
\\
\sphinxhline
\begin{DUlineblock}{0em}
\item[] compute\_50
\item[] compute\_52
\item[] compute\_53
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] 
\item[] +Maxwell架构支持
\item[] 
\end{DUlineblock}
\\
\sphinxhline
\begin{DUlineblock}{0em}
\item[] compute\_60
\item[] compute\_61
\item[] compute\_62
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] 
\item[] +Pascal架构支持
\item[] 
\end{DUlineblock}
\\
\sphinxhline
\begin{DUlineblock}{0em}
\item[] compute\_70
\item[] compute\_72
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] +Volta架构支持
\item[] 
\end{DUlineblock}
\\
\sphinxhline
\begin{DUlineblock}{0em}
\item[] compute\_75
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] +Turing架构支持
\end{DUlineblock}
\\
\sphinxhline
\begin{DUlineblock}{0em}
\item[] compute\_80
\item[] compute\_86
\item[] compute\_87
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] 
\item[] +Ampere架构支持
\item[] 
\end{DUlineblock}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
在CUDA的命名方案中，GPU被命名为sm\_xy，其中x表示GPU的世代编号，y表示该世代的版本。为了便于比较GPU的能力，执行特定的命名设计规则，如果x1y1 <= x2y2，那么sm\_x1y1的所有非ISA相关能力都包括在sm\_x2y2中。由此可见，sm\_52确实是基础麦克斯韦模型，这也解释了为什么表格中的高条目总是对低条目的功能扩展（表格中用加号表示）。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
真实架构（\sphinxhyphen{}code参数）
&\sphinxstyletheadfamily 
\sphinxAtStartPar
特征描述
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\begin{DUlineblock}{0em}
\item[] sm\_35
\item[] sm\_37
\item[] 
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] Kepler架构支持
\item[] 统一内存编程
\item[] 支持动态并行
\end{DUlineblock}
\\
\sphinxhline
\begin{DUlineblock}{0em}
\item[] sm\_50
\item[] sm\_52
\item[] sm\_53
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] 
\item[] +Maxwell架构支持
\item[] 
\end{DUlineblock}
\\
\sphinxhline
\begin{DUlineblock}{0em}
\item[] sm\_60
\item[] sm\_61
\item[] sm\_62
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] 
\item[] +Pascal架构支持
\item[] 
\end{DUlineblock}
\\
\sphinxhline
\begin{DUlineblock}{0em}
\item[] sm\_70
\item[] sm\_72
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] +Volta架构支持
\item[] 
\end{DUlineblock}
\\
\sphinxhline
\begin{DUlineblock}{0em}
\item[] sm\_75
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] +Turing架构支持
\end{DUlineblock}
\\
\sphinxhline
\begin{DUlineblock}{0em}
\item[] sm\_80
\item[] sm\_86
\item[] sm\_87
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] 
\item[] +Ampere架构支持
\item[] 
\end{DUlineblock}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
本节介绍了CUDA的nvcc编译引擎，并列举了nvcc一些基础和常用的编译选项。关于nvcc完整的介绍请参考官方指南NVIDIA CUDA Compiler Driver NVCC %
\begin{footnote}[3]\sphinxAtStartFootnote
NVIDIA CUDA Compiler Driver NVCC
网址：\sphinxurl{https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html}
%
\end{footnote}。


\section{一个简单的例子}
\label{\detokenize{gpu-computing/gpu-computing:id8}}

\subsection{代码示例}
\label{\detokenize{gpu-computing/gpu-computing:id9}}
\sphinxAtStartPar
下面介绍一个简单的CUDA C程序例子，演示如何在瀚海22上编译运行CUDA代码。

\sphinxAtStartPar
例子展示的是两个向量相加的CUDA代码 \sphinxcode{\sphinxupquote{add.cu}} 。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}cuda\PYGZus{}runtime.h\PYGZgt{}}

\PYG{n}{\PYGZus{}\PYGZus{}global\PYGZus{}\PYGZus{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{add}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{float}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{float}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{float}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{z}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{blockIdx}\PYG{p}{.}\PYG{n}{x}\PYG{o}{*}\PYG{n}{blockDim}\PYG{p}{.}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{threadIdx}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{float}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{z}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{d\PYGZus{}x}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{d\PYGZus{}y}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{d\PYGZus{}z}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{n}{cudaMalloc}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{d\PYGZus{}x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{cudaMalloc}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{d\PYGZus{}y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{cudaMalloc}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{d\PYGZus{}z}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{n}{RAND\PYGZus{}MAX}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{n}{RAND\PYGZus{}MAX}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}

\PYG{+w}{  }\PYG{n}{cudaMemcpy}\PYG{p}{(}\PYG{n}{d\PYGZus{}x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{cudaMemcpyHostToDevice}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{cudaMemcpy}\PYG{p}{(}\PYG{n}{d\PYGZus{}y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{cudaMemcpyHostToDevice}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{n}{add}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{N}\PYG{o}{+}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{256}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{256}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d\PYGZus{}x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d\PYGZus{}y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d\PYGZus{}z}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{n}{cudaMemcpy}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d\PYGZus{}z}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{cudaMemcpyDeviceToHost}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{k+kt}{float}\PYG{+w}{ }\PYG{n}{maxError}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0f}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{+w}{        }\PYG{n}{maxError}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxError}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{fabs}\PYG{p}{(}\PYG{n}{z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Max error: \PYGZpc{}f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{maxError}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{n}{cudaFree}\PYG{p}{(}\PYG{n}{d\PYGZus{}x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{cudaFree}\PYG{p}{(}\PYG{n}{d\PYGZus{}y}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{cudaFree}\PYG{p}{(}\PYG{n}{d\PYGZus{}z}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{free}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{free}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{free}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
函数 \sphinxcode{\sphinxupquote{add}} 是在GPU上并行运行的内核， \sphinxcode{\sphinxupquote{main}} 函数是宿主代码。


\subsection{程序解读}
\label{\detokenize{gpu-computing/gpu-computing:id10}}
\sphinxAtStartPar
main函数声明3个数组。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{float}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{z}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{d\PYGZus{}x}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{d\PYGZus{}y}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{d\PYGZus{}z}\PYG{p}{;}
\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{float}\PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{cudaMalloc}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{d\PYGZus{}x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cudaMalloc}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{d\PYGZus{}y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cudaMalloc}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{d\PYGZus{}z}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
指针x、y和z分别指向使用 \sphinxstylestrong{malloc} 分配的主机内存空间，d\_x、d\_y和d\_z指针分别指向使用CUDA运行时API \sphinxstylestrong{cudaMalloc} 函数分配的设备存储空间。
CUDA中的主机和设备有独立的内存空间，这两个空间都可以从主机代码进行管理。

\sphinxAtStartPar
为了初始化设备数组，使用 \sphinxstylestrong{cudaMemcpy} 将数据从x和y复制到相应的设备数组d\_x和d\_y，它的工作方式与标准的C \sphinxstylestrong{memcpy} 函数一样，只是增加了第四个参数，指定拷贝的方向。
在这里，我们使用 \sphinxstyleemphasis{cudaMemcpyHostToDevice} 指定第一个（目标）参数是设备指针，第二个（源）参数是主机指针。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cudaMemcpy}\PYG{p}{(}\PYG{n}{d\PYGZus{}x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{cudaMemcpyHostToDevice}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cudaMemcpy}\PYG{p}{(}\PYG{n}{d\PYGZus{}y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{cudaMemcpyHostToDevice}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
add内核由以下语句启动：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{N}\PYG{o}{+}\PYG{l+m+mi}{256}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{256}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{256}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d\PYGZus{}x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d\PYGZus{}y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d\PYGZus{}z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{<<<} 和 \sphinxstylestrong{>>>} 符号之间的信息是执行配置，指示有多少设备线程并行执行内核。在CUDA中，软件中有一个线程层次结构，它模仿线程处理器在GPU上的分组方式。执行配置中的第一个参数指定网格中线程块的数量，第二个参数指定线程块中的线程数。线程块和网格可以通过为这些参数传递dim3（一个由CUDA用x、y和z成员定义的简单结构）值来生成一维、二维或三维的线程块和网格。对于add这个示例，只需要一维线程组，所以我们只传递整数。在本例中，我们使用包含256个线程的线程块启动内核，并使用“上整计算”来确定处理数组全部N个元素所需的线程块数（(N+256\sphinxhyphen{}1)/256）。

\sphinxAtStartPar
由于数组的元素数有不能被线程块大小整除的可能，内核代码必须检查内存访问是否越界。

\sphinxAtStartPar
在运行内核之后，使用 \sphinxstylestrong{cudaMemcpy} （拷贝方向： \sphinxstyleemphasis{cudaMemcpyDeviceToHost} ），从d\_z指向的设备数组复制到z指向的主机数组，将结果返回给主机。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cudaMemcpy}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d\PYGZus{}z}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{N}\PYG{o}{*}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{cudaMemcpyDeviceToHost}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
程序的最后，使用 \sphinxstylestrong{cudaFree()} 和 \sphinxstylestrong{free()} 分别清理设备端和主机端申请的内存。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cudaFree}\PYG{p}{(}\PYG{n}{d\PYGZus{}x}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cudaFree}\PYG{p}{(}\PYG{n}{d\PYGZus{}y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cudaFree}\PYG{p}{(}\PYG{n}{d\PYGZus{}z}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{free}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{free}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{free}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{编译运行}
\label{\detokenize{gpu-computing/gpu-computing:id11}}
\sphinxAtStartPar
接下来以瀚海22超级计算系统使用Slurm作业调度系统的交互式任务为例，演示CUDA程序在超算系统上编译运行的一般方法。
\begin{itemize}
\item {} 
\sphinxAtStartPar
首先在 \sphinxstylestrong{登录节点} ，利用 \sphinxstylestrong{module} 命令载入合适的CUDA版本。本例中，在 \sphinxstylestrong{登录节点} 运行命令 \sphinxstylestrong{module avail} 确认系统中已安装的CUDA版本，选择符合自身需求的版本，如cuda/11.7.1\_515.65.01装载（ \sphinxstylestrong{module load cuda/x.x.x} , x.x.x指版本号）：

\end{itemize}

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{hanhai22-module}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
（可选操作）使用 \sphinxstylestrong{nvcc –version} 命令可以查看确认当前环境载入的CUDA版本：

\end{itemize}

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{hanhai22-nvcc}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
接着，使用 \sphinxstylestrong{nvcc} 命令编译CUDA程序，编译选项的含义可参考上节“NVCC编译引擎”：

\end{itemize}

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{hanhai22-build}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
然后，使用 \sphinxstylestrong{salloc} 命令向Slurm系统申请交互式任务。 \sphinxstylestrong{salloc} 命令选项及Slurm系统可参考本手册的“Slurm作业调度系统” %
\begin{footnote}[4]\sphinxAtStartFootnote
Slurm作业调度系统
网址：\sphinxurl{http://scc.ustc.edu.cn/zlsc/user\_doc/html/slurm/index.html}
%
\end{footnote}：

\end{itemize}

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{hanhai22-salloc}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
至此，已完成在 \sphinxstylestrong{登录节点} 的工作（CUDA程序的编译和Slurm交互式任务的提交）。我们转入 \sphinxstylestrong{计算节点} 。

\item {} 
\sphinxAtStartPar
使用SSH命令免密登入 \sphinxstylestrong{计算节点} （计算节点的主机名称由salloc命令的输出确定）。

\end{itemize}

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{hanhai22-ssh_gnode}.png}

\begin{sphinxadmonition}{note}{备注:}
\sphinxAtStartPar
由于瀚海22系统的登录节点和计算节点的 \sphinxstyleemphasis{/home} 目录都挂载共享存储对应目录，所以两者的 \sphinxstyleemphasis{/home} 目录内容相同。
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在 \sphinxstylestrong{计算节点} 使用 \sphinxstylestrong{module load} 载入与登录节点一致的CUDA版本。然后运行已编译好的程序，完成计算。

\end{itemize}

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{hanhai22-cuadd}.png}


\subsection{小结}
\label{\detokenize{gpu-computing/gpu-computing:id13}}
\sphinxAtStartPar
本小节的简单例子用于展示瀚海22超级计算系统上CUDA程序的编译运行（交互式）的一般流程。

\begin{sphinxadmonition}{note}{备注:}
\sphinxAtStartPar
使用 \sphinxstylestrong{salloc} （交互式）提交任务是为了向初学者展示登录节点和计算节点的区别，并不是瀚海22的常规作业调度方式。瀚海22超级计算系统上的正式作业请通过编写计算脚本并以 \sphinxstylestrong{sbatch} 提交的方式实现资源的申请和计算的执行。
\end{sphinxadmonition}

\sphinxAtStartPar
Naive加法计算没有考虑如何充分利用GPU的计算资源和数据带宽。对性能优化感兴趣，希望充分利用GPU的计算资源的读者可以进一步阅读NVIDIA关于CUDA编程的进阶读物 %
\begin{footnote}[5]\sphinxAtStartFootnote
CUDA C++ Programming Guide
网址：\sphinxurl{https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html}
%
\end{footnote}。


\section{One More Thing}
\label{\detokenize{gpu-computing/gpu-computing:one-more-thing}}
\sphinxAtStartPar
瀚海22超级计算系统系统预装了NVIDIA HPC SDK（nvhpc），方便用户充分利用GPU计算资源，实现科学计算应用和性能优化等工作。

\sphinxAtStartPar
NVIDIA HPC SDK是NVIDIA公司提供的一个包含编译器、函数库和软件工具的软件包，包含了用于方便用户开发、增强程序性能和可移植性的一系列工具。NVIDIA HPC SDK C、C++和Fortran编译器支持使用标准C++和Fortran、OpenACC指令和CUDA对HPC建模和模拟应用程序进行GPU加速。GPU加速的数学库使普通HPC算法的性能最大化，优化的通信库使基于标准的多GPU和可扩展系统编程成为可能。性能剖析和调试工具简化了HPC应用程序的移植和优化，而容器化工具则使得在企业内部或在云端的部署变得容易。HPC SDK支持NVIDIA GPU和运行Linux的Arm、OpenPOWER或x86\sphinxhyphen{}64 CPU，为用户提供了构建NVIDIA GPU加速的HPC应用程序所需的工具。


\subsection{编译器}
\label{\detokenize{gpu-computing/gpu-computing:id15}}\begin{itemize}
\item {} 
\sphinxAtStartPar
nvc：nvc是一个用于NVIDIA GPU和AMD、Intel、OpenPOWER和Arm CPU的C语言编译器。nvc支持ISO C11，支持用OpenACC进行GPU编程，并支持用OpenACC和OpenMP进行多核CPU编程。

\item {} 
\sphinxAtStartPar
nvc++：nvc++是一个针对NVIDIA GPU和AMD、Intel、OpenPOWER和Arm CPU的C++语言编译器。它为目标处理器调用C++编译器、汇编器和链接器，选项来自其命令行参数。nvc++支持ISO C++17，支持使用C++17并行算法、OpenACC和OpenMP的GPU和多核CPU编程。

\item {} 
\sphinxAtStartPar
nvfortran：nvfortran是一个用于NVIDIA GPU和AMD、Intel、OpenPOWER和Arm CPU的Fortran编译器。nvfortran支持ISO Fortran 2003/2008的许多特性，支持使用CUDA Fortran进行GPU编程，以及使用ISO Fortran并行语言特性、OpenACC和OpenMP进行GPU和多核CPU编程。

\item {} 
\sphinxAtStartPar
nvcc：nvcc是用于NVIDIA GPU的CUDA C和CUDA C++编译器驱动程序。nvcc接受一系列传统的编译器选项，例如用于定义宏和include/library路径，以及用于引导编译过程。nvcc为NVIDIA GPU生成优化代码，并驱动支持AMD、Intel、OpenPOWER和Arm CPU的主机编译器。

\end{itemize}


\subsection{数学库}
\label{\detokenize{gpu-computing/gpu-computing:id16}}\begin{itemize}
\item {} 
\sphinxAtStartPar
cuBLAS：cuBLAS库提供了基本线性代数子程序（BLAS，Basic Linear Algebra Subprograms）的GPU加速实现。cuBLAS利用针对NVIDIA GPU高度优化的行业标准BLAS API加速AI和HPC应用。cuBLAS库包含用于分批操作、跨多个GPU执行以及混合和低精度执行的扩展。

\item {} 
\sphinxAtStartPar
cuTENSOR：cuTENSOR库是第一个由GPU加速的张量线性代数库，提供张量收缩、还原和元素运算。cuTENSOR用于加速深度学习训练和推理、计算机视觉、量子化学和计算物理等领域的应用。

\item {} 
\sphinxAtStartPar
cuSPARSE：cuSPARSE库为稀疏矩阵提供了GPU加速的基本线性代数子程序，其功能可用于建立GPU加速的求解器。cuSPARSE被从事机器学习、计算流体力学、地震勘探和计算科学等应用的工程师和科学家广泛使用。

\item {} 
\sphinxAtStartPar
cuSOLVER：cuSOLVER库提供了针对NVIDIA GPU高度优化的密集和稀疏因式分解、线性求解器和eigensolvers。cuSOLVER用于加速科学计算和数据科学等不同领域的应用，并拥有针对混合精度张量加速和跨多个GPU执行的扩展。

\item {} 
\sphinxAtStartPar
cuFFT：cuFFT库提供了针对NVIDIA GPU高度优化的快速傅里叶变换（FFT，Fast Fourier Transform）实现。cuFFT被用于建立跨学科的商业和研究应用，如深度学习、计算机视觉、计算物理、分子动力学、量子化学以及地震和医学成像，并具有跨多个GPU执行的扩展。

\item {} 
\sphinxAtStartPar
cuRAND：cuRAND库是一个随机数发生器的GPU设备端实现。

\end{itemize}


\subsection{常用工具}
\label{\detokenize{gpu-computing/gpu-computing:id17}}\begin{itemize}
\item {} 
\sphinxAtStartPar
CUDA\sphinxhyphen{}GDB：用于调试CUDA应用程序的NVIDIA工具软件。

\item {} 
\sphinxAtStartPar
Nsight Compute：NVIDIA Nsight Compute是面向CUDA应用程序的下一代交互式内核分析器。它通过一个用户界面和命令行工具提供详细的性能指标和API调试。

\item {} 
\sphinxAtStartPar
Nsight System：NVIDIA Nsight System是一款全系统性能分析工具，旨在实现应用程序算法的可视化。有助于识别优化和调整机会，以便在CPU和GPU上高效扩展应用程序。

\end{itemize}

\sphinxAtStartPar
NVIDIA HPC SDK高性能计算工具包的完整介绍请参考 %
\begin{footnote}[6]\sphinxAtStartFootnote
NVIDIA HPC SDK
网址：\sphinxurl{https://developer.nvidia.com/hpc-sdk}
%
\end{footnote}。

\sphinxstepscope


\chapter{MPI并行程序编译及运行}
\label{\detokenize{mpi-application/mpi-application:mpi}}\label{\detokenize{mpi-application/mpi-application::doc}}

\section{简介}
\label{\detokenize{mpi-application/mpi-application:id1}}
\sphinxAtStartPar
本系统的通信网络由Mellanox \sphinxhref{https://www.mellanox.com/products/infiniband-switches/QM8700}{QM8700 HDR200交换机}和\sphinxhref{https://www.mellanox.com/products/infiniband-adapters/connectx-6}{ConnectX\sphinxhyphen{}6 HDR100网卡}组成的100Gbps高速计算网络及1Gbps千兆以太网两套网络组成。InfiniBand网络相比千兆以太网具有高带宽、低延迟的特点，通信性能比千兆以太网要高很多，建议使用。

\sphinxAtStartPar
本系统安装有多种MPI实现，主要有：HPC\sphinxhyphen{}X（Mellanox官方推荐）、Intel MPI（不建议使用，特别是2019版）和Open MPI，并可与不同编译器相互配合使用，安装目录分别在 \sphinxcode{\sphinxupquote{/opt/hpcx}} 、 \sphinxcode{\sphinxupquote{/opt/intel}} 和 \sphinxcode{\sphinxupquote{/opt/openmpi}} ，且具有不同版本的组合。

\sphinxAtStartPar
用户可以运行\sphinxcode{\sphinxupquote{module apropos MPI}}或\sphinxcode{\sphinxupquote{module avail}}查看可用MPI环境，可用类似命令设置所需的MPI环境：\sphinxcode{\sphinxupquote{module load hpcx/hpcx\sphinxhyphen{}intel\sphinxhyphen{}2019.update5}}，使用此命令有时需要手动加载对应的编译器等版本，比如报：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{error} \PYG{k}{while} \PYG{n}{loading} \PYG{n}{shared} \PYG{n}{libraries}\PYG{p}{:} \PYG{n}{libimf}\PYG{o}{.}\PYG{n}{so}\PYG{p}{:} \PYG{n}{cannot} \PYG{n+nb}{open} \PYG{n}{shared}
\PYG{n+nb}{object} \PYG{n}{file}\PYG{p}{:} \PYG{n}{No} \PYG{n}{such} \PYG{n}{file} \PYG{o+ow}{or} \PYG{n}{directory}
\end{sphinxVerbatim}

\sphinxAtStartPar
则需要加载对应的Intel编译器，比如\sphinxcode{\sphinxupquote{module load intel/2019.update5}}。

\sphinxAtStartPar
Mellanox HDR是比较新的高速计算网络，老的MPI环境对其支持不好。


\section{MPI并行程序的编译}
\label{\detokenize{mpi-application/mpi-application:id2}}

\subsection{HPC\sphinxhyphen{}X ScalableHPC工具集}
\label{\detokenize{mpi-application/mpi-application:hpc-x-scalablehpc}}
\sphinxAtStartPar
\sphinxhref{https://docs.mellanox.com/pages/viewpage.action?pageId=19798265}{Mellanox HPC\sphinxhyphen{}X ScalableHPC工具集}是综合的软件包，含有MPI及SHMEM/PGAS通讯库。HPC\sphinxhyphen{}X ScalableHPC还包含这些库之上的用于提升性能和扩展性的多种加速包，包括加速点对点通信的UCX(Unified Communication X)、加速MPI/PGAS中集合操作的FCA(Fabric Collectives Accelerations)。这些全特性的、经完备测试的及打包好的工具集使得MPI和SHMEM/PGAS程序获得高性能、扩展性和效率，且保证了在Mellanox互连系统中这些通信库经过了全优化。

\sphinxAtStartPar
Mellanox HPC\sphinxhyphen{}X ScalableHPC工具集利用了基于Mellanox硬件的加速引擎，可以最大化基于MPI和SHMEM/PGAS的应用性能。这些应用引擎是Mellanox网卡（CORE\sphinxhyphen{}Direct引擎，硬件标记匹配(Tag Matching)等）和交换机（如Mellanox SHARP加速引擎）解决方案的一部分。Mellanox可扩展的分层聚合和归约协议(Scalable Hierarchical Aggregation and Reduction Protocol, SHARP)技术通过将集合操作从CPU端卸载到交换机网络端，通过去除在端到端之间发送多次数据的的需要，大幅提升了MPI操作性能。这种创新性科技显著降低了MPI操作时间，释放了重要的CPU资源使其用于计算而不是通信，且降低了到达聚合节点时通过网络的数据量。

\sphinxAtStartPar
HPC\sphinxhyphen{}X主要特性如下：
\begin{itemize}
\item {} 
\sphinxAtStartPar
完整的MPI、PGAS/SHMEM包，且含有Mellanox UCX和FCA加速引擎

\item {} 
\sphinxAtStartPar
兼容MPI 3.2标准

\item {} 
\sphinxAtStartPar
兼容OpenSHMEM 1.4标准

\item {} 
\sphinxAtStartPar
从MPI进程将集合通信从CPU卸载到Mellanox网络硬件上

\item {} 
\sphinxAtStartPar
利用底层硬件体系结构最大化提升应用程序性能

\item {} 
\sphinxAtStartPar
针对Mellanox解决方案进行了全优化

\item {} 
\sphinxAtStartPar
提升应用的可扩展性和资源效率

\item {} 
\sphinxAtStartPar
支持RC、DC和UD等多种传输

\item {} 
\sphinxAtStartPar
节点内共享内存通信

\item {} 
\sphinxAtStartPar
带消息条带的多轨支持

\item {} 
\sphinxAtStartPar
支持GPU\sphinxhyphen{}direct的CUDA

\end{itemize}

\sphinxAtStartPar
HPC\sphinxhyphen{}X环境：
\begin{itemize}
\item {} 
\sphinxAtStartPar
HPC\sphinxhyphen{}X CUDA支持：
\begin{itemize}
\item {} 
\sphinxAtStartPar
HPC\sphinxhyphen{}X默认是对于单线程模式优化的，这支持GPU和无GPU模式。

\item {} 
\sphinxAtStartPar
HPC\sphinxhyphen{}X是基于CUDA 10.1编译的，由于CUDA 10.1不支持比GCC v8新的，因此对于基于v8之后的GCC编译的，不支持CUDA。

\end{itemize}

\item {} 
\sphinxAtStartPar
HPC\sphinxhyphen{}X多线程支持 \sphinxhyphen{} hpcx\sphinxhyphen{}mt：
\begin{itemize}
\item {} 
\sphinxAtStartPar
该选项启用所有多线程支持。

\end{itemize}

\end{itemize}

\sphinxAtStartPar
HPC\sphinxhyphen{}X MPI是Open MPI的一种高性能实现，利用Mellanox加速能力且无缝结合了业界领先的商业和开源应用软件包进行了优化。很多用法可参考，该部分主要介绍其不同的参数设置等。


\subsubsection{Mellanox Fabric集合通信加速(Fabric Collective Accelerator, FCA)}
\label{\detokenize{mpi-application/mpi-application:mellanox-fabric-fabric-collective-accelerator-fca}}
\sphinxAtStartPar
集合通信执行全体工薪操作占用系统中所有进程/节点，因此必须执行越快越高效越好。很多应用里面都含有大量的集合通讯，普通的MPI实现那会占用大量的CPU资源及产生系统噪声。Mellanox将很多类似通信从CPU卸载到Mellanox硬件网卡适配器(HCA)和交换机上及降低噪声，这种技术称之为CORE\sphinxhyphen{}Direct® (Collectives Offload Resource Engine)。

\sphinxAtStartPar
FCA 4.4当前支持阻塞和非阻塞的集合通信：Allgather、Allgatherv、Allreduce、AlltoAll、AlltoAllv、Barrier和Bcast。

\sphinxAtStartPar
\sphinxstylestrong{采用FCA v4.x (hcoll)运行MPI}

\sphinxAtStartPar
HPC\sphinxhyphen{}X默认启用FCA v4.3。
\begin{itemize}
\item {} 
\sphinxAtStartPar
采用默认FCA配置参数运行：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}mca coll\_hcoll\_enable 1 \sphinxhyphen{}x HCOLL\_MAIN\_IB=mlx5\_0:1 <...>}}

\item {} 
\sphinxAtStartPar
采用FCA运行：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{oshrun \sphinxhyphen{}mca scoll\_mpi\_enable 1 \sphinxhyphen{}mca scoll basic,mpi \sphinxhyphen{}mca coll\_hcoll\_enable 1 <...>}}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Open MPI中启用FCA}

\sphinxAtStartPar
在Open MPI中启用FCA v4.4，通过下述方法显式设定模块化组件架构模块化组件架构MCA(Modular Component Architecture)参数：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}np 32 \sphinxhyphen{}mca coll\_hcoll\_enable 1 \sphinxhyphen{}x coll\_hcoll\_np=0 \sphinxhyphen{}x HCOLL\_MAIN\_IB=<device\_name>:<port\_num> ./a.out}}

\sphinxAtStartPar
\sphinxstylestrong{调整FCA v4.4配置}

\sphinxAtStartPar
显示当前信息：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/opt/mellanox/hcoll/bin/hcoll\_info \sphinxhyphen{}\sphinxhyphen{}all}}

\sphinxAtStartPar
FCA v4.4的参数是简单的环境变量，可以通过以下方式之一设置：
\begin{itemize}
\item {} 
\sphinxAtStartPar
通过mpirun命令设置：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun ... \sphinxhyphen{}x HCOLL\_ML\_BUFFER\_SIZE=65536}}

\item {} 
\sphinxAtStartPar
从SHELL设置：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{export HCOLL\_ML\_BUFFER\_SIZE=65536}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun ...}}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{选择端口及设备}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}x HCOLL\_MAIN\_IB=<device\_name>:<port\_num>}}

\sphinxAtStartPar
\sphinxstylestrong{启用卸载MPI非阻塞集合}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}x HCOLL\_ENABLE\_NBC=1}}

\sphinxAtStartPar
支持以下非阻塞MPI集合：
\begin{itemize}
\item {} 
\sphinxAtStartPar
MPI\_Ibarrier

\item {} 
\sphinxAtStartPar
MPI\_Ibcast

\item {} 
\sphinxAtStartPar
MPI\_Iallgather

\item {} 
\sphinxAtStartPar
MPI\_Iallreduce (4b, 8b, SUM, MIN, PROD, AND, OR, LAND, LOR)

\end{itemize}

\sphinxAtStartPar
注意：启用非阻塞MPI集合将在阻塞MPI集合中禁止多播聚合。

\sphinxAtStartPar
\sphinxstylestrong{启用Mellanox SHARP软件加速集合}

\sphinxAtStartPar
HPC\sphinxhyphen{}X支持Mellanox SHARP软件加速集合，这些集合默认是启用的。
\begin{itemize}
\item {} 
\sphinxAtStartPar
启用Mellanox SHARP加速：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}x HCOLL\_ENABLE\_SHARP=1}}

\item {} 
\sphinxAtStartPar
禁止Mellanox SHARP加速

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}x HCOLL\_ENABLE\_SHARP=0}}

\item {} 
\sphinxAtStartPar
更改Mellanox SHARP消息阈值（默认为256）：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}x HCOLL\_BCOL\_P2P\_ALLREDUCE\_SHARP\_MAX=<threshold>}}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{HCOLL v4.4中的GPU缓存支持}

\sphinxAtStartPar
如果CUDA运行时(runtime)是有效的，则HCOLL自动启用GPU支持。以下集合操作支持GPU缓存：
\begin{itemize}
\item {} 
\sphinxAtStartPar
MPI\_Allreduce

\item {} 
\sphinxAtStartPar
MPI\_Bcast

\item {} 
\sphinxAtStartPar
MPI\_Allgather

\end{itemize}

\sphinxAtStartPar
如果libhcoll的其它聚合操作API被启用GPU缓存调用，则会检查缓存类型后返回错误HCOLL\_ERROR。

\sphinxAtStartPar
控制参数为\sphinxcode{\sphinxupquote{HCOLL\_GPU\_ENABLE}}，其值可为0、1和\sphinxhyphen{}1：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
值
&\sphinxstyletheadfamily 
\sphinxAtStartPar
含义
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0
&
\sphinxAtStartPar
禁止GPU支持。不会检查用户缓存指针
。此情形下，如用户提供在GPU上分配缓存，则这种行为是未定义的。
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
启用GPU支持。将检查缓存指针，且启用HCOLL
GPU聚合，这是CUDA运行时有效时的默认行为。
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}1
&
\sphinxAtStartPar
部分
GPU支持。将检查缓存指针，且HCOLL回退到GPU缓存情形下的运行时。
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstyleemphasis{局限性}

\sphinxAtStartPar
对于MPI\_Allreduce的GPU缓存支持，不是所有(OP, DTYPE)的组合都支持：
\begin{itemize}
\item {} 
\sphinxAtStartPar
支持的操作
\begin{itemize}
\item {} 
\sphinxAtStartPar
SUM

\item {} 
\sphinxAtStartPar
PROD

\item {} 
\sphinxAtStartPar
MIN

\item {} 
\sphinxAtStartPar
MAX

\end{itemize}

\item {} 
\sphinxAtStartPar
支持的类型
\begin{itemize}
\item {} 
\sphinxAtStartPar
INT8、INT16、INT32、INt64

\item {} 
\sphinxAtStartPar
UINT8、UINT16、UINT32、UINT64

\item {} 
\sphinxAtStartPar
FLOAT16、FLOAT32、FLOAT64

\end{itemize}

\end{itemize}
\phantomsection\label{\detokenize{mpi-application/mpi-application:id3}}
\sphinxAtStartPar
\sphinxstylestrong{局限性}

\sphinxAtStartPar
环境变量\sphinxcode{\sphinxupquote{HCOLL\_ALLREDUCE\_ZCOPY\_TUNE=<static/dynamic>}}（默认为dynamic）用于设置HCOLL的大数据全归约操作算法的自动化运行优化级别。如为Static，则对运行时不优化；如是dynamic，则允许HCOLL基于性能的运行时抽样自动调节算法的基数和zero\sphinxhyphen{}copy %
\begin{footnote}[1]\sphinxAtStartFootnote
zero copy技术就是减少不必要的内核缓冲区跟用户缓冲区间的拷贝，从而减少CPU的开销和内核态切换开销，达到性能的提升
%
\end{footnote} 阈值。

\sphinxAtStartPar
注：由于dynamic模式可能会导致浮点数归约结果有变化，因此不应该用于要求是数值可再现的情形下，导致该问题的原因在于非固定的归约顺序。


\subsubsection{统一通信\sphinxhyphen{}X架构(Unified Communication \sphinxhyphen{} X Framework, UCX)}
\label{\detokenize{mpi-application/mpi-application:x-unified-communication-x-framework-ucx}}
\sphinxAtStartPar
UCX是一种新的加速库，并且被集成到OpenMPI（作为pml层）和OpenSHMEM（作为spml层）中作为HPC\sphinxhyphen{}X的一部分。这是种开源的通信库，被设计为HPC应用能获得最高的性能。UCX含有广泛范围的优化，能实现在通信方面接近低级别软件开销，接近原生级别的性能。

\sphinxAtStartPar
UCX支持接收端标记匹配、单边通信语义、有效内存注册和各种增强，能有效提高HPC应用的缩放性和性能。

\sphinxAtStartPar
UCX支持：
\begin{itemize}
\item {} 
\sphinxAtStartPar
InfiniBand传输：
\begin{itemize}
\item {} 
\sphinxAtStartPar
不可信数据报(Unreliable Datagram, UD)

\item {} 
\sphinxAtStartPar
可信连接(Reliable Connected, RC)

\item {} 
\sphinxAtStartPar
动态连接(Dynamically Connected, DC)

\item {} 
\sphinxAtStartPar
加速verbs(Accelerated verbs)

\end{itemize}

\item {} 
\sphinxAtStartPar
Shared Memory communication with support for KNEM, CMA and XPMEM

\item {} 
\sphinxAtStartPar
RoCE

\item {} 
\sphinxAtStartPar
TCP

\item {} 
\sphinxAtStartPar
CUDA

\end{itemize}

\sphinxAtStartPar
更多信息，请参见：\sphinxurl{https://github.com/openucx/ucx}、\sphinxurl{http://www.openucx.org/}

\sphinxAtStartPar
\sphinxstylestrong{OpenMPI中使用UCX}

\sphinxAtStartPar
UCX在Open MPI是默认的pml，在OpenSHMEM中是默认的spml，一般安装好设置号后无需用户自己设置就可使用，用户也可利用下面方式显式指定：
\begin{itemize}
\item {} 
\sphinxAtStartPar
在Open MPI中显式指定采用UCX：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}\sphinxhyphen{}mca pml ucx \sphinxhyphen{}\sphinxhyphen{}mca osc ucx ...}}

\item {} 
\sphinxAtStartPar
在OpenSHMEM显示指定采用UCX：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{oshrun \sphinxhyphen{}\sphinxhyphen{}mca spml ucx ...}}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{调整UCX}

\sphinxAtStartPar
检查UCX的版本：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\$HPCX\_UCX\_DIR/bin/ucx\_info \sphinxhyphen{}v}}

\sphinxAtStartPar
UCX的参数可通过下述方法之一设置：
\begin{itemize}
\item {} 
\sphinxAtStartPar
通过mpirun设置：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}x UCX\_RC\_VERBS\_RX\_MAX\_BUFS=128000 <...>}}

\item {} 
\sphinxAtStartPar
通过SHELL设置：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{export UCX\_RC\_VERBS\_RX\_MAX\_BUFS=128000}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun <...>}}

\item {} 
\sphinxAtStartPar
从命令行选择采用的传输：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}mca pml ucx \sphinxhyphen{}x UCX\_TLS=sm,rc\_x ...}}

\sphinxAtStartPar
上述命令设置了采用pml ucx和设定其用于使用、共享内存和加速传输verbs。

\item {} 
\sphinxAtStartPar
为了提高缩放性能，可以加大DC传输时使用的网卡的DC发起者(DCI)的QPs数

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}mca pml ucx \sphinxhyphen{}x UCX\_TLS=sm,dc\_x \sphinxhyphen{}x UCX\_DC\_MLX5\_NUM\_DCI=16}}

\sphinxAtStartPar
对于大规模系统，当DC传输不可用或者被禁用时，UCX将回退到UD传输。

\sphinxAtStartPar
在256个连接建立后，RC传输将被禁用，该值可以利用\sphinxcode{\sphinxupquote{UCX\_RC\_MAX\_NUM\_EPS}}环境变量加大。

\item {} 
\sphinxAtStartPar
设置UCX使用zero\sphinxhyphen{}copy时的阈值

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}mca pml ucx \sphinxhyphen{}x UCX\_ZCOPY\_THRESH=16384}}

\sphinxAtStartPar
默认UCX会自己计算优化的该阈值，需要时可利用上面环境变量覆盖掉。

\item {} 
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{UCX\_DC\_MLX5\_TX\_POLICY=<policy>}}环境变量设定端点如何选择DC。策略<policy>可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
dcs：端点或者采用已指定的DCI或DCI是LIFO顺序分配的，且在不在有操作需要时释放。

\item {} 
\sphinxAtStartPar
dcs\_quota：类似dcs。另外，该DCI将在发送超过一定配额时，且有端点在等待DCI时被释放。该DCI一旦完成其所有需要的操作后就被释放。该策略确保了在端点间没有饥荒。

\item {} 
\sphinxAtStartPar
rand：每个端点被赋予一个随机选择的DCI。多个端点有可能共享相同的DCI。

\end{itemize}

\item {} 
\sphinxAtStartPar
利用UCX
CUDA内存钩子也许在静态编译CUDA应用时不会生效，作为一个工作区，可利用下面选项扩展配置：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}x UCX\_MEMTYPE\_CACHE=0 \sphinxhyphen{}x HCOLL\_GPU\_CUDA\_MEMTYPE\_CACHE\_ENABLE=0 \sphinxhyphen{}x HCOLL\_GPU\_ENABLE=1}}

\item {} 
\sphinxAtStartPar
GPUDirectRDMA性能问题可以通过分离协议禁止：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}x UCX\_RNDV\_SCHEME=get\_zcopy}}

\item {} 
\sphinxAtStartPar
共享内存新传输协议命名为：TBD

\sphinxAtStartPar
可用的共享内存传输名是：posix、sysv和xpmem

\sphinxAtStartPar
sm和mm将被包含咋以上三种方法中。

\sphinxAtStartPar
设备‘device’名对于共享内存传输是‘memory’（在\sphinxcode{\sphinxupquote{UCX\_SHM\_DEVICES}}中使用）

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{UCX特性}

\sphinxAtStartPar
\sphinxstyleemphasis{硬件标识符匹配(Tag Matching)}

\sphinxAtStartPar
从ConnectX\sphinxhyphen{}5起，在UCX中之前由软件负责的标识符匹配工作可以卸载到HCA。对于MPI应用发送消息时附带的数值标志符的加速对收到消息的处理，可以提高CPU利用率和降低等待消息的延迟。在标识符匹配中，由软件控制的匹配入口表称为匹配表。每个匹配入口含有一个标志符及对应一个应用缓存的指针。匹配表被用于根据消息标志引导到达的消息到特定的缓存。该传输匹配表和寻找匹配入口的动作被称为标识符匹配，该动作由HCA而不再由CPU实现。在当收到的消息被不按照到达顺序而是基于与发送者相关的数值标记使用时，非常有用。

\sphinxAtStartPar
硬件标识符匹配使得省下的CPU可供其它应用使用。当前硬件标识符匹配对于加速的RC和DC传输(RC\_X和DC\_X)是支持的，且可以在UCX中利用下面环境参数启用：
\begin{itemize}
\item {} 
\sphinxAtStartPar
对RC\_X传输： \sphinxcode{\sphinxupquote{UCX\_RC\_MLX5\_TM\_ENABLE=y}}

\item {} 
\sphinxAtStartPar
对DC\_X传输： \sphinxcode{\sphinxupquote{UCX\_DC\_MLX5\_TM\_ENABLE=y}}

\end{itemize}

\sphinxAtStartPar
默认，只有消息大于一定阈值时才卸载到传输。该阈值由\sphinxcode{\sphinxupquote{UCXTM\_THRESH}}环境变量控制，默认是1024比特。

\sphinxAtStartPar
对于硬件标识符匹配，特定阈值时，UCX也许用回弹缓冲区(bounce
buffer)卸载内部预注册缓存代替用户缓存。该阈值由\sphinxcode{\sphinxupquote{UCX\_TM\_MAX\_BB\_SIZE}}环境变变量控制，该值等于或小于分片大小，且必须大于\sphinxcode{\sphinxupquote{UCX\_TM\_THRESH}}才能生效（默认为1024比特，即默认优化是被禁止的）。

\sphinxAtStartPar
\sphinxstyleemphasis{CUDA GPU}

\sphinxAtStartPar
HPC\sphinxhyphen{}X中的CUDA环境支持，使得HPC\sphinxhyphen{}X在针对点对点和集合函数的UCX和HCOLL通信库中使用各自NVIDIA GPU显存。

\sphinxAtStartPar
系统已安装了NVIDIA peer memory，支持\sphinxhref{https://www.mellanox.com/products/GPUDirect-RDMA}{GPUDirect
RDMA}。

\sphinxAtStartPar
\sphinxstyleemphasis{片上内存(MEMIC)}

\sphinxAtStartPar
片上内存允许从UCX层发送消息时使用设备上的内存，该特性默认启用。它仅支持UCX中的rc\_x和dc\_x传输。

\sphinxAtStartPar
控制这些特性的环境变量为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UCX\_RC\_MLX5\_DM\_SIZE}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UCX\_RC\_MLX5\_DM\_COUNT}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UCX\_DC\_MLX5\_DM\_SIZE}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UCX\_DC\_MLX5\_DM\_COUNT}}

\end{itemize}

\sphinxAtStartPar
针对这些参数的更多信息，可以运行ucx\_info工具查看：\sphinxcode{\sphinxupquote{\$HPCX\_UCX\_DIR/bin/ucx\_info \sphinxhyphen{}f}}。

\sphinxAtStartPar
\sphinxstylestrong{生成Open MPI/OpenSHMEM的UCX统计信息}

\sphinxAtStartPar
为生成统计信息，需设定统计目的及触发器，它们可被选择性过滤或/和格式化。
\begin{itemize}
\item {} 
\sphinxAtStartPar
统计目的可以利用\sphinxcode{\sphinxupquote{UCX\_STATS\_DEST}}环境变量设置，其值可以为下列之一：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
空字符串
&\sphinxstyletheadfamily 
\sphinxAtStartPar
不会生成统计信息
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
file:<filename>
&
\sphinxAtStartPar
存到一个文件中，具有以下替换：\%h: host,
\%p:pid, \%c:cpu, \%t: time,
\%e:exe，如文件名有\%h，则自动替换为节点名
\\
\sphinxhline
\sphinxAtStartPar
stderr
&
\sphinxAtStartPar
显示标准错误信息
\\
\sphinxhline
\sphinxAtStartPar
stdout
&
\sphinxAtStartPar
显示标准输出
\\
\sphinxhline
\sphinxAtStartPar
udp:<host>{[}:<port>{]}
&
\sphinxAtStartPar
通过UDP协议发送到host:port
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
比如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{export UCX\_STATS\_DEST="file:ucx\_\%h\_\%e\_\%p.stats"}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{export UCX\_STATS\_DEST="stdout"}}

\item {} 
\sphinxAtStartPar
触发器通过\sphinxcode{\sphinxupquote{UCX\_STATS\_TRIGGER}}环境变量设置，其值可以为下述之一：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
exit
&\sphinxstyletheadfamily 
\sphinxAtStartPar
在程序退出前存储统计信息
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
timer:<interval>
&
\sphinxAtStartPar
每隔一定时间存储统计信息
\\
\sphinxhline
\sphinxAtStartPar
signal:<signo>
&
\sphinxAtStartPar
当进程收到信号时存储统计信息
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
比如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{export UCX\_STATS\_TRIGGER=exit}}
\sphinxcode{\sphinxupquote{export UCX\_STATS\_TRIGGER=timer:3.5}}

\item {} 
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{UCX\_STATS\_FILTER}}环境变量可以过滤报告中的计数器。它接受以,分割的一组匹配项以指定显示的计数器，统计概要将包含匹配的计数器，批配项的顺序是没关系的。列表中的每个表达式可以包含任何以下选项：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
*
&\sphinxstyletheadfamily 
\sphinxAtStartPar
匹配任意字符，包含没有（显示全部报告）
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
?
&
\sphinxAtStartPar
匹配任意单子字符
\\
\sphinxhline
\sphinxAtStartPar

&
\sphinxAtStartPar
匹配在括号中的一个字符
\\
\sphinxhline
\sphinxAtStartPar

&
\sphinxAtStartPar
匹配从括号中一定范围的字符
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
关于该参数的更多信息可以参见：\sphinxurl{https://github.com/openucx/ucx/wiki/Statistics}。

\item {} 
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{UCX\_STATS\_FORMAT}}环境参数可以控制统计的格式：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
full
&\sphinxstyletheadfamily 
\sphinxAtStartPar
每个计数器都将被在一个单行中显示
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
agg
&
\sphinxAtStartPar
每个计数器将在一个单行中显示，但是将会聚合类似的计数器
\\
\sphinxhline
\sphinxAtStartPar
summary
&
\sphinxAtStartPar
所有计数器将显示在同一行
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
注意：统计特性只有当编译安装UCX库时打开启用统计标记的时候才生效。默认为No，即不启用。因此为了使用统计特性，请重新采用文件编译UCX，或采用debug版本的UCX，可以在\$HPCX\_UCX\_DIR/debug中找到：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}mca pml ucx \sphinxhyphen{}x LD\_PRELOAD=\$HPCX\_UCX\_DIR/debug/lib/libucp.so ...}}

\sphinxAtStartPar
注意：采用上面提到的重新编译的UCX将会影响性能。

\end{itemize}


\subsubsection{PGAS共享内存访问(OpenSHMEM)}
\label{\detokenize{mpi-application/mpi-application:pgas-openshmem}}
\sphinxAtStartPar
共享内存(SHMEM)子程序为高级并行扩展程序提供了低延迟、高带宽的通信。这些子程序在SHMEM
API中提供了用于在协作并行进程间交换数据的编程模型。SHMEM
API可在同一个并行程序中独自或与MPI子程序一起使用。

\sphinxAtStartPar
SHMEM并行编程库是一种非常简单易用的编程模型，可以使用高效的单边通讯API为共享或分布式内存系统提供直观的全局观点接口。

\sphinxAtStartPar
SHMEM程序是单程序多数据(SPMD)类型的。所有的SHMEM进程，被引用为进程单元(PEs)，同时启动且运行相同程序。通常，PEs在它们大程序中自己的子域进行计算，并且周期性与其它下次通讯依赖的PEs进行通信实现数据交换。

\sphinxAtStartPar
SHMEM子程序最小化数据传输请求、最大化带宽以及最小化数据延迟（从一个PE初始化数据传输到结束时的时间周期差）。

\sphinxAtStartPar
SHMEM子程序通过以下支持远程数据传输：
\begin{itemize}
\item {} 
\sphinxAtStartPar
put操作：传递数据给一个不同PE；

\item {} 
\sphinxAtStartPar
get操作：从一个不同PE和远程指针获取数据，允许直接访问属于其它PE的数据。

\end{itemize}

\sphinxAtStartPar
其它支持的操作是集合广播和归约、栅栏同步和原子内存操作(atomic memory
operation)。原子内存操作指的是原子（不允许多个进程同时）读\sphinxhyphen{}更新操作，比如对远程或本地数据的获取\sphinxhyphen{}增加。

\sphinxAtStartPar
SHMEM库实现激活消息。源处理器将数据传输到目的处理器时仅涉及一个CPU，例如，一个处理器从另外处理器内存读取数据而无需中断远程CPU，除非编程者实现了一种机制去告知这些，否则远程处理器察觉不到其内存被读写。

\sphinxAtStartPar
\sphinxstylestrong{HPC\sphinxhyphen{}X Open MPI/OpenSHMEM}

\sphinxAtStartPar
HPC\sphinxhyphen{}X Open MPI/OpenSHMEM编程库是单边通信库，支持唯一的并行编程特性集合，包括并行程序应用进程间使用的点对点和集合子程序、同步、原子操作、和共享内存范式。

\sphinxAtStartPar
HPC\sphinxhyphen{}X OpenSHMEM基于OpenSHMEM.org协会定义的API，该库可在OFED(OpenFabrics
RDMA for Linux stack )上运行，并可使用UCX和Mellanox
FCA，为运行在InfiniBand上的SHMEM程序提供了史无前例的可扩展性级别。

\sphinxAtStartPar
\sphinxstylestrong{运行HPC\sphinxhyphen{}X OpenSHMEM}

\sphinxAtStartPar
\sphinxstyleemphasis{采用UCX运行HPC\sphinxhyphen{}X OpenSHMEM}

\sphinxAtStartPar
对于HPC\sphinxhyphen{}X，采用spml对程序提供服务。v2.1及之后的版本的HPC\sphinxhyphen{}X，ucx已是默认的spml，无需特殊指定，或者也可在oshrun命令行添加\sphinxcode{\sphinxupquote{\sphinxhyphen{}mca spml ucx}}显式指定。

\sphinxAtStartPar
所有的UCX环境参数，oshrun使用时与mpirun一样，完整的列表可运行下面命令获取：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\$HPCX\_UCX\_DIR/bin/ucx\_info \sphinxhyphen{}f}}

\sphinxAtStartPar
\sphinxstyleemphasis{采用HPC\sphinxhyphen{}X OpenSHMEM与MPI一起开发应用}

\sphinxAtStartPar
SHMEM编程模型提供了一种提高延迟敏感性部分的性能的方法。通常，要求采用调用shmem\_put/shmem\_get和shmem\_barrier来代替调用MPI中的send/recv。

\sphinxAtStartPar
SHMEM模型对于短消息来说可以相比传统的MPI调用能显著降低延时。对于MPI\sphinxhyphen{}2
MPI\_Put/MPI\_Get函数，也可以考虑替换为shmem\_get/shmem\_put调用。

\sphinxAtStartPar
\sphinxstyleemphasis{HPC\sphinxhyphen{}X OpenSHMEM调整参数}
\begin{quote}

\sphinxAtStartPar
HPC\sphinxhyphen{}X OpenSHMEM采用MCA参数来调整设置用户应用运行时环境。每个参数对应一种特定函数，以下为可以改变用于应用函数的参数：
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
memheap：控制内存分配策略及阈值

\item {} 
\sphinxAtStartPar
scoll：控制HPC\sphinxhyphen{}X OpenSHMEM集合API阈值及算法

\item {} 
\sphinxAtStartPar
spml：控制HPC\sphinxhyphen{}X OpenSHMEM点对点传输逻辑及阈值

\item {} 
\sphinxAtStartPar
atomic：控制HPC\sphinxhyphen{}X OpenSHMEM原子操作逻辑及阈值

\item {} 
\sphinxAtStartPar
shmem：控制普通HPC\sphinxhyphen{}X OpenSHMEM API行为

\end{itemize}

\sphinxAtStartPar
显示HPC\sphinxhyphen{}X OpenSHMEM参数：
\begin{itemize}
\item {} 
\sphinxAtStartPar
显示所有可用参数：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{oshmem\_info \sphinxhyphen{}a}}

\end{itemize}

\item {} 
\sphinxAtStartPar
显示HPC\sphinxhyphen{}X OpenSHMEM特定参数：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{oshmem\_info \sphinxhyphen{}\sphinxhyphen{}param shmem all}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{oshmem\_info \sphinxhyphen{}\sphinxhyphen{}param memheap all}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{oshmem\_info \sphinxhyphen{}\sphinxhyphen{}param scoll all}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{oshmem\_info \sphinxhyphen{}\sphinxhyphen{}param spml all}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{oshmem\_info \sphinxhyphen{}\sphinxhyphen{}param atomic all}}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
：在所有节点上运行OpenSHMEM应用或性能测试时，需要执行以下命令以释放内存：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{echo 3 > /proc/sys/vm/drop\_caches}}

\sphinxAtStartPar
\sphinxstyleemphasis{针对对称堆(Symmetric Heap)应用的OpenSHMEM MCA参数}

\sphinxAtStartPar
SHMEM memheap大小可以通过对oshrun命令添加\sphinxcode{\sphinxupquote{SHMEM\_SYMMETRIC\_HEAP\_SIZE}}参数来设置，默认为256M。

\sphinxAtStartPar
例如，采用64M memheap来运行SHMEM：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{oshrun \sphinxhyphen{}x SHMEM\_SYMMETRIC\_HEAP\_SIZE=64M \sphinxhyphen{}np 512 \sphinxhyphen{}mca mpi\_paffinity\_alone 1 \textbackslash{}\textbackslash{}}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}map\sphinxhyphen{}by node \sphinxhyphen{}display\sphinxhyphen{}map \sphinxhyphen{}hostfile myhostfile example.exe}}

\sphinxAtStartPar
memheap可以采用下述方法分配：
\begin{itemize}
\item {} 
\sphinxAtStartPar
sysv：system V共享内存API，目前不支持采用大页面(hugepages)分配。

\item {} 
\sphinxAtStartPar
verbs：采用IB verbs分配子。

\item {} 
\sphinxAtStartPar
mmap：采用mmap()分配内存。

\item {} 
\sphinxAtStartPar
ucx： 通过UCX库分配和注册内存

\end{itemize}

\sphinxAtStartPar
默认，HPC\sphinxhyphen{}X OpenSHMEM会自己寻找最好的分配子，优先级为verbs、sysv、mmap和ucx，也可以采用\sphinxhyphen{}mca sshmem <name>指定分配方法。

\sphinxAtStartPar
\sphinxstyleemphasis{用于强制连接生成的参数}

\sphinxAtStartPar
通常，SHMEM会在PE间消极地生成连接，一般是在第一个通信发生时。
\begin{itemize}
\item {} 
\sphinxAtStartPar
开始时就强制连接生成，设定MCA参数：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}mca shmem\_preconnect\_all 1}}

\sphinxAtStartPar
内存注册器（如，infiniband rkeys）信息启动时会在进程间交换。

\item {} 
\sphinxAtStartPar
启用按需内存密钥(key)交换，可设置MCA参数：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}mca shmalloc\_use\_modex 0}}

\end{itemize}


\subsection{Open MPI库}
\label{\detokenize{mpi-application/mpi-application:open-mpi}}\label{\detokenize{mpi-application/mpi-application:openmpi}}
\begin{DUlineblock}{0em}
\item[] Open MPI %
\begin{footnote}[2]\sphinxAtStartFootnote
主页：\sphinxurl{http://www.open-mpi.org/}
%
\end{footnote} 库是另一种非常优秀MPI实现，用户如需使用可以自己通过运行
\item[] \sphinxcode{\sphinxupquote{module load}}选择加载与openmpi相关的项自己设置即可。
\end{DUlineblock}

\sphinxAtStartPar
Open MPI的安装 \sphinxcode{\sphinxupquote{/opt/opnempi}} 目录在下。

\sphinxAtStartPar
Open MPI的编译命令主要为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
C程序：\sphinxcode{\sphinxupquote{mpicc}}

\item {} 
\sphinxAtStartPar
C++程序：\sphinxcode{\sphinxupquote{mpic++}}、\sphinxcode{\sphinxupquote{mpicxx}}、\sphinxcode{\sphinxupquote{mpiCC}}

\item {} 
\sphinxAtStartPar
Fortran 77程序：\sphinxcode{\sphinxupquote{mpif77}}、\sphinxcode{\sphinxupquote{mpif90}}、\sphinxcode{\sphinxupquote{mpifort}}

\item {} 
\sphinxAtStartPar
Fortran 90程序：\sphinxcode{\sphinxupquote{mpif90}}

\item {} 
\sphinxAtStartPar
Fortran程序：\sphinxcode{\sphinxupquote{mpifort}} %
\begin{footnote}[3]\sphinxAtStartFootnote
注意为mpifort，而不是Intel MPI的mpifort
%
\end{footnote}

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpifort}}为1.8系列引入的编译Fortran程序的命令。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpif77}}和\sphinxcode{\sphinxupquote{mpif90}}为1.6系列和1.8系列的编译Fortran程序的命令。

\sphinxAtStartPar
对于MPI并行程序，对应不同类型源文件的编译命令如下：
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] 将C语言的MPI并行程序yourprog\sphinxhyphen{}mpi.c编译为可执行文件yourprog\sphinxhyphen{}mpi：
\item[] \sphinxcode{\sphinxupquote{mpicc \sphinxhyphen{}o yourprog\sphinxhyphen{}mpi yourprog\sphinxhyphen{}mpi.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将C++语言的MPI并行程序yourprog\sphinxhyphen{}mpi.cpp编译为可执行文件yourprog\sphinxhyphen{}mpi，也可换为\sphinxcode{\sphinxupquote{mpic++}}或\sphinxcode{\sphinxupquote{mpiCC}}：
\item[] \sphinxcode{\sphinxupquote{mpicxx \sphinxhyphen{}o yourprog\sphinxhyphen{}mpi yourprog\sphinxhyphen{}mpi.cpp}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran
90语言的MPI并行程序yourprog\sphinxhyphen{}mpi.f90编译为可执行文件yourprog\sphinxhyphen{}mpi：
\item[] \sphinxcode{\sphinxupquote{mpifort \sphinxhyphen{}o yourprog\sphinxhyphen{}mpi yourprog\sphinxhyphen{}mpi.f90}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran
77语言的MPI并行程序yourprog\sphinxhyphen{}mpi.f编译为可执行文件yourprog\sphinxhyphen{}mpi：
\item[] \sphinxcode{\sphinxupquote{mpif77 \sphinxhyphen{}o yourprog\sphinxhyphen{}mpi yourprog\sphinxhyphen{}mpi.f}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 将Fortran
90语言的MPI并行程序yourprog\sphinxhyphen{}mpi.f90编译为可执行文件yourprog\sphinxhyphen{}mpi：
\item[] \sphinxcode{\sphinxupquote{mpif90 \sphinxhyphen{}o yourprog\sphinxhyphen{}mpi yourprog\sphinxhyphen{}mpi.f90}}
\end{DUlineblock}

\end{itemize}

\sphinxAtStartPar
编译命令的基本语法为：\sphinxcode{\sphinxupquote{\textbackslash{} {[}\sphinxhyphen{}showme|\sphinxhyphen{}showme:compile|\sphinxhyphen{}showme:link{]} ...}}

\sphinxAtStartPar
编译参数可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
–showme：显示所调用的编译器所调用编译参数等信息。

\item {} 
\sphinxAtStartPar
–showme:compile：显示调用的编译器的参数

\item {} 
\sphinxAtStartPar
–showme:link：显示调用的链接器的参数

\item {} 
\sphinxAtStartPar
–showme:command：显示调用的编译命令

\item {} 
\sphinxAtStartPar
–showme:incdirs：显示调用的编译器所使用的头文件目录，以空格分隔。

\item {} 
\sphinxAtStartPar
–showme:libdirs：显示调用的编译器所使用的库文件目录，以空格分隔。

\item {} 
\sphinxAtStartPar
–showme:libs：显示调用的编译器所使用的库名，以空格分隔。

\item {} 
\sphinxAtStartPar
–showme:version：显示Open MPI的版本号。

\end{itemize}

\sphinxAtStartPar
默认使用配置Open MPI时所用的编译器及其参数，可以利用环境变量来改变。环境变量格式为\sphinxcode{\sphinxupquote{OMPI\_value}}，其\sphinxcode{\sphinxupquote{value}}可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CPPFLAGS}}：调用C或C++预处理器时的参数

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LDFLAGS}}：调用链接器时的参数

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LIBS}}：调用链接器时所添加的库

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CC}}：C编译器

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CFLAGS}}：C编译器参数

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CXX}}：C++编译器

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CXXFLAGS}}：C++编译器参数

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{F77}}：Fortran 77编译器

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FFLAGS}}：Fortran 77编译器参数

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FC}}：Fortran 90编译器

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FCFLAGS}}：Fortran 90编译器参数

\end{itemize}


\subsection{Intel MPI库}
\label{\detokenize{mpi-application/mpi-application:intel-mpi}}
\sphinxAtStartPar
Intel MPI针对最新的Mellanox HDR有问题，不建议使用；如您的应用运行起来没问题，也可以使用。

\sphinxAtStartPar
Intel MPI库 %
\begin{footnote}[4]\sphinxAtStartFootnote
主页：\sphinxurl{http://software.intel.com/en-us/intel-mpi-library/}
%
\end{footnote} 是一种多模消息传递接口(MPI)库，所安装的5.0版本Intel MPI库实现了\sphinxhref{http://www.mpi-forum.org/}{MPI V3.0标准}。Intel MPI库可以使开发者采用新技术改变或升级其处理器和互联网络而无需改编软件或操作环境成为可能。主要包含以下内容：
\begin{itemize}
\item {} 
\sphinxAtStartPar
Intel
MPI库运行时环境(RTO)：具有运行程序所需要的工具，包含多功能守护进程(MPD)、Hydra及支持的工具、共享库(.so)和文档。

\item {} 
\sphinxAtStartPar
Intel
MPI库开发套件(SDK)：包含所有运行时环境组件和编译工具，含编译器命令，如\sphinxcode{\sphinxupquote{mpiicc}}、头文件和模块、静态库(.a)、调试库、追踪库和测试代码。

\end{itemize}


\subsubsection{编译命令}
\label{\detokenize{mpi-application/mpi-application:id8}}
\sphinxAtStartPar
请注意，Intel MPI与Open MPI等MPI实现不同，\sphinxcode{\sphinxupquote{mpicc}}、\sphinxcode{\sphinxupquote{mpif90}}和\sphinxcode{\sphinxupquote{mpifc}}命令默认使用GNU编译器，如需指定使用Intel编译器等，请使用对应的\sphinxcode{\sphinxupquote{mpiicc}}、\sphinxcode{\sphinxupquote{mpiicpc}}和\sphinxcode{\sphinxupquote{mpiifort}}命令。下表为Intel MPI编译命令及其对应关系。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Intel MPI编译命令及其对应关系}\label{\detokenize{mpi-application/mpi-application:id22}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
编译命令
&\sphinxstyletheadfamily 
\sphinxAtStartPar
调用的默认编译器命令
&\sphinxstyletheadfamily 
\sphinxAtStartPar
支持的语言
&\sphinxstyletheadfamily 
\sphinxAtStartPar
支持的应用二进制接口
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook&&&\\
\sphinxhline
\sphinxAtStartPar
mpicc
&
\sphinxAtStartPar
gcc, cc
&
\sphinxAtStartPar
C
&
\sphinxAtStartPar
32/64 bit
\\
\sphinxhline
\sphinxAtStartPar
mpicxx
&
\sphinxAtStartPar
g++
&
\sphinxAtStartPar
C/C++
&
\sphinxAtStartPar
32/64 bit
\\
\sphinxhline
\sphinxAtStartPar
mpifc
&
\sphinxAtStartPar
gfortran
&
\sphinxAtStartPar
Fortran77*/Fortran 95*
&
\sphinxAtStartPar
32/64 bit
\\
\sphinxhline&&&\\
\sphinxhline
\sphinxAtStartPar
mpigcc
&
\sphinxAtStartPar
gcc
&
\sphinxAtStartPar
C
&
\sphinxAtStartPar
32/64 bit
\\
\sphinxhline
\sphinxAtStartPar
mpigxx
&
\sphinxAtStartPar
g++
&
\sphinxAtStartPar
C/C++
&
\sphinxAtStartPar
32/64 bit
\\
\sphinxhline&&&\\
\sphinxhline
\sphinxAtStartPar
mpif77
&
\sphinxAtStartPar
g77
&
\sphinxAtStartPar
Fortran 77
&
\sphinxAtStartPar
32/64 bit
\\
\sphinxhline
\sphinxAtStartPar
mpif90
&
\sphinxAtStartPar
gfortran
&
\sphinxAtStartPar
Fortran 95
&
\sphinxAtStartPar
32/64 bit
\\
\sphinxhline&&&\\
\sphinxhline
\sphinxAtStartPar
mpiicc
&
\sphinxAtStartPar
icc
&
\sphinxAtStartPar
C
&
\sphinxAtStartPar
32/64 bit
\\
\sphinxhline
\sphinxAtStartPar
mpiicpc
&
\sphinxAtStartPar
icpc
&
\sphinxAtStartPar
C++
&
\sphinxAtStartPar
32/64 bit
\\
\sphinxhline
\sphinxAtStartPar
mpiifort
&
\sphinxAtStartPar
ifort
&
\sphinxAtStartPar
Fortran77/Fortran 95
&
\sphinxAtStartPar
32/64 bit
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
其中：
\begin{itemize}
\item {} 
\sphinxAtStartPar
ia32：IA\sphinxhyphen{}32架构。

\item {} 
\sphinxAtStartPar
intel64：Intel 64(x86\_64, amd64)架构。

\item {} 
\sphinxAtStartPar
移植现有的MPI程序到Intel MPI库时，请重新编译所有源代码。

\item {} 
\sphinxAtStartPar
如需显示某命令的简要帮助，可以不带任何参数直接运行该命令。

\end{itemize}


\subsubsection{编译命令参数}
\label{\detokenize{mpi-application/mpi-application:id9}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mt\_mpi：采用以下级别链接线程安全的MPI库：MPI\_THREAD\_FUNNELED, MPI\_THREAD\_SERIALIZED或MPI\_THREAD\_MULTIPLE。

\sphinxAtStartPar
Intel MPI库默认使用MPI\_THREAD\_FUNNELED级别线程安全库。

\sphinxAtStartPar
注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
如使用Intel C编译器编译时添加了\sphinxhyphen{}openmp、\sphinxhyphen{}qopenmp或\sphinxhyphen{}parallel参数，那么使用线程安全库。

\item {} 
\sphinxAtStartPar
如果用Intel Fortran编译器编译时添加了如下参数，那么使用线程安全库：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}openmp

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}qopenmp

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}parallel

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}threads

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}reentrancy

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}reentrancy threaded

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}static\_mpi：静态链接Intel MPI库，并不影响其它库的链接方式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}static：静态链接Intel MPI库，并将其传递给编译器，作为编译器参数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}config\sphinxstyleemphasis{=name}：使用的配置文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}profile\sphinxstyleemphasis{=profile\_name}：使用的MPI分析库文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}t或\sphinxhyphen{}trace：链接Intel Trace Collector库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}check\_mpi：链接Intel Trace Collector正确性检查库。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}ilp64：打开局部ILP64支持。对于Fortran程序编译时如果使用\sphinxhyphen{}i8选项，那么也需要此ILP64选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}dynamic\_log：与\sphinxhyphen{}t组合使用链接Intel Trace Collector库。不影响其它库链接方式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}g：采用调试模式编译程序，并针对Intel MPI调试版本生成可执行程序。可查看官方手册Environment variables部分\sphinxcode{\sphinxupquote{I\_MPI\_DEBUG}}变量查看\sphinxhyphen{}g参数添加的调试信息。采用调试模式时不对程序进行优化，可查看\sphinxcode{\sphinxupquote{I\_MPI\_LINK}}获取Intel MPI调试版本信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}link\_mpi\sphinxstyleemphasis{=arg}：指定链接MPI的具体版本，具体请查看\sphinxcode{\sphinxupquote{I\_MPI\_LINK}}获取Intel MPI版本信息。此参数将覆盖掉其它参数，如\sphinxhyphen{}mt\_mpi、\sphinxhyphen{}t=log、\sphinxhyphen{}trace=log和\sphinxhyphen{}g。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}O：启用编译器优化。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}fast：对整个程序进行最大化速度优化。此参数强制使用静态方法链接Intel MPI库。\sphinxcode{\sphinxupquote{mpiicc}}、\sphinxcode{\sphinxupquote{mpiicpc}}和\sphinxcode{\sphinxupquote{mpiifort}}编译命令支持此参数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}echo：显示所有编译命令脚本做的信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}show：仅显示编译器如何链接，但不实际执行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\{cc,cxx,fc,f77,f90\}\sphinxstyleemphasis{=compiler}：选择使用的编译器。如：\sphinxcode{\sphinxupquote{mpicc \sphinxhyphen{}cc=icc \sphinxhyphen{}c test.c}}。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}gcc\sphinxhyphen{}version\sphinxstyleemphasis{=nnn}，设置编译命令\sphinxcode{\sphinxupquote{mpicxx}}和\sphinxcode{\sphinxupquote{mpiicpc}}编译时采用部分GNU C++环境的版本，如nnn的值为340，表示对应GNU C++ 3.4.x。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(<\)nnn\(>\)值
&\sphinxstyletheadfamily 
\sphinxAtStartPar
GNU* C++版本
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
320
&
\sphinxAtStartPar
3.2.x
\\
\sphinxhline
\sphinxAtStartPar
330
&
\sphinxAtStartPar
3.3.x
\\
\sphinxhline
\sphinxAtStartPar
340
&
\sphinxAtStartPar
3.4.x
\\
\sphinxhline
\sphinxAtStartPar
400
&
\sphinxAtStartPar
4.0.x
\\
\sphinxhline
\sphinxAtStartPar
410
&
\sphinxAtStartPar
4.1.x
\\
\sphinxhline
\sphinxAtStartPar
420
&
\sphinxAtStartPar
4.2.x
\\
\sphinxhline
\sphinxAtStartPar
430
&
\sphinxAtStartPar
4.3.x
\\
\sphinxhline
\sphinxAtStartPar
440
&
\sphinxAtStartPar
4.4.x
\\
\sphinxhline
\sphinxAtStartPar
450
&
\sphinxAtStartPar
4.5.x
\\
\sphinxhline
\sphinxAtStartPar
460
&
\sphinxAtStartPar
4.6.x
\\
\sphinxhline
\sphinxAtStartPar
470
&
\sphinxAtStartPar
4.7.x
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}compchk：启用编译器设置检查，以保证调用的编译器配置正确。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}v：显示版本信息。

\end{itemize}


\subsubsection{环境变量}
\label{\detokenize{mpi-application/mpi-application:id10}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I\_MPI\_\{CC,CXX,FC,F77,F90\}\_PROFILE}}和\sphinxcode{\sphinxupquote{MPI\{CC,CXX,FC,F77,F90\}\_PROFILE}}：
\begin{itemize}
\item {} 
\sphinxAtStartPar
默认分析库。

\item {} 
\sphinxAtStartPar
语法：\sphinxcode{\sphinxupquote{I\_MPI\_\{CC,CXX,FC,F77,F90\}\_PROFILE=<profile\_name>}}。

\item {} 
\sphinxAtStartPar
过时语法：\sphinxcode{\sphinxupquote{MPI\{CC,CXX,FC,F77,F90\}\_PROFILE=<profile\_name>}}。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I\_MPI\_TRACE\_PROFILE}}：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设定\sphinxhyphen{}trace参数使用的默认分析文件。

\item {} 
\sphinxAtStartPar
语法：\sphinxcode{\sphinxupquote{I\_MPI\_TRACE\_PROFILE=<profile\_name>}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I\_MPI\_\{CC,CXX,F77,F90\}\_PROFILE}}环境变量将覆盖掉\sphinxcode{\sphinxupquote{I\_MPI\_TRACE\_PROFILE}}。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I\_MPI\_CHECK\_PROFILE}}：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设定\sphinxhyphen{}check\_mpi参数使用的默认分析。

\item {} 
\sphinxAtStartPar
语法：\sphinxcode{\sphinxupquote{I\_MPI\_CHECK\_PROFILE=<profile\_name>}}。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I\_MPI\_CHECK\_COMPILER}}：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设定启用或禁用编译器兼容性检查。

\item {} 
\sphinxAtStartPar
语法：\sphinxcode{\sphinxupquote{I\_MPI\_CHECK\_COMPILER=<arg>}}。
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<arg>}}为\sphinxcode{\sphinxupquote{enable | yes | on | 1}}时打开兼容性检查。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<arg>}}为\sphinxcode{\sphinxupquote{disable | no | off | 0}}时，关闭编译器兼容性检查，为默认值。

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I\_MPI\_\{CC,CXX,FC,F77,F90\}}}和\sphinxcode{\sphinxupquote{MPICH\_\{CC,CXX,FC,F77,F90\}}}：
\begin{itemize}
\item {} 
\sphinxAtStartPar
语法：\sphinxcode{\sphinxupquote{I\_MPI\_\{CC,CXX,FC,F77,F90\}=<compiler>}}。

\item {} 
\sphinxAtStartPar
过时语法：\sphinxcode{\sphinxupquote{MPICH\_\{CC,CXX,FC,F77,F90\}=<compiler>}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<compiler>}}为编译器的编译命令名或路径。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I\_MPI\_ROOT}}：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设置Intel MPI库的安装目录路径。

\item {} 
\sphinxAtStartPar
语法：\sphinxcode{\sphinxupquote{I\_MPI\_ROOT=<path>}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<path>}}为Intel MPI库的安装后的目录。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{VT\_ROOT}}：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设置Intel Trace Collector的安装目录路径。

\item {} 
\sphinxAtStartPar
语法：\sphinxcode{\sphinxupquote{VT\_ROOT=<path>}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<path>}}为Intel Trace Collector的安装后的目录。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I\_MPI\_COMPILER\_CONFIG\_DIR}}：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设置编译器配置目录路径。

\item {} 
\sphinxAtStartPar
语法：\sphinxcode{\sphinxupquote{I\_MPI\_COMPILER\_CONFIG\_DIR=<path>}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<path>}}为编译器安装后的配置目录，默认值为\sphinxcode{\sphinxupquote{<installdir>/<arch>/etc}}。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I\_MPI\_LINK}}：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设置链接MPI库版本。

\item {} 
\sphinxAtStartPar
语法：\sphinxcode{\sphinxupquote{I\_MPI\_LINK=<arg>}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<arg>}}可为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{opt}}：优化的单线程版本Intel MPI库；

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{opt\_mt}}：优化的多线程版本Intel MPI库；

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dbg}}：调试的单线程版本Intel MPI库；

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dbg\_mt}}：调试的多线程版本Intel MPI库；

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{log}}：日志的单线程版本Intel MPI库；

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{log\_mt}}：日志的多线程版本Intel MPI库。

\end{itemize}

\end{itemize}

\end{itemize}


\subsubsection{编译举例}
\label{\detokenize{mpi-application/mpi-application:id11}}
\sphinxAtStartPar
对于MPI并行程序，对应不同类型源文件的编译命令如下：
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] 调用默认C编译器将C语言的MPI并行程序yourprog\sphinxhyphen{}mpi.c编译为可执行文件yourprog\sphinxhyphen{}mpi：
\item[] \sphinxcode{\sphinxupquote{mpicc \sphinxhyphen{}o yourprog\sphinxhyphen{}mpi yourprog\sphinxhyphen{}mpi.c}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 调用Intel
C编译器将C语言的MPI并行程序yourprog\sphinxhyphen{}mpi.c编译为可执行文件yourprog\sphinxhyphen{}mpi：
\item[] \sphinxcode{\sphinxupquote{mpiicc \sphinxhyphen{}o yourprog\sphinxhyphen{}mpi yourprog\sphinxhyphen{}mpi.cpp}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 调用Intel
C++编译器将C++语言的MPI并行程序yourprog\sphinxhyphen{}mpi.cpp编译为可执行文件yourprog\sphinxhyphen{}mpi：
\item[] \sphinxcode{\sphinxupquote{mpiicxx \sphinxhyphen{}o yourprog\sphinxhyphen{}mpi yourprog\sphinxhyphen{}mpi.cpp}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 调用GNU Forttan编译器将Fortran
77语言的MPI并行程序yourprog\sphinxhyphen{}mpi.f编译为可执行文件yourprog\sphinxhyphen{}mpi：
\item[] \sphinxcode{\sphinxupquote{mpif90 \sphinxhyphen{}o yourprog\sphinxhyphen{}mpi yourprog\sphinxhyphen{}mpi.f}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] 调用Intel Fortran编译器将Fortran
90语言的MPI并行程序yourprog\sphinxhyphen{}mpi.f90编译为可执行文件yourprog\sphinxhyphen{}mpi：
\item[] \sphinxcode{\sphinxupquote{mpiifort \sphinxhyphen{}o yourprog\sphinxhyphen{}mpi yourprog\sphinxhyphen{}mpi.f90}}
\end{DUlineblock}

\end{itemize}


\subsubsection{调试}
\label{\detokenize{mpi-application/mpi-application:id12}}
\sphinxAtStartPar
使用以下命令对Intel MPI库调用GDB调试器： \sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}gdb \sphinxhyphen{}n 4 ./testc}}

\sphinxAtStartPar
可以像使用GDB调试串行程序一样调试。

\sphinxAtStartPar
也可以使用以下命令附着在一个运行中的作业上：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}n 4 \sphinxhyphen{}gdba <pid>}}

\sphinxAtStartPar
其中<pid>为运行中的MPI作业进程号。

\sphinxAtStartPar
环境变量I\_MPI\_DEBUG提供一种获得MPI应用运行时信息的方式。可以设置此变量的值从0到1000，值越大，信息量越大。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}genv I\_MPI\_DEBUG 5 \sphinxhyphen{}n 8 ./my\_application}}

\sphinxAtStartPar
更多信息参见程序调试章节。


\subsubsection{追踪}
\label{\detokenize{mpi-application/mpi-application:id13}}
\sphinxAtStartPar
使用\sphinxhyphen{}t或\sphinxhyphen{}trace选项链接调用Intel Trace Collector库生成可执行程序。此与当在mpiicc或其它编译脚本中使用\sphinxhyphen{}profile=vt时具有相同的效果。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiicc \sphinxhyphen{}trace test.c \sphinxhyphen{}o testc}}

\sphinxAtStartPar
在环境变量VT\_ROOT中包含用Intel Trace Collector库路径以便使用此选项。设置I\_MPI\_TRACE\_PROFILE为<profile\_name>环境变量指定另一个概要库。如设置
I\_MPI\_TRACE\_PROFILE为vtfs，以链接fail\sphinxhyphen{}safe版本的Intel Trace Collector库。


\subsubsection{正确性检查}
\label{\detokenize{mpi-application/mpi-application:id14}}
\sphinxAtStartPar
使用\sphinxhyphen{}check\_mpi选项调用Intel Trace Collector正确性检查库生成可执行程序。此与当在mpiicc或其它编译脚本中使用\sphinxhyphen{}profile=vtmc时具有相同的效果。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiicc \sphinxhyphen{}profile=vtmc test.c \sphinxhyphen{}o testc}}

\sphinxAtStartPar
或

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiicc \sphinxhyphen{}check\_mpi test.c \sphinxhyphen{}o testc}}

\sphinxAtStartPar
在环境变量VT\_ROOT中包含用Intel Trace Collector库路径以便使用此选项。设置I\_MPI\_CHECK\_PROFILE为<profile\_name>环境变量指定另一个概要库。


\subsubsection{统计收集}
\label{\detokenize{mpi-application/mpi-application:id15}}
\sphinxAtStartPar
如果想收集在应用使用的MPI函数统计，可以设置I\_MPI\_STATS环境变量的值为1到10。设置好后再运行MPI程序，则在stats.txt文件中存储统计信息。


\subsection{与编译器相关的编译选项}
\label{\detokenize{mpi-application/mpi-application:id16}}
\sphinxAtStartPar
MPI编译环境的编译命令实际上是调用Intel、PGI或GCC编译器进行编译，具体优化选项等，请参看Intel
MPI、Open MPI以及Intel、PGI和GCC编译器手册。


\section{MPI并行程序的运行}
\label{\detokenize{mpi-application/mpi-application:id17}}
\sphinxAtStartPar
MPI程序最常见的并行方式类似为：\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}n 40 yourmpi\sphinxhyphen{}prog}}。

\sphinxAtStartPar
在本超算系统上，MPI并行程序需结合Slurm作业调度系统的作业提交命令\sphinxcode{\sphinxupquote{sbatch}}、\sphinxcode{\sphinxupquote{srun}}或\sphinxcode{\sphinxupquote{salloc}}等来调用作业脚本运行，请参看。

\sphinxstepscope


\chapter{程序调试}
\label{\detokenize{debug/debug:id1}}\label{\detokenize{debug/debug::doc}}
\sphinxAtStartPar
从Intel C/C++ Fortran编译器2015版开始，采用的是Intel改造的GDB调试器，命令为\sphinxcode{\sphinxupquote{gdb\sphinxhyphen{}ia}}。PGI调试器很多调试命令类似GDB调试器，请自己查看相关资料。


\section{GDB调试器简介}
\label{\detokenize{debug/debug:gdb}}
\sphinxAtStartPar
GDB调试器可以让使用者查看其它程序运行时内部发生了什么或查看其它程序崩溃时程序在做什么。主要包括以下四项功能以便帮助找出bug：
\begin{itemize}
\item {} 
\sphinxAtStartPar
启动程序，并指定任何可能影响行为的东西。

\item {} 
\sphinxAtStartPar
使程序在特定条件下停止。

\item {} 
\sphinxAtStartPar
当程序停止时，检查发生了什么。

\item {} 
\sphinxAtStartPar
修改程序中的一些东西，以便能用正确的东西影响bug，并获得进一步信息。

\end{itemize}

\sphinxAtStartPar
GDB调试可用于调试采用C/C++、Fortran、D、Modula\sphinxhyphen{}2、OpenCL C、Pascal、Objective\sphinxhyphen{}C等编写的程序。


\section{基本启动方式{[}gdbstart{]}}
\label{\detokenize{debug/debug:gdbstart}}
\sphinxAtStartPar
GDB调试器在Linux系统上可以采用命令行（command line）和图形界面（GUI，借助Eclipse* IDE或xxgdb）两种方式进行调试。

\sphinxAtStartPar
图形界面的GDB调试器相对简单，本手册主要介绍基于命令行的GDB调试器。基于命令行的启动方式主要有如下几种：
\begin{itemize}
\item {} 
\sphinxAtStartPar
最常用的方式是只跟程序名为参数，启动调试程序：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gdb program}}

\item {} 
\sphinxAtStartPar
启动应用程序及以前其出错时生成的core文件：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gdb program core}}

\item {} 
\sphinxAtStartPar
利用运行程序的进程号吸附到运行中程序进行调试：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gdb program 1234}}

\item {} 
\sphinxAtStartPar
如果需要调试的程序有参数，那么需要添加–args参数：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gdb \sphinxhyphen{}\sphinxhyphen{}args gcc \sphinxhyphen{}O2 \sphinxhyphen{}c foo.c}}

\item {} 
\sphinxAtStartPar
采用静默方式启动，不打印启动后的版权信息等：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gdb \sphinxhyphen{}\sphinxhyphen{}silent}}

\item {} 
\sphinxAtStartPar
仅显示帮助信息等：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gdb \sphinxhyphen{}\sphinxhyphen{}help}}

\end{itemize}


\subsection{选择启动时文件}
\label{\detokenize{debug/debug:id2}}
\sphinxAtStartPar
当GDB启动的时候，它读取除选项之外的任何参数用于指定可执行程序文件和core文件（或进程号），这与分别采用\sphinxhyphen{}se和\sphinxhyphen{}c（或\sphinxhyphen{}p）参数类似（gdb读取参数时，如第一个参数没有关联选项标记，那么等价于跟着\sphinxhyphen{}se选项之后的参数，如第二个参数没有关联选项标记，那么等价于跟着\sphinxhyphen{}c/\sphinxhyphen{}p选项之后的参数）。如果第二个参数以十进制数字开始，那么gdb尝试将其作为进程号并进行吸附，如果失败，则尝试作为core文件打开。如果以数字开始的core文件，那么可以在此之前添加./以防止被认为是进程号，例如./12345。很多选项同时具有长格式和短格式两种格式，如果采用了截断的长格式选项，且长度足够避免歧义，那么也可以被重新辨认为长格式。（如果你喜欢，可以采用–而不是\sphinxhyphen{}来标记选项参数）。
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}symbols file、\sphinxhyphen{}s file：从文件file中读取符号表。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}exec file、\sphinxhyphen{}e file：适当时采用文件file作为可执行程序，并且与core dump文件关联时用于检查纯数据。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}se file：从文件file中读取符号表，并且将其作为可执行文件。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}core file、\sphinxhyphen{}c file：将文件file作为core dump文件进行检查。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}pid number、\sphinxhyphen{}p number：将附带的命令吸附到进程号number。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}command file、\sphinxhyphen{}x file：指定启动后执行的命令文件file，文件file中保存一系列命令，启动后会顺序执行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}eval\sphinxhyphen{}command command、\sphinxhyphen{}ex command：执行单个gdb命令，此选项可以多次使用以多次调用命令。需要时，此选项也许与\sphinxhyphen{}command交替，如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gdb \sphinxhyphen{}ex 'target sim' \sphinxhyphen{}ex 'load' \sphinxhyphen{}x setbreakpoints \sphinxhyphen{}ex 'run' a.out}}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}init\sphinxhyphen{}command file、\sphinxhyphen{}ix file：从文件file中加载并执行命令，此过程在加载inferior %
\begin{footnote}[1]\sphinxAtStartFootnote
GDB采用对象表示每个程序执行状态，这个对象被称为inferior。典型的，一个inferior对应一个进程，但是更通常的是对应一个没有进程的目标。inferior有可能在进程执行之前生成，并且可以在进程停止后驻留。inferior具有独有的与进程号不同的标志符。尽管一些嵌入的目标也许具有多个运行在单个地址空间内不同部分的多个inferior，但通常每个inferior具有自己隔离的地址空间。反过来，每个inferior又有多个线程运行它。在GDB中可以用info
inferiors查看。
%
\end{footnote} 之前（但在加载gdbinit文件之后）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}init\sphinxhyphen{}eval\sphinxhyphen{}command command、\sphinxhyphen{}iex command：在加载inferior之前（但在加载gdbinit文件之后）执行命令command。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}directory directory、\sphinxhyphen{}d directory：添加目录directory到源文件和脚本文件的搜索目录

\end{itemize}


\subsection{记录日志}
\label{\detokenize{debug/debug:id4}}
\sphinxAtStartPar
可以采用以下方式记录日志等，启动GDB后执行：
\begin{itemize}
\item {} 
\sphinxAtStartPar
启用日志：\sphinxcode{\sphinxupquote{set logging on}}

\item {} 
\sphinxAtStartPar
关闭日志：\sphinxcode{\sphinxupquote{set logging off}}

\item {} 
\sphinxAtStartPar
记录日志到文件file（默认为gdb.txt）：\sphinxcode{\sphinxupquote{set logging file file}}

\item {} 
\sphinxAtStartPar
设定日志是否覆盖原有文件（默认为追加）：\sphinxcode{\sphinxupquote{set logging overwrite {[}on|off{]}}}

\item {} 
\sphinxAtStartPar
设定日志是否重定向（默认为显示在终端及文件中）：\sphinxcode{\sphinxupquote{set logging redirect {[}on|off{]}}}

\item {} 
\sphinxAtStartPar
显示当前日志设置：\sphinxcode{\sphinxupquote{show logging}}

\end{itemize}


\section{退出GDB}
\label{\detokenize{debug/debug:id5}}
\sphinxAtStartPar
退出调试器，在GDB内部命令执行完后的命令行，输入以下两者之一：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quit}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<ctrl+d>}}

\end{itemize}


\section{准备所需要调试的程序}
\label{\detokenize{debug/debug:id6}}

\subsection{准备调试代码源代码}
\label{\detokenize{debug/debug:id7}}
\sphinxAtStartPar
调试程序时，一般无需修改程序源代码，但是在程序中建议做如下改变：
\begin{itemize}
\item {} 
\sphinxAtStartPar
如果程序运行后，利用调试器难于终止，请设置一个初始停止点；

\item {} 
\sphinxAtStartPar
在源代码增加一些断言，以便帮助定位错误。

\end{itemize}


\subsection{准备编译器和链接器环境}
\label{\detokenize{debug/debug:id8}}
\sphinxAtStartPar
调试信息被编译器存储在.o文件。信息的级别和格式由编译器选项控制。

\sphinxAtStartPar
对于Intel C/C++ Fortran编译器，采用\sphinxhyphen{}g或\sphinxhyphen{}debug选项，例如：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{icc \sphinxhyphen{}g hello.c}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{icpc \sphinxhyphen{}g hello.cpp}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}g hello.f90}}

\end{itemize}

\sphinxAtStartPar
对于GCC编译器，采用\sphinxhyphen{}g选项。对于一些较老版本的GCC，此选项也许会产生DWARF\sphinxhyphen{}1标准的调试信息，如果这样，请使用\sphinxhyphen{}gdwarf\sphinxhyphen{}2选项，例如：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}gdwarf\sphinxhyphen{}2 hello.c}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{g++ \sphinxhyphen{}gdwarf\sphinxhyphen{}2 hello.cpp}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gfortran \sphinxhyphen{}gdwarf\sphinxhyphen{}2 hello.f90}}

\end{itemize}

\sphinxAtStartPar
调试信息将通过\sphinxcode{\sphinxupquote{ld}}命令导入到a.out（可执行程序）或.so（共享库）文件中。

\sphinxAtStartPar
如果是在调试优化编译的代码，采用\sphinxhyphen{}g选项将自动增加\sphinxhyphen{}O0选项。

\sphinxAtStartPar
请参看调试优化编译的代码部分中关于\sphinxhyphen{}g和相关扩展调试选项及它们的与优化之间的关系。


\subsection{调试优化编译的代码}
\label{\detokenize{debug/debug:id9}}
\sphinxAtStartPar
GDB调试器可以通过使用\sphinxhyphen{}g参数帮助调试优化编译的程序。但是关于此程序的信息也许并不准确，尤其是变量的地址和值经常没有被正确报告，这是因为通用调试信息模式无法全部表示\sphinxhyphen{}O1、\sphinxhyphen{}O2、\sphinxhyphen{}O3及其它优化选项的复杂性。

\sphinxAtStartPar
为了避免此限制，采用Intel编译器编译程序时在所需的\sphinxhyphen{}O1、\sphinxhyphen{}O2或\sphinxhyphen{}O3优化选项同时指明\sphinxhyphen{}g和\sphinxhyphen{}debug扩展选项。这会产生具有更多高级但更少通用支持的调试信息，主要激活以下：
\begin{itemize}
\item {} 
\sphinxAtStartPar
给出变量的正确地址和值，不管其是在寄存器或不同时间在不同地址时。注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
在程序中，一些变量可能被优化掉或转换成不同类型的数据，或其地址没有在所有点都被记录。在这些情形下，打印变量时将显示无值。

\item {} 
\sphinxAtStartPar
否则，这些值和地址将正确，但这些寄存器没有地址，调试器中\sphinxcode{\sphinxupquote{print \&i}}命令将打印一条警告。

\item {} 
\sphinxAtStartPar
尽管\sphinxcode{\sphinxupquote{break main}}命令通常将在程序开始处理后停止，但程序大多数变量和参数在程序的开始处理和结束处理时是未定义的。

\end{itemize}

\item {} 
\sphinxAtStartPar
在堆栈追踪中显示内联函数，这通过使用inline关键词识别。注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
只有在堆栈顶端和通常（非内联）调用的函数显示指令指针，其原因在于其它函数与其调用的内联函数共享硬件定义的堆栈帧。

\item {} 
\sphinxAtStartPar
返回指令将只返回对那些采用调用指令时是非内联调用函数的控制，其原因在于内联调用没有定义返回地址。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{up}}、\sphinxcode{\sphinxupquote{down}}和\sphinxcode{\sphinxupquote{call}}命令以通常方式工作。

\end{itemize}

\item {} 
\sphinxAtStartPar
允许在内联函数中设置断点。

\end{itemize}


\subsection{准备所需要调试的并行程序}
\label{\detokenize{debug/debug:id10}}
\sphinxAtStartPar
编译时必须用\sphinxhyphen{}g等调试参数编译源代码才可以使用GDB调试器特性，比如分析共享数据或在重入函数调用中停止。

\sphinxAtStartPar
为了使用并行调试特性，需要：
\begin{itemize}
\item {} 
\sphinxAtStartPar
如果存在makefile编译配置文件，请对它进行编辑。

\item {} 
\sphinxAtStartPar
在命令行添加编译器选项\sphinxhyphen{}debug parallel（Intel编译器针对OpenMP多线程）。

\item {} 
\sphinxAtStartPar
重编译程序。

\end{itemize}


\subsection{编译所要调试的程序}
\label{\detokenize{debug/debug:id11}}
\sphinxAtStartPar
下面以常做为例子的hello程序为例介绍。
\begin{itemize}
\item {} 
\sphinxAtStartPar
hello.c例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello World!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
编译：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{icc \sphinxhyphen{}g helloworld.c \sphinxhyphen{}o helloworld}}

\item {} 
\sphinxAtStartPar
hello.f90例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{program }\PYG{n}{main}
\PYG{k}{print}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}Hello World!\PYGZdq{}}
\PYG{k}{end }\PYG{k}{program }\PYG{n}{main}
\end{sphinxVerbatim}

\sphinxAtStartPar
编译：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}debug \sphinxhyphen{}O0 helloworld.f90 \sphinxhyphen{}o helloworld}}

\end{itemize}


\section{开始调试程序}
\label{\detokenize{debug/debug:id12}}
\sphinxAtStartPar
启动调试：\sphinxcode{\sphinxupquote{gdb helloworld}}。更多启动方式参见{\hyperref[\detokenize{debug/debug:gdbstart}]{\emph{{[}gdbstart{]}}}}。


\subsection{显示源代码}
\label{\detokenize{debug/debug:id13}}
\sphinxAtStartPar
在调试器启动后的命令行中输入\sphinxcode{\sphinxupquote{list}}命令可以显示源代码，如输入\sphinxcode{\sphinxupquote{list main}}，将显示main函数的代码。


\subsection{运行程序}
\label{\detokenize{debug/debug:id14}}
\sphinxAtStartPar
在命令行中输入\sphinxcode{\sphinxupquote{run}}，将开始运行程序。


\subsection{设置和删除断点}
\label{\detokenize{debug/debug:id15}}\begin{itemize}
\item {} 
\sphinxAtStartPar
设置断点：
\begin{itemize}
\item {} 
\sphinxAtStartPar
输入以下命令：\sphinxcode{\sphinxupquote{break main}}

\sphinxAtStartPar
此时在程序main处设置了一个断点。

\item {} 
\sphinxAtStartPar
输入\sphinxcode{\sphinxupquote{run}}再次运行程序

\sphinxAtStartPar
应用将停止在设置的断点处。

\end{itemize}

\item {} 
\sphinxAtStartPar
删除断点：
\begin{itemize}
\item {} 
\sphinxAtStartPar
列出所有设置的断点ID号：\sphinxcode{\sphinxupquote{info breakpoints}}

\sphinxAtStartPar
调试器将显示所有存在的断点。

\item {} 
\sphinxAtStartPar
指明所要删除的断点ID号。如果从开始调试后没有设置其它断点，那么只有1个断点，其ID号为1。

\item {} 
\sphinxAtStartPar
删除此断点：\sphinxcode{\sphinxupquote{delete breakpoint 1}}

\sphinxAtStartPar
那么将删除设置断点1。

\item {} 
\sphinxAtStartPar
重新运行程序。

\sphinxAtStartPar
那么程序将运行并显示“Hello World!”，并退出程序。

\end{itemize}

\end{itemize}


\subsection{控制进程环境}
\label{\detokenize{debug/debug:id16}}
\sphinxAtStartPar
用户可以：1、对进程的环境变量进行设置或者取消设置以便在将来使用；2、设置与当前调试器环境和启动调试器的shell不同的环境。设置的变量将影响后续调试的新进程。环境命令不影响当前运行进程。设置的环境变量不改变或显示调试器的环境变量，它们只影响新产生的进程。
\begin{itemize}
\item {} 
\sphinxAtStartPar
显示当前集的所有环境变量：\sphinxcode{\sphinxupquote{show environment}}

\item {} 
\sphinxAtStartPar
增加或改变环境变量：\sphinxcode{\sphinxupquote{set environment}}

\item {} 
\sphinxAtStartPar
取消一个环境变量：\sphinxcode{\sphinxupquote{unset environment}}

\end{itemize}

\sphinxAtStartPar
注意：GDB调试器没有命令可以简单回到调试器启动时的环境变量的初始状态，用户必须正确设置和取消环境变量。


\subsection{执行一行代码}
\label{\detokenize{debug/debug:id17}}
\sphinxAtStartPar
如果源代码当前行是函数调用，那么可以步入(step into)或者跨越(step over)此函数。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{step}}命令：应用程序执行一行代码，如果此行是函数调用，那么应用程序步入到函数中，即不执行完此函数调用。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{next}}命令：应用程序执行一行代码，如果此行是函数调用，那么应用程序跨越此函数，即执行完此函数调用。

\end{enumerate}


\subsection{执行代码直到}
\label{\detokenize{debug/debug:id18}}
\sphinxAtStartPar
运行代码直到某行或某个表达式，可用\sphinxcode{\sphinxupquote{until}}命令。


\subsection{执行一行汇编指令}
\label{\detokenize{debug/debug:id19}}
\sphinxAtStartPar
如果应用的当前指令为函数调用，那么可以步入或者跨越此函数。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stepi}}命令：应用程序执行一行汇编指令，如果此行指令是函数调用，那么应用程序步入到函数中。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nexti}}命令：应用程序执行一行汇编指令，如果此行指令当前行是跳出或调用，那么应用程序跨越过它。

\end{enumerate}


\subsection{显示变量或表达式值}
\label{\detokenize{debug/debug:id20}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{print}}命令可以显示变量值或表达式的值。如：
\begin{itemize}
\item {} 
\sphinxAtStartPar
显示变量val2的当前值：\sphinxcode{\sphinxupquote{print val2}}

\item {} 
\sphinxAtStartPar
显示表达式val2*2的值：\sphinxcode{\sphinxupquote{print val2*2}}

\end{itemize}


\section{传递命令给调试器}
\label{\detokenize{debug/debug:id21}}

\subsection{命令、文件名和变量补全}
\label{\detokenize{debug/debug:id22}}
\sphinxAtStartPar
GDB调试器支持命令、文件名和变量的补全。在GDB调试器命令行中开始键入一个命令、文件名或变量名，然后按Tab键。如果有不只一个备选，调试器会发出铃声。再一次按Tab键，将列出备选。

\sphinxAtStartPar
利用单引号和双引号影响可能备选集。利用单引号填充C++名字，包含特殊字符“:”、“\(<\)”、“\(>\)”、“(”、“)”等。利用双引号告诉调试器在文件名中查看备选。


\subsection{自定义命令}
\label{\detokenize{debug/debug:id23}}
\sphinxAtStartPar
GDB调试器支持用户自定义命令。

\sphinxAtStartPar
用户定义的命令支持在定义体内包含if、while、loop\_break和loop\_continue命令。用户定义的命令最多可有10个参数，以空白分割。参数名依次为\$arg0、\$arg1、\$arg2、\(\dots\)、\$arg9。参数总数存储在\$argc中。

\sphinxAtStartPar
其步骤为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
输入define commandname

\item {} 
\sphinxAtStartPar
每行输入一个命令

\item {} 
\sphinxAtStartPar
输入end

\end{itemize}


\section{调试并行程序}
\label{\detokenize{debug/debug:id24}}

\subsection{调试OpenMP等多线程程序}
\label{\detokenize{debug/debug:openmp}}
\sphinxAtStartPar
一个单独的程序可以有不止一个线程执行，但一般来说，一个程序的线程除了它们共享一个地址空间外，还类似于多个进程。另一方面，每个县城具有自己的寄存器和执行堆栈，也许还占有私有内存。

\sphinxAtStartPar
线程是进程内部单个、串行控制流。每个线程包含单个执行点。线程在单个地址空间中（共享）执行；因此，进程的线程可以读写相同的内存地址。

\sphinxAtStartPar
多个进程执行时，当用户需要关注某个进程时，它却恼人地或不切实际地枚举所有进程。

\sphinxAtStartPar
当为了设置代码断点而定义停止线程和线程过滤器时，用户需要定义线程集。

\sphinxAtStartPar
用户可以以紧凑方式指定进程或线程集，集可包含一个或多个范围。用户可以对每个进程集执行普通操作，调试器变量既可以存储集也可以存储范围以便操作、引用和查看。
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{info threas}}：查看线程集

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{thread}}：在线程间进行切换，如thread 2

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{thread apply}}：对线程应用特定命令，如thread apply 2 break 164

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{thread apply all}}：对所有线程应用特定命令

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{thread find}}：发现满足某些特定条件的线程

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{thread name}}：给当前线程设定名字

\end{itemize}

\sphinxAtStartPar
注意：线程与当前执行到多线程程序中的位置有关系，在单线程执行的地方只显示一个线程，在多线程执行的地方会显示多线程。

\sphinxAtStartPar
对各线程就可采用普通GDB命令对单个进程分别进行调试。


\subsection{调试MPI并行应用}
\label{\detokenize{debug/debug:mpi}}
\sphinxAtStartPar
采用Intel MPI时，可以采用类似下面命令调用GDB调试器：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}gdb \sphinxhyphen{}n 4 ./tmissem\sphinxhyphen{}dbg}}

\sphinxAtStartPar
之后可以像单进程程序一样调试程序。

\sphinxAtStartPar
也可以吸附到一个运行中的程序：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}n 4 \sphinxhyphen{}gdba <pid>}}

\sphinxAtStartPar
其中<pid>为MPI进程的进程号。

\sphinxAtStartPar
如：\sphinxcode{\sphinxupquote{mpirun \sphinxhyphen{}gdb \sphinxhyphen{}n 4 ./tmissem\sphinxhyphen{}dbg}}显示：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpigdb}\PYG{p}{:} \PYG{n}{np} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{mpigdb}\PYG{p}{:} \PYG{n}{attaching} \PYG{n}{to} \PYG{l+m+mi}{13526} \PYG{o}{.}\PYG{o}{/}\PYG{n}{tmissem}\PYG{o}{\PYGZhy{}}\PYG{n}{dbg} \PYG{n}{tc4600v4}
\PYG{n}{mpigdb}\PYG{p}{:} \PYG{n}{attaching} \PYG{n}{to} \PYG{l+m+mi}{13527} \PYG{o}{.}\PYG{o}{/}\PYG{n}{tmissem}\PYG{o}{\PYGZhy{}}\PYG{n}{dbg} \PYG{n}{tc4600v4}
\PYG{n}{mpigdb}\PYG{p}{:} \PYG{n}{attaching} \PYG{n}{to} \PYG{l+m+mi}{13528} \PYG{o}{.}\PYG{o}{/}\PYG{n}{tmissem}\PYG{o}{\PYGZhy{}}\PYG{n}{dbg} \PYG{n}{tc4600v4}
\PYG{n}{mpigdb}\PYG{p}{:} \PYG{n}{attaching} \PYG{n}{to} \PYG{l+m+mi}{13529} \PYG{o}{.}\PYG{o}{/}\PYG{n}{tmissem}\PYG{o}{\PYGZhy{}}\PYG{n}{dbg} \PYG{n}{tc4600v4}
\end{sphinxVerbatim}

\sphinxAtStartPar
上面np=4显示使用了4个进程启动MPI程序，13526之类的为系统MPI程序进程号（不是MPI rank号），./tmissem\sphinxhyphen{}dbg为应用程序，tc4600v4为对应节点。

\sphinxAtStartPar
查看源码，执行\sphinxcode{\sphinxupquote{list}}：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[2,3]   200 implicit none
[0,1]   200 implicit none
[2,3]   201 include \PYGZsq{}mpif.h\PYGZsq{}
[0,1]   201 include \PYGZsq{}mpif.h\PYGZsq{}
[2,3]   202 integer nmstep,ik,NStep,jk,i,PNum
[0,1]   202 integer nmstep,ik,NStep,jk,i,PNum
[2,3]   203 !real pathxyz(3,100000),t\PYGZus{}p(3) !path
[0,1]   203 !real pathxyz(3,100000),t\PYGZus{}p(3) !path
[2,3]   204 real    Time\PYGZus{}S
[0,1]   204 real    Time\PYGZus{}S
[2,3]   205 real(8)  T3
[0,1]   205 real(8)  T3
[2,3]   206 character*2 resf
[0,1]   206 character*2 resf
[2,3]   207
[0,1]   207
[2,3]   208 call MPI\PYGZus{}Init(ierr)
[0,1]   208 call MPI\PYGZus{}Init(ierr)
\end{sphinxVerbatim}

\sphinxAtStartPar
上面{[}0\sphinxhyphen{}3{]}、{[}0,1{]}之类的为MPI进程编号，表示改行后面显示的内容为这些进程的。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{z}}命令可设置对某MPI进程进行操作，如\sphinxcode{\sphinxupquote{z 0,1,3}}命令设置当前进程集包含进程0、1、3：

\sphinxAtStartPar
mpigdb: set active processes to 0 1 3

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{z all}}切换到全部进程。

\sphinxAtStartPar
之后对各进程就可采用普通GDB命令对单个进程分别进行调试。

\sphinxstepscope


\chapter{Intel MKL数值函数库}
\label{\detokenize{intel-mkl/intel-mkl:intel-mkl}}\label{\detokenize{intel-mkl/intel-mkl::doc}}
\sphinxAtStartPar
本系统上安装的数值函数库主要有Intel核心数学库(Math Kernel Library, MKL)，用户可以直接调用，以提高性能、加快开发。

\sphinxAtStartPar
当前安装的Intel MKL版本为Intel Parallel Studio XE 2018、2019和2020版编译器自带的，安装在。在BASH下可以通过运行\sphinxcode{\sphinxupquote{module load}}选择Intel编译器时设置，或者在之类的环境变量设置文件中添加类似下面代码设置Intel MKL所需的环境变量\sphinxcode{\sphinxupquote{INCLUDE}}、\sphinxcode{\sphinxupquote{LD\_LIBRARY\_PATH}}和\sphinxcode{\sphinxupquote{MANPATH}}等：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
. /opt/intel/2020/mkl/bin/mklvars.sh intel64
\end{sphinxVerbatim}


\section{Intel MKL主要内容}
\label{\detokenize{intel-mkl/intel-mkl:id1}}
\sphinxAtStartPar
Intel MKL主要包含如下内容：
\begin{itemize}
\item {} 
\sphinxAtStartPar
基本线性代数子系统库（BLAS, level 1, 2, 3）和线性代数库（LAPACK）：提供向量、向量\sphinxhyphen{}矩阵、矩阵\sphinxhyphen{}矩阵操作。

\item {} 
\sphinxAtStartPar
ScaLAPACK分布式线性代数库：含基础线性代数通信子程序（Basic Linear Algebra Communications Subprograms, BLACS）和并行基础线性代数子程序（Parallel Basic Linear Algebra Subprograms, PBLAS）

\item {} 
\sphinxAtStartPar
PARDISO直接离散算子：一种迭代离散算子，支持用于求解方程的离散系统的离散BLAS (level 1, 2, and 3)子函数，并提供可用于集群系统的分布式版本的PARDISO。

\item {} 
\sphinxAtStartPar
快速傅立叶变换方程（Fast Fourier transform, FFT）：支持1、2或3维，支持混合基数（不局限与2的次方），并有分布式版本。

\item {} 
\sphinxAtStartPar
向量数学库（Vector Math Library, VML）： 提供针对向量优化的数学操作。

\item {} 
\sphinxAtStartPar
向量统计库（Vector Statistical Library, VSL）：提供高性能的向量化随机数生成算子，可用于一些几率分布、剪辑和相关例程和汇总统计功能。

\item {} 
\sphinxAtStartPar
数据拟合库（Data Fitting Library）：提供基于样条函数逼近、函数的导数和积分，及搜索。

\item {} 
\sphinxAtStartPar
扩展本征解算子（Extended Eigensolver）：基于FEAST的本征值解算子的共享内存版本的本征解算子。

\end{itemize}


\section{Intel MKL目录内容}
\label{\detokenize{intel-mkl/intel-mkl:id2}}
\sphinxAtStartPar
Intel MKL的主要目录内容见下表 。


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\begin{longtable}[c]{|*{2}{\X{1}{2}|}}
\sphinxthelongtablecaptionisattop
\caption{Intel MKL目录内容\strut}\label{\detokenize{intel-mkl/intel-mkl:id23}}\\*[\sphinxlongtablecapskipadjust]
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
目录
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内容
\\
\sphinxmidrule
\endfirsthead

\multicolumn{2}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} 接上页}}%
}\\
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
目录
&\sphinxstyletheadfamily 
\sphinxAtStartPar
内容
\\
\sphinxmidrule
\endhead

\sphinxbottomrule
\multicolumn{2}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{续下页}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
<mkl\_dir>
&
\sphinxAtStartPar
MKL主目录，如 \sphinxcode{\sphinxupquote{/opt/intel/2020/mkl}}
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/benchmarks/linpack
&
\sphinxAtStartPar
包含OpenMP版的LINPACK的基准程序
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/benchmarks/mp\_linpack
&
\sphinxAtStartPar
包含MPI版的LINPACK的基准程序
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/bin
&
\sphinxAtStartPar
包含设置MKL环境变量的脚本
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/bin/ia32
&
\sphinxAtStartPar
包含针对IA\sphinxhyphen{}32架构设置MKL环境变量的脚本
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/bin/intel64
&
\sphinxAtStartPar
包含针对Intel64架构设置MKL环境变量的脚本
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/examples
&
\sphinxAtStartPar
一些例子，可以参考学习
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/include
&
\sphinxAtStartPar
含有INCLUDE文件
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/include/ia32
&
\sphinxAtStartPar
含有针对ia32 Intel编译器的Fortran 95 .mod文件
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir >/include/intel64/ilp64
&
\sphinxAtStartPar
含有针对Intel64 Intel编译器ILP64接口 %
\begin{footnote}[3]\sphinxAtStartFootnote
ILP64接口和LP64接口的区别参见{\hyperref[\detokenize{intel-mkl/intel-mkl:lp}]{\emph{4.3.3}}}使用接口库链接。
%
\end{footnote} 的Fortran  95 .mod文件
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/include/intel64/lp64
&
\sphinxAtStartPar
含有针对Intel64 Intel编译器LP64接口的Fortran 95 .mod文件
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/include/mic/ilp64
&
\sphinxAtStartPar
含针对MIC架构ILP64接口的Fortran 95 .mod文件，本系统未配置MIC
\\
\sphinxhline
\sphinxAtStartPar
<mk \_dir>/include/mic/lp64l
&
\sphinxAtStartPar
含针对MIC架构LP64接口的Fortran 95 .mod文件，本系统未配置MIC
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/include/fftw
&
\sphinxAtStartPar
含有FFTW2和3的INCLUDE文件
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/interfaces/blas95
&
\sphinxAtStartPar
包含BLAS的Fortran90封装及用于编译成库的makefile
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/interfaces/LAPACK95
&
\sphinxAtStartPar
包含LAPACK的Fortran 90封装及用于编译成库的makefile
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/interfaces/fftw2xc
&
\sphinxAtStartPar
包含2.x版FFTW(C接口)封装及用于编译成库的makefile
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/interfaces/fftw2xf
&
\sphinxAtStartPar
包含2.x版FFTW(Fortran接口)封装及用于编译成库的makefile
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/interfaces/fftw2x\_cdft
&
\sphinxAtStartPar
包含2.x版集群FFTW(MPI接口)封装及用于编译成库的makefile
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/interfaces/fftw3xc
&
\sphinxAtStartPar
包含3.x版FFTW(C接口)封装及用于编译成库的makefile
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/interfaces/fftw3xf
&
\sphinxAtStartPar
包含3.x版FFTW(Fortran接口)封装及用于编译成库的makefile
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir >/interfaces/fftw3x\_cdft
&
\sphinxAtStartPar
包含3.x版集群FFTW(MPI接口)封装及用于编译成库的makefile
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir >/interfaces/fftw2x\_cdft
&
\sphinxAtStartPar
包含2.x版MPIFFTW(集群FFT)封装及用于编译成库的makefile
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/lib/ia32
&
\sphinxAtStartPar
包含IA32架构的静态库和共享目标文件
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/lib/intel64
&
\sphinxAtStartPar
包含EM64T架构的静态库和共享目标文件
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/lib/mic
&
\sphinxAtStartPar
用于MIC协处理器，本系统未配置MIC
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/tests
&
\sphinxAtStartPar
一些测试文件
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/tools
&
\sphinxAtStartPar
工具及插件
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/tools/builder
&
\sphinxAtStartPar
包含用于生成定制动态可链接库的工具
\\
\sphinxhline
\sphinxAtStartPar
<mkl\_dir>/../Documentation/en\_US/mkl
&
\sphinxAtStartPar
MKL文档目录
\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}


\section{链接Intel MKL}
\label{\detokenize{intel-mkl/intel-mkl:id4}}

\subsection{快速入门}
\label{\detokenize{intel-mkl/intel-mkl:id5}}

\subsubsection{利用\sphinxhyphen{}mkl编译器参数}
\label{\detokenize{intel-mkl/intel-mkl:mkl}}
\sphinxAtStartPar
Intel Composer XE编译器支持采用\sphinxhyphen{}mkl %
\begin{footnote}[4]\sphinxAtStartFootnote
是\sphinxhyphen{}mkl，不是\sphinxhyphen{}lmkl，其它编译器未必支持此\sphinxhyphen{}mkl选项。
%
\end{footnote} 参数链接Intel MKL：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mkl或\sphinxhyphen{}mkl=parallel：采用标准线程Intel MKL库链接；

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mkl=sequential：采用串行Intel MKL库链接；

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}mkl=cluster：采用Intel MPI和串行MKL库链接；

\item {} 
\sphinxAtStartPar
对Intel 64架构的系统，默认使用LP64接口链接程序。

\end{itemize}


\subsubsection{使用单一动态库}
\label{\detokenize{intel-mkl/intel-mkl:id7}}
\sphinxAtStartPar
可以通过使用Intel MKL Single Dynamic Library(SDL)来简化链接行。

\sphinxAtStartPar
为了使用SDL库，请在链接行上添加libmkl\_rt.so。例如

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{icc application.c \sphinxhyphen{}lmkl\_rt}}

\sphinxAtStartPar
SDL使得可以在运行时选择Intel MKL的接口和线程。默认使用SDL链接时提供：
\begin{itemize}
\item {} 
\sphinxAtStartPar
对Intel 64架构的系统，使用LP64接口链接程序；

\item {} 
\sphinxAtStartPar
Intel线程。

\end{itemize}

\sphinxAtStartPar
如需要使用其它接口或改变线程性质，含使用串行版本Intel MKL等，需要使用函数或环境变量来指定选择，参见{\hyperref[\detokenize{intel-mkl/intel-mkl:dsi}]{\emph{4.3.2}}}动态选择接口和线程层部分。


\subsubsection{选择所需库进行链接}
\label{\detokenize{intel-mkl/intel-mkl:id8}}
\sphinxAtStartPar
选择所需库进行链接，一般需要：
\begin{itemize}
\item {} 
\sphinxAtStartPar
从接口层(Interface layer)和线程层(Threading layer)各选择一个库；

\item {} 
\sphinxAtStartPar
从计算层(Computational layer)和运行时库(run\sphinxhyphen{}time libraries, RTL)添加仅需的库。

\end{itemize}

\sphinxAtStartPar
链接应用程序时的对应库参见下表。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
接口层
&\sphinxstyletheadfamily 
\sphinxAtStartPar
线程层
&\sphinxstyletheadfamily 
\sphinxAtStartPar
计算层
&\sphinxstyletheadfamily 
\sphinxAtStartPar
运行库
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
IA\sphinxhyphen{}32架构，静态链接
&
\sphinxAtStartPar
libmkl\_intel.a
&
\sphinxAtStartPar
libmkl\_intel\_thread.a
&
\sphinxAtStartPar
libmkl\_core.a
&
\sphinxAtStartPar
libiomp5.so
\\
\sphinxhline
\sphinxAtStartPar
IA\sphinxhyphen{}32架构，动态链接
&
\sphinxAtStartPar
libmkl\_intel.so
&
\sphinxAtStartPar
libmkl\_intel\_thread.so
&
\sphinxAtStartPar
libmkl\_core.so
&
\sphinxAtStartPar
libiomp5.so
\\
\sphinxhline
\sphinxAtStartPar
Intel 64架构，静态链接
&
\sphinxAtStartPar
libmkl\_intel\_lp64.a
&
\sphinxAtStartPar
libmkl\_intel\_thread.a
&
\sphinxAtStartPar
libmkl\_core.a
&
\sphinxAtStartPar
libiomp5.so
\\
\sphinxhline
\sphinxAtStartPar
Intel64架构，动态链接
&
\sphinxAtStartPar
libmkl\_intel\_lp64.so
&
\sphinxAtStartPar
libmkl\_intel\_thread.so
&
\sphinxAtStartPar
libmkl\_core.so
&
\sphinxAtStartPar
libiomp5.so
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
SDL会自动链接接口、线程和计算库，简化了链接处理。下表列出的是采用SDL动态链接时的Intel MKL库。参见{\hyperref[\detokenize{intel-mkl/intel-mkl:dsi}]{\emph{4.3.2}}}动态选择接口和线程层部分，了解如何在运行时利用函数调用或环境变量设置接口和线程层。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\sphinxtoprule

\sphinxAtStartPar

&\sphinxstyletheadfamily 
\sphinxAtStartPar
SDL
&\sphinxstyletheadfamily 
\sphinxAtStartPar
运行时库
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
IA\sphinxhyphen{}32和Intel 64架构
&
\sphinxAtStartPar
libmkl\_rt.so
&
\sphinxAtStartPar
libiomp5.so
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsubsection{使用链接行顾问}
\label{\detokenize{intel-mkl/intel-mkl:id9}}
\sphinxAtStartPar
Intel提供了网页方式的链接行顾问帮助用户设置所需要的MKL链接参数。访问\sphinxurl{http://software.intel.com/en-us/articles/intel-mkl-link-line-advisor}，按照提示输入所需要信息即可获取链接Intel MKL时所需要的参数。


\subsubsection{使用命令行链接工具}
\label{\detokenize{intel-mkl/intel-mkl:id10}}
\sphinxAtStartPar
使用Intel MKL提供的命令行链接工具可以简化使用Intel MKL编译程序。本工具不仅可以给出所需的选项、库和环境变量，还可执行编译和生成可执行程序。\sphinxcode{\sphinxupquote{mkl\_link\_tool}}命令安装在，主要有三种模式：
\begin{itemize}
\item {} 
\sphinxAtStartPar
查询模式：返回所需的编译器参数、库或环境变量等：
\begin{itemize}
\item {} 
\sphinxAtStartPar
获取Intel MKL库：\sphinxcode{\sphinxupquote{mkl\_link\_tool \sphinxhyphen{}libs {[}Intel MKL Link Tool options{]}}}

\item {} 
\sphinxAtStartPar
获取编译参数：\sphinxcode{\sphinxupquote{mkl\_link\_tool \sphinxhyphen{}opts {[}Intel MKL Link Tool options{]}}}

\item {} 
\sphinxAtStartPar
获取编译环境变量：\sphinxcode{\sphinxupquote{mkl\_link\_tool \sphinxhyphen{}env {[}Intel MKL Link Tool options{]}}}

\end{itemize}

\item {} 
\sphinxAtStartPar
编译模式：可编译程序。
\begin{itemize}
\item {} 
\sphinxAtStartPar
用法：\sphinxcode{\sphinxupquote{mkl\_link\_tool {[}options{]} <compiler> {[}options2{]} file1 {[}file2 ...{]}}}

\end{itemize}

\item {} 
\sphinxAtStartPar
交互模式：采用交互式获取所需要的参数等。
\begin{itemize}
\item {} 
\sphinxAtStartPar
用法：\sphinxcode{\sphinxupquote{mkl\_link\_tool \sphinxhyphen{}interactive}}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
参见\sphinxurl{http://software.intel.com/en-us/articles/mkl-command-line-link-tool}。


\subsection{链接举例}
\label{\detokenize{intel-mkl/intel-mkl:id11}}

\subsubsection{在Intel 64架构上链接}
\label{\detokenize{intel-mkl/intel-mkl:intel-64}}
\sphinxAtStartPar
在这些例子中：
\begin{itemize}
\item {} 
\sphinxAtStartPar
MKLPATH=\$MKLROOT/lib/intel64

\item {} 
\sphinxAtStartPar
MKLINCLUDE=\$MKLROOT/include

\end{itemize}

\sphinxAtStartPar
如果已经设置好环境变量，那么在所有例子中可以略去\sphinxhyphen{}I\$MKLINCLUDE，在所有动态链接的例子中可以略去\sphinxhyphen{}L\$MKLPATH。
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用LP64接口的并行Intel MKL库静态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}lp64.a \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}thread.a \PYG{l+s+se}{\PYGZbs{}}
\PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}core.a \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}end\PYGZhy{}group \PYGZhy{}liomp5 \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用LP64接口的并行Intel MKL库动态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}lmkl\PYGZus{}intel\PYGZus{}lp64 \PYGZhy{}lmkl\PYGZus{}intel\PYGZus{}thread \PYGZhy{}lmkl\PYGZus{}core \PYGZhy{}liomp5 \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用LP64接口的串行Intel MKL库静态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}lp64.a \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}sequential.a \PYG{l+s+se}{\PYGZbs{}}
\PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}core.a \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}end\PYGZhy{}group \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用LP64接口的串行Intel MKL库动态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}lmkl\PYGZus{}intel\PYGZus{}lp64 \PYGZhy{}lmkl\PYGZus{}sequential \PYGZhy{}lmkl\PYGZus{}core \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用ILP64接口的并行Intel MKL库动态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}ilp64.a \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}thread.a \PYG{l+s+se}{\PYGZbs{}}
\PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}core.a \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}end\PYGZhy{}group \PYGZhy{}liomp5 \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用ILP64接口的并行Intel MKL库动态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}lmkl\PYGZus{}intel\PYGZus{}ilp64 \PYGZhy{}lmkl\PYGZus{}intel\PYGZus{}thread \PYGZhy{}lmkl\PYGZus{}core \PYGZhy{}liomp5 \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用串行或并行（调用函数或设置环境变量选择线程或串行模式，并设置接口）Intel MKL库动态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}lmkl\PYGZus{}rt
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用Fortran 95 LAPACK接口和LP64接口的并行Intel MKL库静态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE}/intel64/lp64 \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}lmkl\PYGZus{}lapack95\PYGZus{}lp64 \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}lp64.a \PYG{l+s+se}{\PYGZbs{}}
\PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}thread.a \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}core.a \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}end\PYGZhy{}group \PYGZhy{}liomp5 \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用Fortran 95 BLAS接口和LP64接口的并行Intel MKL库静态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE}/intel64/lp64 \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}lmkl\PYGZus{}blas95\PYGZus{}lp64 \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}lp64.a \PYG{l+s+se}{\PYGZbs{}}
\PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}thread.a \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}core.a \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}end\PYGZhy{}group \PYGZhy{}liomp5 \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}


\subsubsection{在IA\sphinxhyphen{}32架构上链接}
\label{\detokenize{intel-mkl/intel-mkl:ia-32}}
\sphinxAtStartPar
在这些例子中：
\begin{itemize}
\item {} 
\sphinxAtStartPar
MKLPATH=\$MKLROOT/lib/ia32

\item {} 
\sphinxAtStartPar
MKLINCLUDE=\$MKLROOT/include

\end{itemize}

\sphinxAtStartPar
如果已经设置好环境变量，那么在所有例子中可以略去\sphinxhyphen{}I\$MKLINCLUDE，在所有动态链接的例子中可以略去\sphinxhyphen{}L\$MKLPATH。
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用并行Intel MKL库静态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel.a \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}thread.a \PYG{l+s+se}{\PYGZbs{}}
\PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}core.a \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}end\PYGZhy{}group \PYGZhy{}liomp5 \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用并行Intel MKL库动态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}lmkl\PYGZus{}intel \PYGZhy{}lmkl\PYGZus{}intel\PYGZus{}thread \PYGZhy{}lmkl\PYGZus{}core \PYGZhy{}liomp5 \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用串行Intel MKL库静态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel.a \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}sequential.a \PYG{l+s+se}{\PYGZbs{}}
\PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}core.a \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}end\PYGZhy{}group \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用串行Intel MKL库动态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYGZhy{}lmkl\PYGZus{}intel \PYGZhy{}lmkl\PYGZus{}sequential \PYGZhy{}lmkl\PYGZus{}core \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用串行或并行（调用mkl\_set\_threading\_layer函数或设置环境变量MKL\_THREADING\_LAYER选择线程或串行模式）Intel MKL库动态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}lmkl\PYGZus{}rt
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用Fortran 95 LAPACK接口和并行Intel MKL库静态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE}/ia32 \PYGZhy{}lmkl\PYGZus{}lapack95 \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel.a \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}thread.a
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用Fortran 95 BLAS接口和并行Intel MKL库静态链接myprog.f：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifort myprog.f \PYGZhy{}L\PYG{n+nv}{\PYGZdl{}MKLPATH} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE} \PYGZhy{}I\PYG{n+nv}{\PYGZdl{}MKLINCLUDE}/ia32 \PYGZhy{}lmkl\PYGZus{}blas95 \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}start\PYGZhy{}group \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel.a \PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}intel\PYGZus{}thread.a \PYG{l+s+se}{\PYGZbs{}}
\PYG{n+nv}{\PYGZdl{}MKLPATH}/libmkl\PYGZus{}core.a \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}end\PYGZhy{}group \PYGZhy{}liomp5 \PYGZhy{}lpthread \PYGZhy{}lm
\end{sphinxVerbatim}


\subsection{链接细节}
\label{\detokenize{intel-mkl/intel-mkl:id12}}

\subsubsection{在命令行上列出所需库链接}
\label{\detokenize{intel-mkl/intel-mkl:id13}}
\sphinxAtStartPar
注意：下面是动态链接的命令，如果想静态链接，需要将含有\sphinxhyphen{}l的库名用含有库文件的路径来代替，比如用\$MKLPATH/libmkl\_core.a代替\sphinxhyphen{}lmkl\_core，其中\$MKLPATH为用户定义的指向MKL库目录的环境变量。

\begin{DUlineblock}{0em}
\item[] 注：\sphinxcode{\sphinxupquote{{[}{]}}}内的表示可选，\sphinxcode{\sphinxupquote{|}}表示其中之一、\sphinxcode{\sphinxupquote{\{\}}}表示含有。
在静态链接时，在分组符号（如，\sphinxcode{\sphinxupquote{\sphinxhyphen{}Wl,\sphinxhyphen{}\sphinxhyphen{}start\sphinxhyphen{}group \$MKLPATH/libmkl\_cdft\_core.a \$MKLPATH/libmkl\_blacs\_}}
\item[] \sphinxcode{\sphinxupquote{intelmpi\_ilp64.a \$MKLPATH/libmkl\_intel\_ilp64.a \$MKLPATH/libmkl\_intel\_thread.a\textbackslash{}}}
\item[] \sphinxcode{\sphinxupquote{\$MKLPATH/libmkl\_core.a \sphinxhyphen{}Wl,\sphinxhyphen{}\sphinxhyphen{}end\sphinxhyphen{}group}}）封装集群组件、接口、线程和计算库。
\end{DUlineblock}

\sphinxAtStartPar
列出库的顺序是有要求的，除非是封装在上面分组符号中的。


\subsubsection{动态选择接口和线程层链接}
\label{\detokenize{intel-mkl/intel-mkl:dsi}}\label{\detokenize{intel-mkl/intel-mkl:id14}}
\sphinxAtStartPar
SDL接口使得用户可以动态选择Intel MKL的接口和线程层。
\begin{itemize}
\item {} 
\sphinxAtStartPar
设置接口层

\sphinxAtStartPar
可用的接口与系统架构有关，对于Intel
64架构，可使用LP64和ILP64接口。在运行时设置接口，可调用mkl\_set\_interface\_layer函数或设置\sphinxcode{\sphinxupquote{MKL\_INTERFACE\_LAYER}}环境变量。下表为可用的接口层的值。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
接口层
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MKL\_INTERFACE\_LAYER}}的值
&\sphinxstyletheadfamily 
\sphinxAtStartPar
mkl\_set\_interface\_layer的参数值
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
LP64
&
\sphinxAtStartPar
LP64
&
\sphinxAtStartPar
MKL\_INTERFACE\_LP64
\\
\sphinxhline
\sphinxAtStartPar
ILP64
&
\sphinxAtStartPar
ILP64
&
\sphinxAtStartPar
MKL\_INTERFACE\_ILP64
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
如果调用了mkl\_set\_interface\_layer函数，那么环境变量\sphinxcode{\sphinxupquote{MKL\_INTERFACE\_LAYER}}的值将被忽略。默认使用LP64接口。

\item {} 
\sphinxAtStartPar
设置线程层

\sphinxAtStartPar
在运行时设置线程层，可以调用mkl\_set\_threading\_layer函数或者设置环境变量\sphinxcode{\sphinxupquote{MKL\_THREADING\_LAYER}}。下表为可用的线程层的值。


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
线程层
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MKL\_INTERFACE\_LAYER}}的值
&\sphinxstyletheadfamily 
\sphinxAtStartPar
mkl\_set\_interface\_layer的参数值
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Intel线程
&
\sphinxAtStartPar
INTEL
&
\sphinxAtStartPar
MKL\_THREADING\_INTEL
\\
\sphinxhline
\sphinxAtStartPar
串行线程
&
\sphinxAtStartPar
SEQUENTIAL
&
\sphinxAtStartPar
MKL\_THREADING\_SEQUENTIAL
\\
\sphinxhline
\sphinxAtStartPar
GNU线程
&
\sphinxAtStartPar
GNU
&
\sphinxAtStartPar
MKL\_THREADING\_GNU
\\
\sphinxhline
\sphinxAtStartPar
PGI线程
&
\sphinxAtStartPar
PGI
&
\sphinxAtStartPar
MKL\_THREADING\_PGI
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
如果调用了mkl\_set\_threading\_layer函数，那么环境变量MKL\_THREADING\_LAYER的值被忽略。默认使用Intel线程。

\end{itemize}


\subsubsection{使用接口库链接}
\label{\detokenize{intel-mkl/intel-mkl:lp}}\label{\detokenize{intel-mkl/intel-mkl:id15}}\begin{itemize}
\item {} 
\sphinxAtStartPar
使用ILP64接口 vs. LP64接口

\sphinxAtStartPar
Intel MKL ILP64库采用64\sphinxhyphen{}bit整数（索引超过含有\(2^{31}-1\)个元素的大数组时使用），而LP64库采用32\sphinxhyphen{}bit整数索引数组。

\sphinxAtStartPar
LP64和ILP64接口在接口层实现，分别采用下面接口层链接使用LP64或ILP64：
\begin{itemize}
\item {} 
\sphinxAtStartPar
静态链接：libmkl\_intel\_lp64.a或libmkl\_intel\_ilp64.a

\item {} 
\sphinxAtStartPar
动态链接：libmkl\_intel\_lp64.so或libmkl\_intel\_ilp64.so

\end{itemize}

\sphinxAtStartPar
ILP64接口提供以下功能：
\begin{itemize}
\item {} 
\sphinxAtStartPar
支持大数据数组（具有超过\(2^{31}-1\)个元素）；

\item {} 
\sphinxAtStartPar
添加\sphinxhyphen{}i8编译器参数编译Fortran程序。

\end{itemize}

\sphinxAtStartPar
LP64接口提供与以前Intel MKL版本的兼容，因为LP64对于仅提供一种接口的版本低于9.1的Intel MKL来说是一个新名字。如果用户的应用采用Intel MKL计算大数据数组或此库也许在将来会用到时请选择使用ILP64接口。

\sphinxAtStartPar
Intel MKL提供的ILP64和LP64头文件路径是相同的。
\begin{itemize}
\item {} 
\sphinxAtStartPar
采用LP64/ILP64编译

\sphinxAtStartPar
下面显示如何采用ILP64和LP64接口进行编译：
\begin{itemize}
\item {} 
\begin{DUlineblock}{0em}
\item[] Fortran：
\item[] ILP64：\sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}i8 \sphinxhyphen{}I<mkl directory>/include ...}}
\item[] LP64：\sphinxcode{\sphinxupquote{ifort \sphinxhyphen{}I<mkl directory>/include ...}}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] C/C++：
\item[] ILP64：\sphinxcode{\sphinxupquote{icc \sphinxhyphen{}DMKL\_ILP64 \sphinxhyphen{}I<mkl directory>/include ...}}
\item[] LP64：\sphinxcode{\sphinxupquote{icc \sphinxhyphen{}I<mkl directory>/include ...}}
\end{DUlineblock}

\end{itemize}

\sphinxAtStartPar
注意，采用\sphinxhyphen{}i8或\sphinxhyphen{}DMKL\_ILP64选项链接LP64接口库时也许将会产生预想不到的错误。

\item {} 
\sphinxAtStartPar
编写代码

\sphinxAtStartPar
如果不使用ILP64接口，无需修改代码。

\sphinxAtStartPar
为了移植或者新写代码使用ILP64接口，需要使用正确的Intel MKL函数和子程序的参数类型：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
整数类型
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Fortran
&\sphinxstyletheadfamily 
\sphinxAtStartPar
C/C++
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
32\sphinxhyphen{}bit整数
&
\sphinxAtStartPar
INTEGER*4或INTEGER(KIND=4)
&
\sphinxAtStartPar
int
\\
\sphinxhline
\sphinxAtStartPar
针对ILP64/LP64的通用整数（ILP64使用64\sphinxhyphen{}bit，其余32\sphinxhyphen{}bit）
&
\sphinxAtStartPar
INTEGER，不指明KIND
&
\sphinxAtStartPar
MKL\_INT
\\
\sphinxhline
\sphinxAtStartPar
针对ILP64/LP64的通用整数（64\sphinxhyphen{}bit整数）
&
\sphinxAtStartPar
INTEGER*8或INTEGER(KIND=8)
&
\sphinxAtStartPar
MKL\_INT64
\\
\sphinxhline
\sphinxAtStartPar
针对ILP64/LP64的FFT接口
&
\sphinxAtStartPar
INTEGER，不指明KIND
&
\sphinxAtStartPar
MKL\_LONG
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
局限性

\sphinxAtStartPar
所有Intel MKL函数都支持ILP64编程，但是针对Intel MKL的FFTW接口：
\begin{itemize}
\item {} 
\sphinxAtStartPar
FFTW 2.x封装不支持ILP64；

\item {} 
\sphinxAtStartPar
FFTW 3.2封装通过专用功能函数plan\_guru64支持ILP64。

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
使用Fortran 95接口库

\sphinxAtStartPar
libmkl\_blas95*.a和libmkl\_lapack95*.a库分别含有BLAS和LAPACK所需的Fortran 95接口，并且是与编译器无关。在Intel MKL包中，已经为Intel Fortran编译器预编译了，如果使用其它编译器，请在使用前先编译。

\end{itemize}


\subsubsection{使用线程库链接}
\label{\detokenize{intel-mkl/intel-mkl:id16}}\begin{itemize}
\item {} 
\sphinxAtStartPar
串行库模式

\sphinxAtStartPar
采用Intel MKL串行（非线程化）模式时，Intel MKL运行非线程化代码。它是线程安全的（除了LAPACK已过时的子程序?lacon），即可以在用户程序的OpenMP代码部分使用。串行模式不要求与OpenMP运行时库的兼容，环境变量\sphinxcode{\sphinxupquote{OMP\_NUM\_THREADS}}或其Intel MKL等价变量对其也无影响。

\sphinxAtStartPar
只有在不需要使用Intel MKL线程时才应使用串行模式。当使用一些非Intel编译器线程化程序或在需要非线程化库（比如使用MPI的一些情况时）的情形使用Intel MKL时，串行模式也许有用。为了使用串行模式，请选择*sequential.*库。

\sphinxAtStartPar
对于串行模式，由于*sequential.*依赖于pthread，请在链接行添加POSIX线程库(pthread)。

\item {} 
\sphinxAtStartPar
选择线程库层

\sphinxAtStartPar
一些Intel MKL支持的编译器使用OpenMP线程技术。Intel MKL支持这些编译器提供OpenMP技术实现，为了使用这些支持，需要采用正确的线程层和编译器支持运行库进行链接。
\begin{itemize}
\item {} 
\sphinxAtStartPar
线程层

\sphinxAtStartPar
每个Intel MKL线程库包含针对同样的代码采用不同编译器（Intel、GNU和PGI编译器）分别编译的库。

\item {} 
\sphinxAtStartPar
运行时库

\sphinxAtStartPar
此层包含Intel编译器兼容的OpenMP运行时库libiomp。在Intel编译器之外，libiomp提供在Linux操作系统上对更多线程编译器的支持。即，采用GNU编译器线程化的程序可以安全地采用intel MKL和libiomp链接。

\sphinxAtStartPar
下表有助于解释在不同情形下使用Intel MKL时选择线程库和运行时库（仅静态链接情形）：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
编译器
&\sphinxstyletheadfamily 
\sphinxAtStartPar
应用是否线程化
&\sphinxstyletheadfamily 
\sphinxAtStartPar
线程层
&\sphinxstyletheadfamily 
\sphinxAtStartPar
推荐的运行时库
&\sphinxstyletheadfamily 
\sphinxAtStartPar
备注
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Intel
&
\sphinxAtStartPar
无所谓
&
\sphinxAtStartPar
libmkl\_intel\_thread.a
&
\sphinxAtStartPar
libiomp5.so
&\\
\sphinxhline
\sphinxAtStartPar
PGI
&
\sphinxAtStartPar
Yes
&
\sphinxAtStartPar
libmkl\_pgi\_thread.a或
libmkl\_sequential.a
&
\sphinxAtStartPar
由PGI*提供
&
\sphinxAtStartPar
使用libmkl\_sequential.a
从IntelMKL调用中去除线程化
\\
\sphinxhline
\sphinxAtStartPar
PGI
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
libmkl\_intel\_thread.a
&
\sphinxAtStartPar
libiomp5.so
&\\
\sphinxhline
\sphinxAtStartPar
PGI
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
libmkl\_pgi\_thread.a
&
\sphinxAtStartPar
由PGI*提供
&\\
\sphinxhline
\sphinxAtStartPar
PGI
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
libmkl\_sequential.a
&
\sphinxAtStartPar
None
&\\
\sphinxhline
\sphinxAtStartPar
GNU
&
\sphinxAtStartPar
Yes
&
\sphinxAtStartPar
libmkl\_gnu\_thread.a
&
\sphinxAtStartPar
libiomp5.so或库
GNU OpenMP运行时库
&
\sphinxAtStartPar
libiomp5提供监控缩放性能
\\
\sphinxhline
\sphinxAtStartPar
GNU
&
\sphinxAtStartPar
Yes
&
\sphinxAtStartPar
libmkl\_sequential.a
&
\sphinxAtStartPar
None
&\\
\sphinxhline
\sphinxAtStartPar
GNU
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
libmkl\_intel\_thread.a
&
\sphinxAtStartPar
libiomp5.so
&\\
\sphinxhline
\sphinxAtStartPar
other
&
\sphinxAtStartPar
Yes
&
\sphinxAtStartPar
libmkl\_sequential.a
&
\sphinxAtStartPar
None
&\\
\sphinxhline
\sphinxAtStartPar
other
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
libmkl\_intel\_thread.a
&
\sphinxAtStartPar
libiomp5.so
&\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\end{itemize}

\end{itemize}


\subsubsection{使用计算库链接}
\label{\detokenize{intel-mkl/intel-mkl:id17}}\begin{itemize}
\item {} 
\sphinxAtStartPar
如不使用Intel MKL集群软件在链接应用程序时只需要一个计算库即可，其依赖于链接方式：
\begin{itemize}
\item {} 
\sphinxAtStartPar
静态链接： libmkl\_core.a

\item {} 
\sphinxAtStartPar
动态链接： libmkl\_core.so

\end{itemize}

\item {} 
\sphinxAtStartPar
采用Intel MKL集群软件的计算库

\sphinxAtStartPar
ScaLAPACK和集群Fourier变换函数(Cluster FFTs)要求更多的计算库，其也许依赖于架构。下表为列出的针对Intel 64架构的使用ScaLAPACK或集群FFTs的计算库：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
函数域
&\sphinxstyletheadfamily 
\sphinxAtStartPar
静态链接
&\sphinxstyletheadfamily 
\sphinxAtStartPar
动态链接
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
ScaLAPACK，LP64接口
&
\sphinxAtStartPar
libmkl\_scalapack\_lp64.a和libmkl\_core.a
&
\sphinxAtStartPar
libmkl\_scalapack\_lp64.so和libmkl\_core.so
\\
\sphinxhline
\sphinxAtStartPar
ScaLAPACK，ILP64接口
&
\sphinxAtStartPar
libmkl\_scalapack\_ilp64.a和libmkl\_core.a
&
\sphinxAtStartPar
libmkl\_scalapack\_ilp64.so和libmkl\_core.so
\\
\sphinxhline
\sphinxAtStartPar
集群FFTs
&
\sphinxAtStartPar
libmkl\_cdft\_core.a和libmkl\_core.a
&
\sphinxAtStartPar
libmkl\_cdft\_core.so和libmkl\_core.so
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\end{itemize}

\sphinxAtStartPar
下表为列出的针对IA\sphinxhyphen{}32架构的使用 ScaLAPACK或集群FFTs的计算库：


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
函数域
&\sphinxstyletheadfamily 
\sphinxAtStartPar
静态链接
&\sphinxstyletheadfamily 
\sphinxAtStartPar
动态链接
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
ScaLAPACK
&
\sphinxAtStartPar
libmkl\_scalapack\_core.a和libmkl\_core.a
&
\sphinxAtStartPar
libmkl\_scalapack\_core.so和libmkl\_core.so
\\
\sphinxhline
\sphinxAtStartPar
集群FFTs
&
\sphinxAtStartPar
libmkl\_cdft\_core.a和libmkl\_core.a
&
\sphinxAtStartPar
libmkl\_cdft\_core.so和libmkl\_core.so
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
注意：对于ScaLAPACK和集群FFTs，当在MPI程序中使用时，还需要添加BLACS库。


\subsubsection{使用编译器运行库链接}
\label{\detokenize{intel-mkl/intel-mkl:id18}}
\sphinxAtStartPar
甚至在静态链接其它库时，也可动态链接libiomp5、兼容的OpenMP运行时库。

\sphinxAtStartPar
静态链接libiomp5也许会存在问题，其原因由于操作环境或应用越复杂，将会包含更多多余的库的复本。这将不仅会导致性能问题，甚至导致不正确的结果。

\sphinxAtStartPar
动态链接libiomp5时，需确保\sphinxcode{\sphinxupquote{LD\_LIBRARY\_PATH}}环境变量设置正确。


\subsubsection{使用系统库链接}
\label{\detokenize{intel-mkl/intel-mkl:id19}}
\sphinxAtStartPar
使用Intel MKL的FFT、Trigonometric Transforn或Poisson、Laplace和Helmholtz求解程序时，需要通过在链接行添加\sphinxhyphen{}lm参数链接数学支持系统库。

\sphinxAtStartPar
在Linux系统上，由于多线程libiomp5库依赖于原生的pthread库，因此，在任何时候，libiomp5要求在链接行随后添加\sphinxhyphen{}lpthread参数（列出的库的顺序非常重要）。


\subsubsection{冗长（Verbose）启用模式链接}
\label{\detokenize{intel-mkl/intel-mkl:verbose}}
\sphinxAtStartPar
如果应用调用了MKL函数，您也许希望知道调用了哪些计算函数，传递给它们什么参数，并且花费多久执行这些函数。当启用Intel MKL冗长（Verbose）模式时，您的应用可以打印出这些信息。可以打印出这些信息的函数称为冗长启用函数。并不是所有Intel MKL函数都是冗长启用的，请查看Intel MKL发布说明。

\sphinxAtStartPar
在冗长模式下，每个冗长启用函数的调用都将打印人性化可读行描述此调用。如果此应用在此函数调用中终止，不会有针对此函数的信息打印出来。第一个冗长启用函数调用将打印一版本信息行。

\sphinxAtStartPar
为了对应用启用Intel MKL冗长模式，需要执行以下两者之一：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设置环境变量MKL\_VERBOSE为1，在bash下可以执行\sphinxcode{\sphinxupquote{export MKL\_VERBOSE=1}}

\item {} 
\sphinxAtStartPar
调用支持函数mkl\_verbose(1)

\end{itemize}

\sphinxAtStartPar
函数调用mkl\_verbose(0)将停止冗长模式。调用启用或禁止冗长模式的函数将覆盖掉环境变量设置。关于mkl\_verbose函数，请参看Intel MKL Reference Manual。

\sphinxAtStartPar
Intel MKL冗长模式不是线程局域的，而是全局状态。这意味着如果一个应用从多线程中改变模式，其结果将是未定义的。


\section{性能优化等}
\label{\detokenize{intel-mkl/intel-mkl:id20}}
\sphinxAtStartPar
请参见Intel MKL官方手册。

\sphinxstepscope


\chapter{应用程序的编译与安装}
\label{\detokenize{compile-install/compile-install:id1}}\label{\detokenize{compile-install/compile-install::doc}}
\sphinxAtStartPar
应用程序一般有两种方式发布：
\begin{itemize}
\item {} 
\sphinxAtStartPar
二进制方式：用户无需编译，只要解压缩后设置相关环境变量等即可。如Gaussian %
\begin{footnote}[1]\sphinxAtStartFootnote
Gaussian主页：\sphinxurl{http://www.gaussian.com/}
%
\end{footnote}，国内用户只能购买到已经编译好的二进制可执行文件，有些国家和地区能购买到源代码。

\item {} 
\sphinxAtStartPar
源代码方式：
\begin{itemize}
\item {} 
\sphinxAtStartPar
用户需要自己编译，并且可以按照需要修改编译参数以编译成最适合自己的可执行程序，之后再设置环境变量等使用，如VASP %
\begin{footnote}[2]\sphinxAtStartFootnote
VASP主页：\sphinxurl{http://www.vasp.at/}
%
\end{footnote}。

\item {} 
\sphinxAtStartPar
源代码编译时经常用到的编译命令为\sphinxcode{\sphinxupquote{make}}，编译配置文件为，请查看\sphinxcode{\sphinxupquote{make}}命令用法及文件说明。

\end{itemize}

\end{itemize}

\sphinxAtStartPar
应用程序一般都有官方的安装说明，建议在安装前，首先仔细查看一下，比如到其主页或者查看解压缩后的目录中的类似：install*、readme*等文件。


\section{二进制程序的安装}
\label{\detokenize{compile-install/compile-install:id4}}
\sphinxAtStartPar
以二进制方式发布的程序，安装相对简单，一般只要解压缩后设置好环境变量即可，以Gaussian09为例：
\begin{itemize}
\item {} 
\sphinxAtStartPar
将压缩包复制到某个地方，如

\item {} 
\sphinxAtStartPar
解压缩：\sphinxcode{\sphinxupquote{tar xvf gaussian09.tar.gz}} %
\begin{footnote}[3]\sphinxAtStartFootnote
当前主流Linux系统，\sphinxcode{\sphinxupquote{tar}}命令已经能自动识别.gz和.bz压缩，无需再明确添加z或j参数来指定。
%
\end{footnote}

\item {} 
\sphinxAtStartPar
设置环境变量：修改 \sphinxcode{\sphinxupquote{\textasciitilde{}/.bashrc}} ，添加：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}Add for g09}
\PYG{n+nb}{export} \PYG{n+nv}{g09root}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}/opt\PYGZdq{}}
\PYG{n+nb}{export} \PYG{n+nv}{GAUSS\PYGZus{}SCRDIR}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}/tmp\PYGZdq{}}
. \PYG{n+nv}{\PYGZdl{}g09root}/g09/bsd/g09.profile
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}End for g09}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
刷新环境设置： \sphinxcode{\sphinxupquote{. \textasciitilde{}/.bashrc}}  或重新登录下。

\end{itemize}


\section{源代码程序的安装}
\label{\detokenize{compile-install/compile-install:id6}}
\sphinxAtStartPar
以源代码发布的程序安装相对复杂，需了解所采用的编译环境，并对配置等做相应修改（主要修改编译命令、库、头文件等编译参数等）。以VASP为例：
\begin{itemize}
\item {} 
\sphinxAtStartPar
查看安装说明：其主页上的文档：\sphinxurl{http://www.vasp.at/index.php/documentation}

\item {} 
\sphinxAtStartPar
解压缩文件：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tar xvf vasp.5.lib.tar.gz}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tar xvf vasp.5.2.tar.gz}}

\end{itemize}

\item {} 
\sphinxAtStartPar
查看说明：install、readme文件等，VASP解压后的目录中未含有，可以参见上述主页文档安装。

\item {} 
\sphinxAtStartPar
生成默认配置文件：\sphinxcode{\sphinxupquote{./configure}}。
\begin{itemize}
\item {} 
\sphinxAtStartPar
VASP不需要\sphinxcode{\sphinxupquote{./configure}}命令生成，而是提供了几个针对不同系统和编译器的makefile模板，可以复制成

\item {} 
\sphinxAtStartPar
其它程序也许需要\sphinxcode{\sphinxupquote{./configure}}生成所需要的，在运行\sphinxcode{\sphinxupquote{./configure}}之前，一般可以运行\sphinxcode{\sphinxupquote{./configure \sphinxhyphen{}h}}查看其选项。如对Open
MPI 1.6.4，可以运行以下命令生成：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{F77=ifort FC=ifort CC=icc CXX=icpc ./configure \sphinxhyphen{}\sphinxhyphen{}prefix=/opt/openmpi\sphinxhyphen{}1.6.4}}

\sphinxAtStartPar
其中：
\begin{itemize}
\item {} 
\sphinxAtStartPar
F77：编译Fortran77源文件的编译器命令

\item {} 
\sphinxAtStartPar
FC：编译Fortran90源文件的编译器命令

\item {} 
\sphinxAtStartPar
CC：编译C源文件的编译器命令

\item {} 
\sphinxAtStartPar
CXX：编译C++源文件的编译器命令

\item {} 
\sphinxAtStartPar
–prefix：安装到的目录前缀

\end{itemize}

\sphinxAtStartPar
另外一些在Makefile中常见变量为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
CPP：预处理参数

\item {} 
\sphinxAtStartPar
CLAGS：C程序编译参数

\item {} 
\sphinxAtStartPar
CXXFLAGS：C程序编译参数

\item {} 
\sphinxAtStartPar
F90：编译Fortran90及以后源文件的编译器命令

\item {} 
\sphinxAtStartPar
FFLAGS：Fortran编译参数

\item {} 
\sphinxAtStartPar
OFLAG：优化参数

\item {} 
\sphinxAtStartPar
INCLUDE：头文件参数

\item {} 
\sphinxAtStartPar
LIB：库文件参数

\item {} 
\sphinxAtStartPar
LINK：链接参数

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
修改文件配置，设定编译环境等：
\begin{itemize}
\item {} 
\sphinxAtStartPar
对做如下修改：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设定编译Fortran的编译器命令为Intel Fortran编译器命令：FC=ifort

\end{itemize}

\item {} 
\sphinxAtStartPar
对做如下修改：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设定BLAS库使用Intel MKL中的BLAS：BLAS=\sphinxhyphen{}mkl %
\begin{footnote}[4]\sphinxAtStartFootnote
因为2013版本的Intel编译器支持\sphinxhyphen{}mkl选项自动Intel
MKL库，因此可以这么设置。
%
\end{footnote}

\item {} 
\sphinxAtStartPar
打开FFT3D支持：去掉FFT3D = fft3dfurth.o fft3dlib.o前的\# %
\begin{footnote}[5]\sphinxAtStartFootnote
在Makefile中\#表示注释
%
\end{footnote}

\item {} 
\sphinxAtStartPar
设定MPI Fortran编译器为Intel MPI编译器：FC=mpiifort

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
编译：\sphinxcode{\sphinxupquote{make}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
先在目录中执行\sphinxcode{\sphinxupquote{make}}

\item {} 
\sphinxAtStartPar
如未出错，则再在目录中执行\sphinxcode{\sphinxupquote{make}}

\end{itemize}

\item {} 
\sphinxAtStartPar
安装：\sphinxcode{\sphinxupquote{make install}}。VASP不需要，有些程序需要执行此步。

\item {} 
\sphinxAtStartPar
设置环境变量：比如在中设置安装后的可执行程序目录在环境变量\sphinxcode{\sphinxupquote{PATH}}中：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{export} \PYG{n+nv}{PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PATH}:/opt/vasp.5.2
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Slurm作业调度系统}
\label{\detokenize{slurm/index:slurm}}\label{\detokenize{slurm/index::doc}}
\sphinxstepscope


\section{简介}
\label{\detokenize{slurm/slurm:id1}}\label{\detokenize{slurm/slurm::doc}}
\sphinxAtStartPar
Slurm(Simple Linux Utility for Resource Management，\sphinxurl{http://slurm.schedmd.com/})是开源的、具有容错性和高度可扩展大型和小型Linux集群资源管理和作业调度系统。超级计算系统可利用Slurm进行资源和作业管理，以避免相互干扰，提高运行效率。所有需运行的作业无论是用于程序调试还是业务计算均必须通过交互式并行\sphinxcode{\sphinxupquote{srun}}、批处理式\sphinxcode{\sphinxupquote{sbatch}}或分配式\sphinxcode{\sphinxupquote{salloc}}等命令提交，提交后可以利用相关命令查询作业状态等。请不要在登录节点直接运行作业（编译除外），以免影响其余用户的正常使用。

\sphinxAtStartPar
该文档的针对的Slurm版本为19.05（瀚海20超级计算系统使用）、22.05（瀚海22超级计算系统使用）。


\section{基本概念}
\label{\detokenize{slurm/slurm:id2}}

\subsection{三种模式区别}
\label{\detokenize{slurm/slurm:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
批处理作业（采用\sphinxcode{\sphinxupquote{sbatch}}命令提交，最常用方式）：

\sphinxAtStartPar
对于批处理作业（提交后立即返回该命令行终端，用户可进行其它操作）使用\sphinxcode{\sphinxupquote{sbatch}}命令提交作业脚本，作业被调度运行后，在所分配的首个节点上执行作业脚本。在作业脚本中也可使用\sphinxcode{\sphinxupquote{srun}}命令加载作业任务。提交时采用的命令行终端终止，也不影响作业运行。

\item {} 
\sphinxAtStartPar
交互式作业提交（采用\sphinxcode{\sphinxupquote{srun}}命令提交）：

\sphinxAtStartPar
资源分配与任务加载两步均通过\sphinxcode{\sphinxupquote{srun}}命令进行：当在登录shell中执行\sphinxcode{\sphinxupquote{srun}}命令时，\sphinxcode{\sphinxupquote{srun}}首先向系统提交作业请求并等待资源分配，然后在所分配的节点上加载作业任务。采用该模式，用户在该终端需等待任务结束才能继续其它操作，在作业结束前，如果提交时的命令行终端断开，则任务终止。一般用于短时间小作业测试。

\item {} 
\sphinxAtStartPar
实时分配模式作业（采用\sphinxcode{\sphinxupquote{salloc}}命令提交）：

\sphinxAtStartPar
分配作业模式类似于交互式作业模式和批处理作业模式的融合。用户需指定所需要的资源条件，向资源管理器提出作业的资源分配请求。提交后，作业处于排队，当用户请求资源被满足时，将在用户提交作业的节点上执行用户所指定的命令，指定的命令执行结束后，作业运行结束，用户申请的资源被释放。在作业结束前，如果提交时的命令行终端断开，则任务终止。典型用途是分配资源并启动一个shell，然后在这个shell中利用\sphinxcode{\sphinxupquote{srun}}运行并行作业。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salloc}}后面如果没有跟定相应的脚本或可执行文件，则默认选择 \sphinxcode{\sphinxupquote{/bin/sh}}，用户获得了一个合适环境变量的shell环境。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salloc}}和\sphinxcode{\sphinxupquote{sbatch}}最主要的区别是\sphinxcode{\sphinxupquote{salloc}}命令资源请求被满足时，直接在提交作业的节点执行相应任务，而\sphinxcode{\sphinxupquote{sbatch}}则当资源请求被满足时，在分配的第一个节点上执行相应任务。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salloc}}在分配资源后，再执行相应的任务，很适合需要指定运行节点和其它资源限制，并有特定命令的作业。

\end{itemize}


\subsection{基本用户命令}
\label{\detokenize{slurm/slurm:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sacct}}：显示激活的或已完成作业或作业步的记账（对应需缴纳的机时费）信息。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salloc}}：为需实时处理的作业分配资源，典型场景为分配资源并启动一个shell，然后用此shell执行\sphinxcode{\sphinxupquote{srun}}命令去执行并行任务。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sattach}}：吸附到运行中的作业步的标准输入、输出及出错，通过吸附，使得有能力监控运行中的作业步的IO等。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sbatch}}：提交作业脚本使其运行。此脚本一般也可含有一个或多个\sphinxcode{\sphinxupquote{srun}}命令启动并行任务。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sbcast}}：将本地存储中的文件传递分配给作业的节点上，比如\sphinxcode{\sphinxupquote{/tmp}}等本地目录；对于\sphinxcode{\sphinxupquote{/home}}等共享目录，因各节点已经是同样文件，无需使用。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scancel}}：取消排队或运行中的作业或作业步，还可用于发送任意信号到运行中的作业或作业步中的所有进程。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scontrol}}：显示或设定Slurm作业、队列、节点等状态。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinfo}}：显示队列或节点状态，具有非常多过滤、排序和格式化等选项。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{speek}}：查看作业屏幕输出。注：该命令是本人写的，不是slurm官方命令，在其它系统上不一定有。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{squeue}}：显示队列中的作业及作业步状态，含非常多过滤、排序和格式化等选项。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{srun}}：实时交互式运行并行作业，一般用于段时间测试，或者与\sphinxcode{\sphinxupquote{sallcoc}}及\sphinxcode{\sphinxupquote{sbatch}}结合。

\end{itemize}


\subsection{基本术语}
\label{\detokenize{slurm/slurm:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
socket：CPU插槽，可以简单理解为CPU。

\item {} 
\sphinxAtStartPar
core：CPU核，单颗CPU可以具有多颗CPU核。

\item {} 
\sphinxAtStartPar
job：作业。

\item {} 
\sphinxAtStartPar
job step：作业步，单个作业（job）可以有个多作业步。

\item {} 
\sphinxAtStartPar
tasks：任务数，单个作业或作业步可有多个任务，一般一个任务需一个CPU核，可理解为所需的CPU核数。

\item {} 
\sphinxAtStartPar
rank：秩，如MPI进程号。

\item {} 
\sphinxAtStartPar
partition：队列、分区。作业需在特定队列中运行，一般不同队列允许的资源不一样，比如单作业核数等。

\item {} 
\sphinxAtStartPar
stdin：标准输入文件，一般指可以通过屏幕输入或采用\sphinxcode{\sphinxupquote{<文件名}}方式传递给程序的文件，对应C程序中的文件描述符0。

\item {} 
\sphinxAtStartPar
stdout：标准输出文件，程序运行正常时输出信息到的文件，一般指输出到屏幕的，并可采用>文件名定向到的文件，对应C程序中的文件描述符1。

\item {} 
\sphinxAtStartPar
stderr：标准出错文件，程序运行出错时输出信息到的文件，一般指也输出到屏幕，并可采用2>定向到的文件（注意这里的2），对应C程序中的文件描述符2。

\end{itemize}


\subsection{常用参考}
\label{\detokenize{slurm/slurm:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
作业提交：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salloc}}：为需实时处理的作业分配资源，提交后等获得作业分配的资源后运行，作业结束后返回命令行终端。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sbatch}}：批处理提交，提交后无需等待立即返回命令行终端。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{srun}}：运行并行作业，等获得作业分配的资源并运行，作业结束后返回命令行终端。

\end{itemize}

\sphinxAtStartPar
常用参数：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}begin=<time>：设定作业开始运行时间，如\sphinxhyphen{}\sphinxhyphen{}begin=“18:00:00”。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}constraints<features>：设定需要的节点特性。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}cpu\sphinxhyphen{}per\sphinxhyphen{}task：需要的CPU核数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}error=<filename>：设定存储出错信息的文件名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}exclude=<names>：设定不采用（即排除）运行的节点。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}dependency=<state:jobid>：设定只有当作业号的作业达到某状态时才运行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}exclusive{[}=user|mcs{]}：设定排它性运行，不允许该节点有它人或某user用户或mcs的作业同时运行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}export=<name{[}=value{]}>：输出环境变量给作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}gres=<name{[}:count{]}>：设定需要的通用资源。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}input=<filename>：设定输入文件名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}job\sphinxhyphen{}name=<name>：设定作业名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}label：设定输出时前面有标记（\sphinxcode{\sphinxupquote{仅限srun}}）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}mem=<size{[}unit{]}>：设定每个节点需要的内存。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}cpu=<size{[}unit{]}>：设定每个分配的CPU所需的内存。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}N<minnodes{[}\sphinxhyphen{}maxnodes{]}>：设定所需要的节点数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}n：设定启动的任务数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}nodelist=<names>：设定需要的特定节点名，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}output=<filename>：设定存储标准输出信息的文件名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}partition=<name>：设定采用的队列。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}qos=<name>：设定采用的服务质量(QOS)。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}signal={[}B:{]}<num>{[}@time{]}：设定当时间到时发送给作业的信号。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}time=<time>：设定作业运行时的墙上时钟限制。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}wrap=<command\_strings>：将命令封装在一个简单的sh shell中运行（ \sphinxcode{\sphinxupquote{仅限sbatch}} ）。

\end{itemize}

\item {} 
\sphinxAtStartPar
服务质量(QoS)：\sphinxcode{\sphinxupquote{sacctmgr}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sacctmgr list qos}}或\sphinxcode{\sphinxupquote{sacctmgr show qos}}：显示QoS

\end{itemize}

\item {} 
\sphinxAtStartPar
记账信息：\sphinxcode{\sphinxupquote{sacct}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}endtime=<time>：设定显示的截止时间之前的作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}format=<spec>：格式化输出。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}name=<jobname>：设定显示作业名的信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}partition=<name>：设定采用队列的作业信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}state=<state\_list>：显示特定状态的作业信息。

\end{itemize}

\item {} 
\sphinxAtStartPar
作业管理
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scancel}}：取消作业
\begin{itemize}
\item {} 
\sphinxAtStartPar
jobid<job\_id\_list>：设定作业号。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}name=<name>：设定作业名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}partition=<name>：设定采用队列的作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}qos=<name>：设定采用的服务质量(QOS)的作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}reservation=<name>：设定采用了预留测略的作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}nodelist=<name>：设定采用特定节点名的作业，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{squeue}}：查看作业信息
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}format=<spec>：格式化输出。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}jobid<job\_id\_list>：设定作业号。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}name=<name>：设定作业名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}partition=<name>：设定采用队列的作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}qos=<name>：设定采用的服务质量(QOS)的作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}start：显示作业开始时间。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}state=<state\_list>：显示特定状态的作业信息。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scontrol}}：查看作业、节点和队列等信息
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}details：显示更详细信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}oneline：所有信息显示在同一行。

\item {} 
\sphinxAtStartPar
show ENTITY ID：显示特定入口信息，ENTITY可为：job、node、partition等，ID可为作业号、节点名、队列名等。

\item {} 
\sphinxAtStartPar
update SPECIFICATION：修改特定信息，用户一般只能修改作业的。

\end{itemize}

\end{itemize}

\end{itemize}


\section{显示队列、节点信息：sinfo}
\label{\detokenize{slurm/slurm:sinfo}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sinfo}}可以查看系统存在什么队列、节点及其状态。如\sphinxcode{\sphinxupquote{sinfo \sphinxhyphen{}l}}：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PARTITION}   \PYG{n}{AVAIL}  \PYG{n}{TIMELIMIT}   \PYG{n}{JOB\PYGZus{}SIZE} \PYG{n}{ROOT} \PYG{n}{OVERSUBS}     \PYG{n}{GROUPS}  \PYG{n}{NODES}       \PYG{n}{STATE} \PYG{n}{NODELIST}
\PYG{n}{CPU}\PYG{o}{\PYGZhy{}}\PYG{n}{Large}\PYG{o}{*}     \PYG{n}{up}   \PYG{n}{infinite} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{infinite}   \PYG{n}{no}       \PYG{n}{NO}        \PYG{n+nb}{all}    \PYG{l+m+mi}{720}        \PYG{n}{idle} \PYG{n}{cnode}\PYG{p}{[}\PYG{l+m+mi}{001}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{720}\PYG{p}{]}
\PYG{n}{GPU}\PYG{o}{\PYGZhy{}}\PYG{n}{V100}       \PYG{n}{up}   \PYG{n}{infinite} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{infinite}   \PYG{n}{no}       \PYG{n}{NO}        \PYG{n+nb}{all}     \PYG{l+m+mi}{10}        \PYG{n}{idle} \PYG{n}{gnode}\PYG{p}{[}\PYG{l+m+mi}{01}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}
\PYG{l+m+mi}{2}\PYG{n}{TB}\PYG{o}{\PYGZhy{}}\PYG{n}{AEP}\PYG{o}{\PYGZhy{}}\PYG{n}{Mem}    \PYG{n}{up}   \PYG{n}{infinite} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{infinite}   \PYG{n}{no}       \PYG{n}{NO}        \PYG{n+nb}{all}      \PYG{l+m+mi}{8}       \PYG{n}{mixed} \PYG{n}{anode}\PYG{p}{[}\PYG{l+m+mi}{01}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{]}
\PYG{n}{ARM}\PYG{o}{\PYGZhy{}}\PYG{n}{CPU}        \PYG{n}{up}   \PYG{n}{infinite} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{infinite}   \PYG{n}{no}       \PYG{n}{NO}        \PYG{n+nb}{all}      \PYG{l+m+mi}{2}       \PYG{n}{down}\PYG{o}{*} \PYG{n}{rnode}\PYG{p}{[}\PYG{l+m+mi}{01}\PYG{p}{,}\PYG{l+m+mi}{09}\PYG{p}{]}
\PYG{n}{ARM}\PYG{o}{\PYGZhy{}}\PYG{n}{CPU}        \PYG{n}{up}   \PYG{n}{infinite} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{infinite}   \PYG{n}{no}       \PYG{n}{NO}        \PYG{n+nb}{all}      \PYG{l+m+mi}{2}   \PYG{n}{allocated} \PYG{n}{rnode}\PYG{p}{[}\PYG{l+m+mi}{02}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{03}\PYG{p}{]}
\PYG{n}{ARM}\PYG{o}{\PYGZhy{}}\PYG{n}{CPU}        \PYG{n}{up}   \PYG{n}{infinite} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{infinite}   \PYG{n}{no}       \PYG{n}{NO}        \PYG{n+nb}{all}      \PYG{l+m+mi}{5}        \PYG{n}{idle} \PYG{n}{rnode}\PYG{p}{[}\PYG{l+m+mi}{04}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{主要输出项}
\label{\detokenize{slurm/slurm:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
AVAIL：up表示可用，down表示不可用。

\item {} 
\sphinxAtStartPar
CPUS：各节点上的CPU数。

\item {} 
\sphinxAtStartPar
S:C:T：各节点上的CPU插口sockets(S)数（CPU颗数，一颗CPU含有多颗CPU核，以下类似）、CPU核cores(C)数和线程threads(T)数。

\item {} 
\sphinxAtStartPar
SOCKETS：各节点CPU插口数，CPU颗数。

\item {} 
\sphinxAtStartPar
CORES：各节点CPU核数。

\item {} 
\sphinxAtStartPar
THREADS：各节点线程数。

\item {} 
\sphinxAtStartPar
GROUPS：可使用的用户组，all表示所有组都可以用。

\item {} 
\sphinxAtStartPar
JOB\_SIZE：可供用户作业使用的最小和最大节点数，如果只有1个值，则表示最大和最小一样，infinite表示无限制。

\item {} 
\sphinxAtStartPar
TIMELIMIT：作业运行墙上时间（walltime，指的是用计时器，如手表或挂钟，度量的实际时间）限制，infinite表示没限制，如有限制的话，其格式为“days\sphinxhyphen{}hours:minutes:seconds”。

\item {} 
\sphinxAtStartPar
MEMORY：实际内存大小，单位为MB。

\item {} 
\sphinxAtStartPar
NODELIST：节点名列表，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
NODES：节点数。

\item {} 
\sphinxAtStartPar
NODES(A/I)：节点数，状态格式为“available/idle”。

\item {} 
\sphinxAtStartPar
NODES(A/I/O/T)：节点数，状态格式为“available/idle/other/total”。

\item {} 
\sphinxAtStartPar
PARTITION：队列名，后面带有*的，表示此队列为默认队列。

\item {} 
\sphinxAtStartPar
ROOT：是否限制资源只能分配给root账户。

\item {} 
\sphinxAtStartPar
OVERSUBSCRIBE：是否允许作业分配的资源超过计算资源（如CPU数）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
no：不允许超额。

\item {} 
\sphinxAtStartPar
exclusive：排他的，只能给这些作业用（等价于\sphinxcode{\sphinxupquote{srun \sphinxhyphen{}\sphinxhyphen{}exclusive}}）。

\item {} 
\sphinxAtStartPar
force：资源总被超额。

\item {} 
\sphinxAtStartPar
yes：资源可以被超额。

\end{itemize}

\item {} 
\sphinxAtStartPar
STATE：节点状态，可能的状态包括：
\begin{itemize}
\item {} 
\sphinxAtStartPar
allocated、alloc：已分配。

\item {} 
\sphinxAtStartPar
completing、comp：完成中。

\item {} 
\sphinxAtStartPar
down：宕机。

\item {} 
\sphinxAtStartPar
drained、drain：已失去活力。

\item {} 
\sphinxAtStartPar
draining、drng：失去活力中。

\item {} 
\sphinxAtStartPar
fail：失效。

\item {} 
\sphinxAtStartPar
failing、failg：失效中。

\item {} 
\sphinxAtStartPar
future、futr：将来可用。

\item {} 
\sphinxAtStartPar
idle：空闲，可以接收新作业。

\item {} 
\sphinxAtStartPar
maint：保持。

\item {} 
\sphinxAtStartPar
mixed：混合，节点在运行作业，但有些空闲CPU核，可接受新作业。

\item {} 
\sphinxAtStartPar
perfctrs、npc：因网络性能计数器使用中导致无法使用。

\item {} 
\sphinxAtStartPar
power\_down、pow\_dn：已关机。

\item {} 
\sphinxAtStartPar
power\_up、pow\_up：正在开机中。

\item {} 
\sphinxAtStartPar
reserved、resv：预留。

\item {} 
\sphinxAtStartPar
unknown、unk：未知原因。

\end{itemize}

\sphinxAtStartPar
注意，如果状态带有后缀*，表示节点没响应。

\item {} 
\sphinxAtStartPar
TMP\_DISK：/tmp所在分区空间大小，单位为MB。

\end{itemize}


\subsection{主要参数}
\label{\detokenize{slurm/slurm:id8}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}a、\sphinxhyphen{}\sphinxhyphen{}all：显示全部队列信息，如显示隐藏队列或本组没有使用权的队列。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}d、\sphinxhyphen{}\sphinxhyphen{}dead：仅显示无响应或已宕机节点。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}e、\sphinxhyphen{}\sphinxhyphen{}exact：精确而不是分组显示显示各节点。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}help：显示帮助。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}i <seconds>、\sphinxhyphen{}\sphinxhyphen{}iterate=<seconds>：以<seconds>秒间隔持续自动更新显示信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}l、\sphinxhyphen{}\sphinxhyphen{}long：显示详细信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}n <nodes>、\sphinxhyphen{}\sphinxhyphen{}nodes=<nodes>：显示<nodes>节点信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}N, \sphinxhyphen{}\sphinxhyphen{}Node：以每行一个节点方式显示信息，即显示各节点信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}p <partition>、\sphinxhyphen{}\sphinxhyphen{}partition=<partition>：显示<partition>队列信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}r、\sphinxhyphen{}\sphinxhyphen{}responding：仅显示响应的节点信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}R、\sphinxhyphen{}\sphinxhyphen{}list\sphinxhyphen{}reasons：显示不响应（down、drained、fail或failing状态）节点的原因。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}s：显示摘要信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}S <sort\_list>、\sphinxhyphen{}\sphinxhyphen{}sort=<sort\_list>：设定显示信息的排序方式。排序字段参见后面输出格式部分，多个排序字段采用,分隔，字段前面的+和\sphinxhyphen{}分表表示升序（默认）或降序。队列字段P前面如有\#，表示以Slurm配置文件slurm.conf中的顺序显示。例如：\sphinxcode{\sphinxupquote{sinfo \sphinxhyphen{}S +P,\sphinxhyphen{}m}}表示以队列名升序及内存大小降序排序。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}t <states>、\sphinxhyphen{}\sphinxhyphen{}states=<states>：仅显示<states>状态的信息。<states>状态可以为（不区分大小写）：ALLOC、ALLOCATED、COMP、COMPLETING、DOWN、DRAIN、DRAINED、DRAINING、ERR、ERROR、FAIL、FUTURE、FUTR、IDLE、MAINT、MIX、MIXED、NO\_RESPOND、NPC、PERFCTRS、POWER\_DOWN、POWER\_UP、RESV、RESERVED、UNK和UNKNOWN。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}T, \sphinxhyphen{}\sphinxhyphen{}reservation：仅显示预留资源信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}usage：显示用法。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}v、\sphinxhyphen{}\sphinxhyphen{}verbose：显示冗余信息，即详细信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}V：显示版本信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}o <output\_format>、\sphinxhyphen{}\sphinxhyphen{}format=<output\_format>：按照<output\_format>格式输出信息，默认为“\%\#P \%.5a \%.10l \%.6D \%.6t \%N”：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\%all：所有字段信息。

\item {} 
\sphinxAtStartPar
\%a：队列的状态及是否可用。

\item {} 
\sphinxAtStartPar
\%A：以“allocated/idle”格式显示状态对应的节点数。

\item {} 
\sphinxAtStartPar
\%b：激活的特性，参见\%f。

\item {} 
\sphinxAtStartPar
\%B：队列中每个节点可分配给作业的CPU数。

\item {} 
\sphinxAtStartPar
\%c：各节点CPU数。

\item {} 
\sphinxAtStartPar
\%C：以“allocated/idle/other/total”格式状态显示CPU数。

\item {} 
\sphinxAtStartPar
\%d：各节点临时磁盘空间大小，单位为MB。

\item {} 
\sphinxAtStartPar
\%D：节点数。

\item {} 
\sphinxAtStartPar
\%e：节点空闲内存。

\item {} 
\sphinxAtStartPar
\%E：节点无效的原因（down、draine或ddraining状态）。

\item {} 
\sphinxAtStartPar
\%f：节点可用特性，参见\%b。

\item {} 
\sphinxAtStartPar
\%F：以“allocated/idle/other/total”格式状态的节点数。

\item {} 
\sphinxAtStartPar
\%g：可以使用此节点的用户组。

\item {} 
\sphinxAtStartPar
\%G：与节点关联的通用资源（gres）。

\item {} 
\sphinxAtStartPar
\%h：作业是否能超用计算资源（如CPUs），显示结果可以为yes、no、exclusive或force。

\item {} 
\sphinxAtStartPar
\%H：节点不可用信息的时间戳。

\item {} 
\sphinxAtStartPar
\%I：队列作业权重因子。

\item {} 
\sphinxAtStartPar
\%l：以“days\sphinxhyphen{}hours:minutes:seconds”格式显示作业可最长运行时间。

\item {} 
\sphinxAtStartPar
\%L：以“days\sphinxhyphen{}hours:minutes:seconds”格式显示作业默认时间。

\item {} 
\sphinxAtStartPar
\%m：节点内存，单位MB。

\item {} 
\sphinxAtStartPar
\%M：抢占模式，可以为no或yes。

\item {} 
\sphinxAtStartPar
\%n：节点主机名。

\item {} 
\sphinxAtStartPar
\%N：节点名。

\item {} 
\sphinxAtStartPar
\%o：节点IP地址。

\item {} 
\sphinxAtStartPar
\%O：节点负载。

\item {} 
\sphinxAtStartPar
\%p：队列调度优先级。

\item {} 
\sphinxAtStartPar
\%P：队列名，带有*为默认队列，参见\%R。

\item {} 
\sphinxAtStartPar
\%R：队列名，不在默认队列后附加*，参见\%P。

\item {} 
\sphinxAtStartPar
\%s：节点最大作业大小。

\item {} 
\sphinxAtStartPar
\%S：允许分配的节点数。

\item {} 
\sphinxAtStartPar
\%t：以紧凑格式显示节点状态。

\item {} 
\sphinxAtStartPar
\%T：以扩展格式显示节点状态。

\item {} 
\sphinxAtStartPar
\%v：slurmd守护进程版本。

\item {} 
\sphinxAtStartPar
\%w：节点调度权重。

\item {} 
\sphinxAtStartPar
\%X：单节点socket数。

\item {} 
\sphinxAtStartPar
\%Y：单节点CPU核数。

\item {} 
\sphinxAtStartPar
\%Z：单核进程数。

\item {} 
\sphinxAtStartPar
\%z：扩展方式显示单节点处理器信息：sockets、cores、threads（S:C:T）数。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}O <output\_format>, \sphinxhyphen{}\sphinxhyphen{}Format=<output\_format>：按照<output\_format>格式输出信息，类似\sphinxhyphen{}o <output\_format>、\sphinxhyphen{}\sphinxhyphen{}format=<output\_format>。

\sphinxAtStartPar
每个字段的格式为“type{[}:{[}.{]}size{]}”：
\begin{itemize}
\item {} 
\sphinxAtStartPar
size：最小字段大小，如没指明，则最大为20个字符。

\item {} 
\sphinxAtStartPar
.：指明为右对齐，默认为左对齐。

\item {} 
\sphinxAtStartPar
可用type：
\begin{itemize}
\item {} 
\sphinxAtStartPar
all：所有字段信息。

\item {} 
\sphinxAtStartPar
allocmem：节点上分配的内存总数，单位MB。

\item {} 
\sphinxAtStartPar
allocnodes：允许分配的节点。

\item {} 
\sphinxAtStartPar
available：队列的State/availability状态。

\item {} 
\sphinxAtStartPar
cpus：各节点CPU数。

\item {} 
\sphinxAtStartPar
cpusload：节点负载。

\item {} 
\sphinxAtStartPar
freemem：节点可用内存，单位MB。

\item {} 
\sphinxAtStartPar
cpusstate：以“allocated/idle/other/total”格式状态的CPU数。

\item {} 
\sphinxAtStartPar
cores：单CPU颗CPU核数。

\item {} 
\sphinxAtStartPar
disk：各节点临时磁盘空间大小，单位为MB。

\item {} 
\sphinxAtStartPar
features：节点可用特性，参见features\_act。

\item {} 
\sphinxAtStartPar
features\_act：激活的特性，参见features。

\item {} 
\sphinxAtStartPar
groups：可以使用此节点的用户组。

\item {} 
\sphinxAtStartPar
gres：与节点关联的通用资源（gres）。

\item {} 
\sphinxAtStartPar
maxcpuspernode：队列中各节点最大可用CPU数。

\item {} 
\sphinxAtStartPar
memory：节点内存，单位MB。

\item {} 
\sphinxAtStartPar
nodeai：以“allocated/idle”格式显示状态对应的节点数。

\item {} 
\sphinxAtStartPar
nodes：节点数。

\item {} 
\sphinxAtStartPar
nodeaiot：以“allocated/idle/other/total”格式状态的节点数。

\item {} 
\sphinxAtStartPar
nodehost：节点主机名。

\item {} 
\sphinxAtStartPar
nodelist：节点名，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
oversubscribe：作业是否能超用计算资源（如CPUs），显示结果可以为yes、no、exclusive或force。

\item {} 
\sphinxAtStartPar
partition：队列名，带有*为默认队列，参见\%R。

\item {} 
\sphinxAtStartPar
partitionname：队列名，默认队列不附加*，参见\%P。

\item {} 
\sphinxAtStartPar
preemptmode：抢占模式，可以为no或yes。

\item {} 
\sphinxAtStartPar
priorityjobfactor：队列作业权重因子。

\item {} 
\sphinxAtStartPar
prioritytier或priority：队列调度优先级。

\item {} 
\sphinxAtStartPar
reason：节点无效的原因（down、draine或ddraining状态）。

\item {} 
\sphinxAtStartPar
size：节点最大作业数。

\item {} 
\sphinxAtStartPar
statecompact：紧凑格式节点状态。

\item {} 
\sphinxAtStartPar
statelong：扩展格式节点状态。

\item {} 
\sphinxAtStartPar
sockets：各节点CPU颗数。

\item {} 
\sphinxAtStartPar
socketcorethread：扩展方式显示单节点处理器信息：sockets、cores、threads（S:C:T）数。

\item {} 
\sphinxAtStartPar
time：以“days\sphinxhyphen{}hours:minutes:seconds”格式显示作业可最长运行时间。

\item {} 
\sphinxAtStartPar
timestamp：节点不可用信息的时间戳。

\item {} 
\sphinxAtStartPar
threads：CPU核线程数。

\item {} 
\sphinxAtStartPar
weight：节点调度权重。

\item {} 
\sphinxAtStartPar
version：slurmd守护进程版本。

\end{itemize}

\end{itemize}

\end{itemize}


\section{查看队列中的作业信息：squeue}
\label{\detokenize{slurm/slurm:squeue}}
\sphinxAtStartPar
显示队列中的作业信息。如\sphinxcode{\sphinxupquote{squeue}}显示：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{JOBID} \PYG{n}{PARTITION}      \PYG{n}{NAME}     \PYG{n}{USER} \PYG{n}{ST}       \PYG{n}{TIME}  \PYG{n}{NODES} \PYG{n}{NODELIST}\PYG{p}{(}\PYG{n}{REASON}\PYG{p}{)}
 \PYG{l+m+mi}{75}     \PYG{n}{ARM}\PYG{o}{\PYGZhy{}}\PYG{n}{CPU}   \PYG{n}{arm\PYGZus{}job}     \PYG{n}{hmli}  \PYG{n}{R}       \PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{27}      \PYG{l+m+mi}{2} \PYG{n}{rnode}\PYG{p}{[}\PYG{l+m+mi}{02}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{03}\PYG{p}{]}
 \PYG{l+m+mi}{76}    \PYG{n}{GPU}\PYG{o}{\PYGZhy{}}\PYG{n}{V100} \PYG{n}{gpu}\PYG{o}{.}\PYG{n}{slurm}     \PYG{n}{hmli} \PYG{n}{PD}       \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{00}      \PYG{l+m+mi}{5} \PYG{p}{(}\PYG{n}{Resources}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{主要输出项}
\label{\detokenize{slurm/slurm:id9}}\label{\detokenize{slurm/slurm:id10}}\begin{itemize}
\item {} 
\sphinxAtStartPar
JOBID：作业号。

\item {} 
\sphinxAtStartPar
PARTITION：队列名（分区名）。

\item {} 
\sphinxAtStartPar
NAME：作业名。

\item {} 
\sphinxAtStartPar
USER：用户名。

\item {} 
\sphinxAtStartPar
ST：状态。
\begin{itemize}
\item {} 
\sphinxAtStartPar
PD：排队中，PENDING。

\item {} 
\sphinxAtStartPar
R：运行中，RUNNING。

\item {} 
\sphinxAtStartPar
CA：已取消，CANCELLED。

\item {} 
\sphinxAtStartPar
CF：配置中，CONFIGURING。

\item {} 
\sphinxAtStartPar
CG：完成中，COMPLETING

\item {} 
\sphinxAtStartPar
CD：已完成，COMPLETED。

\item {} 
\sphinxAtStartPar
F：已失败，FAILED。

\item {} 
\sphinxAtStartPar
TO：超时，TIMEOUT。

\item {} 
\sphinxAtStartPar
NF：节点失效，NODE FAILURE。

\item {} 
\sphinxAtStartPar
SE：特殊退出状态，SPECIAL EXIT STATE。

\end{itemize}

\item {} 
\sphinxAtStartPar
TIME：已运行时间。

\item {} 
\sphinxAtStartPar
NODELIST(REASON)：分配给的节点名列表（原因）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
AssociationCpuLimit： 作业指定的关联CPU已在用，作业最终会运行。

\item {} 
\sphinxAtStartPar
AssociationMaxJobsLimit：作业关联的最大作业数已到，作业最终会运行。

\item {} 
\sphinxAtStartPar
AssociationNodeLimit：作业指定的关联节点已在用，作业最终会运行。

\item {} 
\sphinxAtStartPar
AssociationJobLimit：作业达到其最大允许的作业数限制。

\item {} 
\sphinxAtStartPar
AssociationResourceLimit：作业达到其最大允许的资源限制。

\item {} 
\sphinxAtStartPar
AssociationTimeLimit：作业达到时间限制。

\item {} 
\sphinxAtStartPar
BadConstraints：作业含有无法满足的约束。

\item {} 
\sphinxAtStartPar
BeginTime：作业最早开始时间尚未达到。

\item {} 
\sphinxAtStartPar
Cleaning：作业被重新排入队列，并且仍旧在执行之前运行的清理工作。

\item {} 
\sphinxAtStartPar
Dependency：作业等待一个依赖的作业结束后才能运行。

\item {} 
\sphinxAtStartPar
FrontEndDown：没有前端节点可用于执行此作业。

\item {} 
\sphinxAtStartPar
InactiveLimit：作业达到系统非激活限制。

\item {} 
\sphinxAtStartPar
InvalidAccount：作业用户无效，建议取消该作业重新采用正确账户提交。

\item {} 
\sphinxAtStartPar
InvalidQOS：作业QOS无效，建议取消该作业重新采用正确QoS提交。

\item {} 
\sphinxAtStartPar
JobHeldAdmin：作业被系统管理员挂起。

\item {} 
\sphinxAtStartPar
JobHeldUser：作业被用户自己挂起。

\item {} 
\sphinxAtStartPar
JobLaunchFailure：作业无法被启动，有可能因为文件系统故障、无效程序名等。

\item {} 
\sphinxAtStartPar
Licenses：作业等待相应的授权。

\item {} 
\sphinxAtStartPar
NodeDown：作业所需的节点宕机。

\item {} 
\sphinxAtStartPar
NonZeroExitCode：作业停止时退出代码非零。

\item {} 
\sphinxAtStartPar
PartitionDown：作业所需的队列出于DOWN状态。

\item {} 
\sphinxAtStartPar
PartitionInactive：作业所需的队列处于Inactive状态。

\item {} 
\sphinxAtStartPar
PartitionNodeLimit：作业所需的节点超过所用队列当前限制。

\item {} 
\sphinxAtStartPar
PartitionTimeLimit：作业所需的队列达到时间限制。

\item {} 
\sphinxAtStartPar
PartitionCpuLimit：该作业使用的队列对应的CPU已经被使用，作业最终会运行。

\item {} 
\sphinxAtStartPar
PartitionMaxJobsLimit：该作业使用的队列的最大作业数已到，作业最终会运行。

\item {} 
\sphinxAtStartPar
PartitionNodeLimit：该作业使用的队列对指定的节点都已在用，作业最终会运行。

\item {} 
\sphinxAtStartPar
Priority：作业所需的队列存在高等级作业或预留。

\item {} 
\sphinxAtStartPar
Prolog：作业的PrologSlurmctld前处理程序仍旧在运行。

\item {} 
\sphinxAtStartPar
QOSJobLimit：作业的QOS达到其最大作业数限制。

\item {} 
\sphinxAtStartPar
QOSResourceLimit：作业的QOS达到其最大资源限制。

\item {} 
\sphinxAtStartPar
QOSGrpCpuLimit： 作业的QoS的指定所有CPU已被占用，作业最终会运行。

\item {} 
\sphinxAtStartPar
QOSGrpMaxJobsLimit：作业的QoS的最大作业数已到，作业最终会运行。

\item {} 
\sphinxAtStartPar
QOSGrpNodeLimit：作业的QoS指定的节点都已经被占用，作业最终会运行。

\item {} 
\sphinxAtStartPar
QOSTimeLimit：作业的QOS达到其时间限制。

\item {} 
\sphinxAtStartPar
QOSUsageThreshold：所需的QOS阈值被违反。

\item {} 
\sphinxAtStartPar
ReqNodeNotAvail：作业所需的节点无效，如节点宕机。

\item {} 
\sphinxAtStartPar
Reservation：作业等待其预留的资源可用。

\item {} 
\sphinxAtStartPar
Resources：作业将要等待所需要的资源满足后才运行。

\item {} 
\sphinxAtStartPar
SystemFailure：Slurm系统失效，如文件系统、网络失效等。

\item {} 
\sphinxAtStartPar
TimeLimit：作业超过去时间限制。

\item {} 
\sphinxAtStartPar
QOSUsageThreshold：所需的QoS阈值被违反。

\item {} 
\sphinxAtStartPar
WaitingForScheduling：等待被调度中。

\end{itemize}

\end{itemize}


\subsection{主要参数}
\label{\detokenize{slurm/slurm:id11}}\label{\detokenize{slurm/slurm:id12}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}A <account\_list>, \sphinxhyphen{}\sphinxhyphen{}account=<account\_list>：显示用户<account\_list>的作业信息，用户以,分隔。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}a, \sphinxhyphen{}\sphinxhyphen{}all：显示所有队列中的作业及作业步信息，也显示被配置为对用户组隐藏队列的信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}r, \sphinxhyphen{}\sphinxhyphen{}array：以每行一个作业元素方式显示。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}h, \sphinxhyphen{}\sphinxhyphen{}noheader：不显示头信息，即不显示第一行“PARTITION AVAIL TIMELIMIT NODES STATE NODELIST”。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}help：显示帮助信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}hide：不显示隐藏队列中的作业和作业步信息。此为默认行为，不显示配置为对用户组隐藏队列的信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}i <seconds>, \sphinxhyphen{}\sphinxhyphen{}iterate=<seconds>：以间隔<seconds>秒方式循环显示信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}j <job\_id\_list>, \sphinxhyphen{}\sphinxhyphen{}jobs=<job\_id\_list>：显示作业号<job\_id\_list>的作业，作业号以,分隔。\sphinxhyphen{}\sphinxhyphen{}jobs=<job\_id\_list>可与\sphinxhyphen{}\sphinxhyphen{}steps选项结合显示特定作业的步信息。作业号格式为“job\_id{[}\_array\_id{]}”，默认为64字节，可以用环境变量SLURM\_BITSTR\_LEN设定更大的字段大小。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}l, \sphinxhyphen{}\sphinxhyphen{}long：显示更多的作业信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}L, \sphinxhyphen{}\sphinxhyphen{}licenses=<license\_list>：指定使用授权文件<license\_list>，以,分隔。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}n, \sphinxhyphen{}\sphinxhyphen{}name=<name\_list>：显示具有特定<name\_list>名字的作业，以,分隔。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}noconvert：不对原始单位做转换，如2048M不转换为2G。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}p <part\_list>, \sphinxhyphen{}\sphinxhyphen{}partition=<part\_list>：显示特定队列<part\_list>信息，<part\_list>以,分隔。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}P, \sphinxhyphen{}\sphinxhyphen{}priority：对于提交到多个队列的作业，按照各队列显示其信息。如果作业要按照优先级排序时，需考虑队列和作业优先级。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}q <qos\_list>, \sphinxhyphen{}\sphinxhyphen{}qos=<qos\_list>：显示特定qos的作业和作业步，<qos\_list>以,分隔。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}R, \sphinxhyphen{}\sphinxhyphen{}reservation=reservation\_name：显示特定预留信息作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}s, \sphinxhyphen{}\sphinxhyphen{}steps：显示特定作业步。作业步格式为“job\_id{[}\_array\_id{]}.step\_id”。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}S <sort\_list>, \sphinxhyphen{}\sphinxhyphen{}sort=<sort\_list>：按照显示特定字段排序显示，<sort\_list>以,分隔。如\sphinxhyphen{}S P,U。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}start：显示排队中的作业的预期执行时间。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}t <state\_list>, \sphinxhyphen{}\sphinxhyphen{}states=<state\_list>：显示特定状态<state\_list>的作业信息。<state\_list>以,分隔，有效的可为：PENDING(PD)、RUNNING(R)、SUSPENDED(S)、STOPPED(ST)、COMPLETING(CG)、COMPLETED(CD)、CONFIGURING(CF)、CANCELLED(CA)、FAILED(F)、TIMEOUT(TO)、PREEMPTED(PR)、BOOT\_FAIL(BF)、NODE\_FAIL(NF)和SPECIAL\_EXIT(SE)，注意是不区分大小写的，如“pd”和“PD”是等效的。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}u <user\_list>, \sphinxhyphen{}\sphinxhyphen{}user=<user\_list>：显示特定用户<user\_list>的作业信息，<user\_list>以,分隔。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}usage：显示帮助信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}v, \sphinxhyphen{}\sphinxhyphen{}verbose：显示squeue命令详细动作信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}V, \sphinxhyphen{}\sphinxhyphen{}version：显示版本信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}w <hostlist>, \sphinxhyphen{}\sphinxhyphen{}nodelist=<hostlist>：显示特定节点<hostlist>信息，<hostlist>以,分隔。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}o <output\_format>, \sphinxhyphen{}\sphinxhyphen{}format=<output\_format>：以特定格式<output\_format>显示信息。参见 \sphinxhyphen{}O <output\_format>, \sphinxhyphen{}\sphinxhyphen{}Format=<output\_format>，采用不同参数的默认格式为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
default：“\%.18i \%.9P \%.8j \%.8u \%.2t \%.10M \%.6D \%R”

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}l, \sphinxhyphen{}\sphinxhyphen{}long： “\%.18i \%.9P \%.8j \%.8u \%.8T \%.10M \%.9l \%.6D \%R”

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}s, \sphinxhyphen{}\sphinxhyphen{}steps：“\%.15i \%.8j \%.9P \%.8u \%.9M \%N”

\end{itemize}

\sphinxAtStartPar
每个字段的格式为“\%{[}{[}.{]}size{]}type”：
\begin{itemize}
\item {} 
\sphinxAtStartPar
size：字段最小尺寸，如果没有指定size，则按照所需长度显示。

\item {} 
\sphinxAtStartPar
.：右对齐显示，默认为左对齐。

\item {} 
\sphinxAtStartPar
type：类型，一些类型仅对作业有效，而有些仅对作业步有效，有效的类型为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\%all：显示所有字段。

\item {} 
\sphinxAtStartPar
\%a：显示记帐信息（仅对作业有效）。

\item {} 
\sphinxAtStartPar
\%A：作业步生成的任务数（仅适用于作业步）。

\item {} 
\sphinxAtStartPar
\%A：作业号（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%b：作业或作业步所需的普通资源（gres）。

\item {} 
\sphinxAtStartPar
\%B：执行作业的节点。

\item {} 
\sphinxAtStartPar
\%c：作业每个节点所需的最小CPU数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%C：如果作业还在运行，显示作业所需的CPU数；如果作业正在完成，显示当前分配给此作业的CPU数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%d：作业所需的最小临时磁盘空间，单位MB（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%D：作业所需的节点（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%e：作业结束或预期结束时间（基于其时间限制）（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%E：作业依赖剩余情况。作业只有依赖的作业完成才运行，如显示NULL，则无依赖（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%f：作业所需的特性（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%F：作业组作业号（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%g：作业用户组（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%G：作业用户组ID（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%h：分配给此作业的计算资源能否被其它作业预约（仅适用于作业）。可被预约的资源包含节点、CPU颗、CPU核或超线程。值可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
YES：如果作业提交时含有oversubscribe选项或队列被配置含有OverSubscribe=Force。

\item {} 
\sphinxAtStartPar
NO：如果作业所需排他性运行。

\item {} 
\sphinxAtStartPar
USER：如果分配的计算节点设定为单个用户。

\item {} 
\sphinxAtStartPar
MCS：如果分配的计算节点设定为单个安全类（参看MCSPlugin和MCSParameters配置参数，Multi\sphinxhyphen{}Category Security）。

\item {} 
\sphinxAtStartPar
OK：其它（典型的分配给专用的CPU）（仅适用于作业）。

\end{itemize}

\item {} 
\sphinxAtStartPar
\%H：作业所需的单节点CPU数，显示srun \sphinxhyphen{}\sphinxhyphen{}sockets\sphinxhyphen{}per\sphinxhyphen{}node提交选项，如\sphinxhyphen{}\sphinxhyphen{}sockets\sphinxhyphen{}per\sphinxhyphen{}node未设定，则显示*（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%i：作业或作业步号，在作业组中，作业号格式为“<base\_job\_id>\_<index>”，默认作业组索引字段限制到64字节，可以用环境变量\sphinxcode{\sphinxupquote{SLURM\_BITSTR\_LEN}}设定为更大的字段大小。

\item {} 
\sphinxAtStartPar
\%I：作业所需的每颗CPU的CPU核数，显示的是srun \sphinxhyphen{}\sphinxhyphen{}cores\sphinxhyphen{}per\sphinxhyphen{}socket设定的值，如\sphinxhyphen{}\sphinxhyphen{}cores\sphinxhyphen{}per\sphinxhyphen{}socket未设定，则显示*（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%j：作业或作业步名。

\item {} 
\sphinxAtStartPar
\%J：作业所需的每个CPU核的线程数，显示的是srun \sphinxhyphen{}\sphinxhyphen{}threads\sphinxhyphen{}per\sphinxhyphen{}core设定的值，如\sphinxhyphen{}\sphinxhyphen{}threads\sphinxhyphen{}per\sphinxhyphen{}core未被设置则显示*（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%k：作业说明（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%K：作业组索引默认作业组索引字段限制到64字节，可以用环境变量\sphinxcode{\sphinxupquote{SLURM\_BITSTR\_LEN}}设定为更大的字段大小（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%l：作业或作业步时间限制，格式为“days\sphinxhyphen{}hours:minutes:seconds”：NOT\_SET表示没有建立；UNLIMITED表示没有限制。

\item {} 
\sphinxAtStartPar
\%L：作业剩余时间，格式为“days\sphinxhyphen{}hours:minutes:seconds”，此值由作业的时间限制减去已用时间得到：NOT\_SET表示没有建立；UNLIMITED表示没有限制（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%m：作业所需的最小内存，单位为MB（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%M：作业或作业步已经使用的时间，格式为“days\sphinxhyphen{}hours:minutes:seconds”。

\item {} 
\sphinxAtStartPar
\%n：作业所需的节点名（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%N：作业或作业步分配的节点名，对于正在完成的作业，仅显示尚未释放资源回归服务的节点。

\item {} 
\sphinxAtStartPar
\%o：执行的命令。

\item {} 
\sphinxAtStartPar
\%O：作业是否需连续节点（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%p：作业的优先级（0.0到1.0之间），参见\%Q（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%P：作业或作业步的队列。

\item {} 
\sphinxAtStartPar
\%q：作业关联服务的品质（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%Q：作业优先级（通常为非常大的一个无符号整数），参见\%p（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%r：作业在当前状态的原因，参见JOB REASON CODES（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%R：参见JOB REASON CODES（仅适用于作业）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
对于排队中的作业：作业没有执行的原因。

\item {} 
\sphinxAtStartPar
对于出错终止的作业：作业出错的解释。

\item {} 
\sphinxAtStartPar
对于其他作业状态：分配的节点。

\end{itemize}

\item {} 
\sphinxAtStartPar
\%S：作业或作业步实际或预期的开始时间。

\item {} 
\sphinxAtStartPar
\%t：作业状态，以紧凑格式显示：PD（排队pending）、R（运行running）、CA（取消cancelled）、CF(配置中configuring）、CG（完成中completing）、CD（已完成completed）、F（失败failed）、TO（超时timeout）、NF（节点失效node failure)和SE（特殊退出状态special exit state），参见JOB STATE CODES（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%T：作业状态，以扩展格式显示：PENDING、RUNNING、SUSPENDED、CANCELLED、COMPLETING、COMPLETED、CONFIGURING、FAILED、TIMEOUT、PREEMPTED、NODE\_FAIL和SPECIAL\_EXIT，参见JOB STATE CODES（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%u：作业或作业步的用户名。

\item {} 
\sphinxAtStartPar
\%U：作业或作业步的用户ID。

\item {} 
\sphinxAtStartPar
\%v：作业的预留资源（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%V：作业的提交时间。

\item {} 
\sphinxAtStartPar
\%w：工程量特性关键Workload Characterization Key（wckey）（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%W：作业预留的授权（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%x：作业排他性节点名（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%X：系统使用需每个节点预留的CPU核数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%y：Nice值（调整作业调动优先级）（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%Y：对于排队中作业，显示其开始运行时期望的节点名。

\item {} 
\sphinxAtStartPar
\%z：作业所需的每个节点的CPU颗数、CPU核数和线程数（S:C:T），如（S:C:T）未设置，则显示*（仅适用于作业）。

\item {} 
\sphinxAtStartPar
\%Z：作业的工作目录。

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}O <output\_format>, \sphinxhyphen{}\sphinxhyphen{}Format=<output\_format>：以特定格式<output\_format>显示信息，参见\sphinxhyphen{}o <output\_format>, \sphinxhyphen{}\sphinxhyphen{}format=<output\_format> 每个字段的格式为“\%{[}{[}.{]}size{]}type”：
\begin{itemize}
\item {} 
\sphinxAtStartPar
size：字段最小尺寸，如果没有指定size，则最长显示20个字符。

\item {} 
\sphinxAtStartPar
.：右对齐显示，默认为左对齐。

\item {} 
\sphinxAtStartPar
type：类型，一些类型仅对作业有效，而有些仅对作业步有效，有效的类型为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
account：作业记账信息（仅适用于作业）。

\item {} 
\sphinxAtStartPar
allocnodes：作业分配的节点（仅适用于作业）。

\item {} 
\sphinxAtStartPar
allocsid：用于提交作业的会话ID（仅适用于作业）。

\item {} 
\sphinxAtStartPar
arrayjobid：作业组中的作业ID。

\item {} 
\sphinxAtStartPar
arraytaskid：作业组中的任务ID。

\item {} 
\sphinxAtStartPar
associd：作业关联ID（仅适用于作业）。

\item {} 
\sphinxAtStartPar
batchflag：是否批处理设定了标记（仅适用于作业）。

\item {} 
\sphinxAtStartPar
batchhost：执行节点（仅适用于作业）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
对于分配的会话：显示的是会话执行的节点（如，\sphinxcode{\sphinxupquote{srun}}或\sphinxcode{\sphinxupquote{salloc}}命令执行的节点）。

\item {} 
\sphinxAtStartPar
对于批处理作业：显示的执行批处理的节点。

\end{itemize}

\item {} 
\sphinxAtStartPar
chptdir：作业checkpoint的写目录（仅适用于作业步）。

\item {} 
\sphinxAtStartPar
chptinter：作业checkpoint时间间隔（仅适用于作业步）。

\item {} 
\sphinxAtStartPar
command：作业执行的命令（仅适用于作业）。

\item {} 
\sphinxAtStartPar
comment：作业关联的说明（仅适用于作业）。

\item {} 
\sphinxAtStartPar
contiguous：作业是否要求连续节点（仅适用于作业）。

\item {} 
\sphinxAtStartPar
cores：作业所需的每颗CPU的CPU核数，显示的是srun \sphinxhyphen{}\sphinxhyphen{}cores\sphinxhyphen{}per\sphinxhyphen{}socket设定的值，如\sphinxhyphen{}\sphinxhyphen{}cores\sphinxhyphen{}per\sphinxhyphen{}socket未设定，则显示*（仅适用于作业）。

\item {} 
\sphinxAtStartPar
corespec：为了系统使用所预留的CPU核数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
cpufreq：分配的CPU主频（仅适用于作业步）。

\item {} 
\sphinxAtStartPar
cpuspertask：作业分配的每个任务的CPU颗数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
deadline：作业的截止时间（仅适用于作业）。

\item {} 
\sphinxAtStartPar
dependency：作业依赖剩余。作业只有依赖的作业完成才运行，如显示NULL，则无依赖（仅适用于作业）。

\item {} 
\sphinxAtStartPar
derivedec：作业的起源退出码，对任意作业步是最高退出码（仅适用于作业）。

\item {} 
\sphinxAtStartPar
eligibletime：预计作业开始运行时间（仅适用于作业）。

\item {} 
\sphinxAtStartPar
endtime：作业实际或预期的终止时间（仅适用于作业）。

\item {} 
\sphinxAtStartPar
exit\_code：作业退出码（仅适用于作业）。

\item {} 
\sphinxAtStartPar
feature：作业所需的特性（仅适用于作业）。

\item {} 
\sphinxAtStartPar
gres：作业或作业步需的通用资源（gres）。

\item {} 
\sphinxAtStartPar
groupid：作业用户组ID（仅适用于作业）。

\item {} 
\sphinxAtStartPar
groupname：作业用户组名（仅适用于作业）。

\item {} 
\sphinxAtStartPar
jobarrayid：作业组作业ID（仅适用于作业）。

\item {} 
\sphinxAtStartPar
jobid：作业号（仅适用于作业）。

\item {} 
\sphinxAtStartPar
licenses：作业预留的授权（仅适用于作业）。

\item {} 
\sphinxAtStartPar
maxcpus：分配给作业的最大CPU颗数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
maxnodes：分配给作业的最大节点数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
mcslabel：作业的MCS\_label（仅适用于作业）。

\item {} 
\sphinxAtStartPar
minmemory：作业所需的最小内存大小，单位MB（仅适用于作业）。

\item {} 
\sphinxAtStartPar
mintime：作业的最小时间限制（仅适用于作业）。

\item {} 
\sphinxAtStartPar
mintmpdisk：作业所需的临时磁盘空间，单位MB（仅适用于作业）。

\item {} 
\sphinxAtStartPar
mincpus：作业所需的各节点最小CPU颗数，显示的是\sphinxcode{\sphinxupquote{srun \sphinxhyphen{}\sphinxhyphen{}mincpus}}设定的值（仅适用于作业）。

\item {} 
\sphinxAtStartPar
name：作业或作业步名。

\item {} 
\sphinxAtStartPar
network：作业运行的网络。

\item {} 
\sphinxAtStartPar
nice Nice值(调整作业调度优先值)（仅适用于作业）。

\item {} 
\sphinxAtStartPar
nodes：作业或作业步分配的节点名，对于正在完成的作业，仅显示尚未释放资源回归服务的节点。

\item {} 
\sphinxAtStartPar
nodelist：作业或作业步分配的节点，对于正在完成的作业，仅显示尚未释放资源回归服务的节点，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
ntpercore：作业每个CPU核分配的任务数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
ntpernode：作业每个节点分配的任务数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
ntpersocket：作业每颗CPU分配的任务数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
numcpus：作业所需的或分配的CPU颗数。

\item {} 
\sphinxAtStartPar
numnodes：作业所需的或分配的最小节点数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
numtask：作业或作业号需的任务数，显示的\sphinxhyphen{}\sphinxhyphen{}ntasks设定的。

\item {} 
\sphinxAtStartPar
oversubscribe：分配给此作业的计算资源能否被其它作业预约（仅适用于作业）。可被预约的资源包含节点、CPU颗、CPU核或超线程。值可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
YES：如果作业提交时含有oversubscribe选项或队列被配置含有OverSubscribe=Force。

\item {} 
\sphinxAtStartPar
NO：如果作业所需排他性运行。

\item {} 
\sphinxAtStartPar
USER：如果分配的计算节点设定为单个用户。

\item {} 
\sphinxAtStartPar
MCS：如果分配的计算节点设定为单个安全类（参看MCSPlugin和MCSParameters配置参数）。

\item {} 
\sphinxAtStartPar
OK：其它(典型分配给指定CPU)。

\end{itemize}

\item {} 
\sphinxAtStartPar
partition：作业或作业步的队列。

\item {} 
\sphinxAtStartPar
priority：作业的优先级（0.0到1.0之间），参见\%Q（仅适用于作业）。

\item {} 
\sphinxAtStartPar
prioritylong：作业优先级（通常为非常大的一个无符号整数），参见\%p（仅适用于作业）。

\item {} 
\sphinxAtStartPar
profile：作业特征（仅适用于作业）。

\item {} 
\sphinxAtStartPar
preemptime：作业抢占时间（仅适用于作业）。

\item {} 
\sphinxAtStartPar
qos：作业的服务质量（仅适用于作业）。

\item {} 
\sphinxAtStartPar
reason：作业在当前的原因，参见JOB REASON CODES（仅适用于作业）。

\item {} 
\sphinxAtStartPar
reasonlist：参见JOB REASON CODES（仅适用于作业）。
\begin{itemize}
\item {} 
\sphinxAtStartPar
对于排队中的作业：作业没有执行的原因。

\item {} 
\sphinxAtStartPar
对于出错终止的作业：作业出错的解释。

\item {} 
\sphinxAtStartPar
对于其他作业状态：分配的节点。

\end{itemize}

\item {} 
\sphinxAtStartPar
reqnodes：作业所需的节点名（仅适用于作业）。

\item {} 
\sphinxAtStartPar
requeue：作业失败时是否需重新排队运行（仅适用于作业）。

\item {} 
\sphinxAtStartPar
reservation：预留资源（仅适用于作业）。

\item {} 
\sphinxAtStartPar
resizetime：运行作业的变化时间总和（仅适用于作业）。

\item {} 
\sphinxAtStartPar
restartcnt：作业的重启checkpoint数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
resvport：作业的预留端口（仅适用于作业步）。

\item {} 
\sphinxAtStartPar
schednodes：排队中的作业开始运行时预期将被用的节点列表（仅适用于作业）。

\item {} 
\sphinxAtStartPar
sct：各节点作业所需的CPU数、CPU核数和线程数（S:C:T），如（S:C:T）未设置，则显示*（仅适用于作业）。

\item {} 
\sphinxAtStartPar
selectjobinfo：节点选择插件针对作业指定的数据，可能的数据包含：资源分配的几何维度（X、Y、Z维度）、连接类型（TORUS、MESH或NAV == torus else mesh），是否允许几何旋转（yes或no），节点使用（VIRTUAL或COPROCESSOR）等（仅适用于作业）。

\item {} 
\sphinxAtStartPar
sockets：作业每个节点需的CPU数，显示srun时的\sphinxhyphen{}\sphinxhyphen{}sockets\sphinxhyphen{}per\sphinxhyphen{}node选项，如\sphinxhyphen{}\sphinxhyphen{}sockets\sphinxhyphen{}per\sphinxhyphen{}node未设置，则显示*（仅适用于作业）。

\item {} 
\sphinxAtStartPar
sperboard：每个主板分配给作业的CPU数（仅适用于作业）。

\item {} 
\sphinxAtStartPar
starttime：作业或作业布实际或预期开始时间。

\item {} 
\sphinxAtStartPar
state：扩展格式作业状态：排队中PENDING、运行中RUNNING、已停止STOPPED、被挂起SUSPENDED、被取消CANCELLED、完成中COMPLETING、已完成COMPLETED、配置中CONFIGURING、已失败FAILED、超时TIMEOUT、预取PREEMPTED、节点失效NODE\_FAIL、特定退出SPECIAL\_EXIT，参见JOB STATE CODES部分（仅适用于作业）。

\item {} 
\sphinxAtStartPar
statecompact：紧凑格式作业状态：PD（排队中pending）、R（运行中running）、CA（已取消cancelled）、CF(配置中configuring）、CG（完成中completing）、CD（已完成completed）、F（已失败failed）、TO（超时timeout）、NF（节点失效node failure）和SE（特定退出状态special exit state），参见JOB STATE CODES部分（仅适用于作业）。

\item {} 
\sphinxAtStartPar
stderr：标准出错输出目录（仅适用于作业）。

\item {} 
\sphinxAtStartPar
stdin：标准输入目录（仅适用于作业）。

\item {} 
\sphinxAtStartPar
stdout：标准输出目录（仅适用于作业）。

\item {} 
\sphinxAtStartPar
stepid：作业或作业步号。在作业组中，作业号格式为“<base\_job\_id>\_<index>”（仅适用于作业步）。

\item {} 
\sphinxAtStartPar
stepname：作业步名（仅适用于作业步）。

\item {} 
\sphinxAtStartPar
stepstate：作业步状态（仅适用于作业步）。

\item {} 
\sphinxAtStartPar
submittime：作业提交时间（仅适用于作业）。

\item {} 
\sphinxAtStartPar
threads：作业所需的每颗CPU核的线程数，显示srun的\sphinxhyphen{}\sphinxhyphen{}threads\sphinxhyphen{}per\sphinxhyphen{}core参数，如\sphinxhyphen{}\sphinxhyphen{}threads\sphinxhyphen{}per\sphinxhyphen{}core未设置，则显示*（仅适用于作业）。

\item {} 
\sphinxAtStartPar
timeleft：作业剩余时间，格式为“days\sphinxhyphen{}hours:minutes:seconds”，此值是通过其时间限制减去已运行时间得出的：如未建立则显示“NOT\_SET”；如无限制则显示“UNLIMITED”（仅适用于作业）。

\item {} 
\sphinxAtStartPar
timelimit：作业或作业步的时间限制。

\item {} 
\sphinxAtStartPar
timeused：作业或作业步以使用时间，格式为“days\sphinxhyphen{}hours:minutes:seconds”，days和hours只有需要时才显示。对于作业步，显示从执行开始经过的时间，因此对于被曾挂起的作业并不准确。节点间的时间差也会导致时间不准确。如时间不对（如，负值），将显示“INVALID”。

\item {} 
\sphinxAtStartPar
tres：显示分配给作业的可被追踪的资源。

\item {} 
\sphinxAtStartPar
userid：作业或作业步的用户ID。

\item {} 
\sphinxAtStartPar
username：作业或作业步的用户名。

\item {} 
\sphinxAtStartPar
wait4switch：需满足转轨器数目的总等待时间（仅适用于作业）。

\item {} 
\sphinxAtStartPar
wckey：工作负荷特征关键（wckey）（仅适用于作业）。

\item {} 
\sphinxAtStartPar
workdir：作业工作目录（仅适用于作业）。

\end{itemize}

\end{itemize}

\end{itemize}


\section{查看详细队列信息：scontrol show partition}
\label{\detokenize{slurm/slurm:scontrol-show-partition}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scontrol show partition}}显示全部队列信息，\sphinxcode{\sphinxupquote{scontrol show partition PartitionName}}或
\sphinxcode{\sphinxupquote{scontrol show partition=PartitionName}}显示队列名PartitionName的队列信息，输出类似：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PartitionName}\PYG{o}{=}\PYG{n}{CPU}\PYG{o}{\PYGZhy{}}\PYG{n}{Large} \PYG{n}{AllowGroups}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{AllowAccounts}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{AllowQos}\PYG{o}{=}\PYG{n}{ALL}
\PYG{n}{AllocNodes}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{Default}\PYG{o}{=}\PYG{n}{YES} \PYG{n}{QoS}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A} \PYG{n}{DefaultTime}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{DisableRootJobs}\PYG{o}{=}\PYG{n}{YES}
\PYG{n}{ExclusiveUser}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{GraceTime}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{Hidden}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{MaxNodes}\PYG{o}{=}\PYG{n}{UNLIMITED}
\PYG{n}{MaxTime}\PYG{o}{=}\PYG{n}{UNLIMITED} \PYG{n}{MinNodes}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{LLN}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{MaxCPUsPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED}
\PYG{n}{Nodes}\PYG{o}{=}\PYG{n}{cnode}\PYG{p}{[}\PYG{l+m+mi}{001}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{720}\PYG{p}{]} \PYG{n}{PriorityJobFactor}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{PriorityTier}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{RootOnly}\PYG{o}{=}\PYG{n}{NO}
\PYG{n}{ReqResv}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{OverSubscribe}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{OverTimeLimit}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{PreemptMode}\PYG{o}{=}\PYG{n}{OFF} \PYG{n}{State}\PYG{o}{=}\PYG{n}{UP}
\PYG{n}{TotalCPUs}\PYG{o}{=}\PYG{l+m+mi}{28800} \PYG{n}{TotalNodes}\PYG{o}{=}\PYG{l+m+mi}{720} \PYG{n}{SelectTypeParameters}\PYG{o}{=}\PYG{n}{NONE}
\PYG{n}{JobDefaults}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)} \PYG{n}{DefMemPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED} \PYG{n}{MaxMemPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED}

\PYG{n}{PartitionName}\PYG{o}{=}\PYG{n}{GPU}\PYG{o}{\PYGZhy{}}\PYG{n}{V100} \PYG{n}{AllowGroups}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{AllowAccounts}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{AllowQos}\PYG{o}{=}\PYG{n}{ALL}
\PYG{n}{AllocNodes}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{Default}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{QoS}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A} \PYG{n}{DefaultTime}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{DisableRootJobs}\PYG{o}{=}\PYG{n}{YES}
\PYG{n}{ExclusiveUser}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{GraceTime}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{Hidden}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{MaxNodes}\PYG{o}{=}\PYG{n}{UNLIMITED}
\PYG{n}{MaxTime}\PYG{o}{=}\PYG{n}{UNLIMITED} \PYG{n}{MinNodes}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{LLN}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{MaxCPUsPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED}
\PYG{n}{Nodes}\PYG{o}{=}\PYG{n}{gnode}\PYG{p}{[}\PYG{l+m+mi}{01}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{n}{PriorityJobFactor}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{PriorityTier}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{RootOnly}\PYG{o}{=}\PYG{n}{NO}
\PYG{n}{ReqResv}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{OverSubscribe}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{OverTimeLimit}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{PreemptMode}\PYG{o}{=}\PYG{n}{OFF} \PYG{n}{State}\PYG{o}{=}\PYG{n}{UP}
\PYG{n}{TotalCPUs}\PYG{o}{=}\PYG{l+m+mi}{400} \PYG{n}{TotalNodes}\PYG{o}{=}\PYG{l+m+mi}{10} \PYG{n}{SelectTypeParameters}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{JobDefaults}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
\PYG{n}{DefMemPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED} \PYG{n}{MaxMemPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED}

\PYG{n}{PartitionName}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{n}{TB}\PYG{o}{\PYGZhy{}}\PYG{n}{AEP}\PYG{o}{\PYGZhy{}}\PYG{n}{Mem} \PYG{n}{AllowGroups}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{AllowAccounts}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{AllowQos}\PYG{o}{=}\PYG{n}{ALL}
\PYG{n}{AllocNodes}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{Default}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{QoS}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A} \PYG{n}{DefaultTime}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{DisableRootJobs}\PYG{o}{=}\PYG{n}{YES}
\PYG{n}{ExclusiveUser}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{GraceTime}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{Hidden}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{MaxNodes}\PYG{o}{=}\PYG{n}{UNLIMITED}
\PYG{n}{MaxTime}\PYG{o}{=}\PYG{n}{UNLIMITED} \PYG{n}{MinNodes}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{LLN}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{MaxCPUsPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED}
\PYG{n}{Nodes}\PYG{o}{=}\PYG{n}{anode}\PYG{p}{[}\PYG{l+m+mi}{01}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{]} \PYG{n}{PriorityJobFactor}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{PriorityTier}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{RootOnly}\PYG{o}{=}\PYG{n}{NO}
\PYG{n}{ReqResv}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{OverSubscribe}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{OverTimeLimit}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{PreemptMode}\PYG{o}{=}\PYG{n}{OFF} \PYG{n}{State}\PYG{o}{=}\PYG{n}{UP}
\PYG{n}{TotalCPUs}\PYG{o}{=}\PYG{l+m+mi}{320} \PYG{n}{TotalNodes}\PYG{o}{=}\PYG{l+m+mi}{8} \PYG{n}{SelectTypeParameters}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{JobDefaults}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
\PYG{n}{DefMemPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED} \PYG{n}{MaxMemPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED}

\PYG{n}{PartitionName}\PYG{o}{=}\PYG{n}{ARM}\PYG{o}{\PYGZhy{}}\PYG{n}{CPU} \PYG{n}{AllowGroups}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{AllowAccounts}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{AllowQos}\PYG{o}{=}\PYG{n}{ALL}
\PYG{n}{AllocNodes}\PYG{o}{=}\PYG{n}{ALL} \PYG{n}{Default}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{QoS}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A} \PYG{n}{DefaultTime}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{DisableRootJobs}\PYG{o}{=}\PYG{n}{YES}
\PYG{n}{ExclusiveUser}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{GraceTime}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{Hidden}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{MaxNodes}\PYG{o}{=}\PYG{n}{UNLIMITED}
\PYG{n}{MaxTime}\PYG{o}{=}\PYG{n}{UNLIMITED} \PYG{n}{MinNodes}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{LLN}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{MaxCPUsPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED}
\PYG{n}{Nodes}\PYG{o}{=}\PYG{n}{rnode}\PYG{p}{[}\PYG{l+m+mi}{01}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{p}{]} \PYG{n}{PriorityJobFactor}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{PriorityTier}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{RootOnly}\PYG{o}{=}\PYG{n}{NO}
\PYG{n}{ReqResv}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{OverSubscribe}\PYG{o}{=}\PYG{n}{NO} \PYG{n}{OverTimeLimit}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{PreemptMode}\PYG{o}{=}\PYG{n}{OFF} \PYG{n}{State}\PYG{o}{=}\PYG{n}{UP}
\PYG{n}{TotalCPUs}\PYG{o}{=}\PYG{l+m+mi}{864} \PYG{n}{TotalNodes}\PYG{o}{=}\PYG{l+m+mi}{9} \PYG{n}{SelectTypeParameters}\PYG{o}{=}\PYG{n}{NONE} \PYG{n}{JobDefaults}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
\PYG{n}{DefMemPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED} \PYG{n}{MaxMemPerNode}\PYG{o}{=}\PYG{n}{UNLIMITED}
\end{sphinxVerbatim}


\subsection{主要输出项}
\label{\detokenize{slurm/slurm:id13}}\label{\detokenize{slurm/slurm:id14}}\begin{itemize}
\item {} 
\sphinxAtStartPar
PartitionName：队列名。

\item {} 
\sphinxAtStartPar
AllowGroups：允许的用户组。

\item {} 
\sphinxAtStartPar
AllowAccounts：允许的用户。

\item {} 
\sphinxAtStartPar
AllowQos：允许的QoS。

\item {} 
\sphinxAtStartPar
AllocNodes：允许的节点。

\item {} 
\sphinxAtStartPar
Default：是否为默认队列。

\item {} 
\sphinxAtStartPar
QoS：服务质量。

\item {} 
\sphinxAtStartPar
DefaultTime：默认时间。

\item {} 
\sphinxAtStartPar
DisableRootJobs：是否禁止root用户提交作业。

\item {} 
\sphinxAtStartPar
ExclusiveUser：排除的用户。

\item {} 
\sphinxAtStartPar
GraceTime：抢占的款显时间，单位秒。

\item {} 
\sphinxAtStartPar
Hidden：是否为隐藏队列。

\item {} 
\sphinxAtStartPar
MaxNodes：最大节点数。

\item {} 
\sphinxAtStartPar
MaxTime：最大运行时间。

\item {} 
\sphinxAtStartPar
MinNodes：最小节点数。

\item {} 
\sphinxAtStartPar
LLN：是否按照最小负载节点调度。

\item {} 
\sphinxAtStartPar
MaxCPUsPerNode：每个节点的最大CPU颗数。

\item {} 
\sphinxAtStartPar
Nodes：节点名。

\item {} 
\sphinxAtStartPar
PriorityJobFactor：作业因子优先级。

\item {} 
\sphinxAtStartPar
PriorityTier：调度优先级。

\item {} 
\sphinxAtStartPar
RootOnly：是否只允许Root。

\item {} 
\sphinxAtStartPar
ReqResv：要求预留的资源。

\item {} 
\sphinxAtStartPar
OverSubscribe：是否允许超用。

\item {} 
\sphinxAtStartPar
PreemptMode：是否为抢占模式。

\item {} 
\sphinxAtStartPar
State：状态：
\begin{itemize}
\item {} 
\sphinxAtStartPar
UP：可用，作业可以提交到此队列，并将运行。

\item {} 
\sphinxAtStartPar
DOWN：作业可以提交到此队列，但作业也许不会获得分配开始运行。已运行的作业还将继续运行。

\item {} 
\sphinxAtStartPar
DRAIN：不接受新作业，已接受的作业可以被运行。

\item {} 
\sphinxAtStartPar
INACTIVE：不接受新作业，已接受的作业未开始运行的也不运行。

\end{itemize}

\item {} 
\sphinxAtStartPar
TotalCPUs：总CPU核数。

\item {} 
\sphinxAtStartPar
TotalNodes：总节点数。

\item {} 
\sphinxAtStartPar
SelectTypeParameters：资源选择类型参数。

\item {} 
\sphinxAtStartPar
DefMemPerNode：每个节点默认分配的内存大小，单位MB。

\item {} 
\sphinxAtStartPar
MaxMemPerNode：每个节点最大内存大小，单位MB。

\end{itemize}


\section{查看详细节点信息：scontrol show node}
\label{\detokenize{slurm/slurm:scontrol-show-node}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scontrol show node}}显示全部节点信息，\sphinxcode{\sphinxupquote{scontrol show node NODENAME}}或
\sphinxcode{\sphinxupquote{scontrol show node=NODENAME}}显示节点名NODENAME的节点信息，输出类似：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeName}\PYG{o}{=}\PYG{n}{anode01} \PYG{n}{Arch}\PYG{o}{=}\PYG{n}{x86\PYGZus{}64} \PYG{n}{CoresPerSocket}\PYG{o}{=}\PYG{l+m+mi}{20}
  \PYG{n}{CPUAlloc}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{CPUTot}\PYG{o}{=}\PYG{l+m+mi}{40} \PYG{n}{CPULoad}\PYG{o}{=}\PYG{l+m+mf}{0.01}
  \PYG{n}{AvailableFeatures}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
  \PYG{n}{ActiveFeatures}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
  \PYG{n}{Gres}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
  \PYG{n}{NodeAddr}\PYG{o}{=}\PYG{n}{anode01} \PYG{n}{NodeHostName}\PYG{o}{=}\PYG{n}{anode01} \PYG{n}{Version}\PYG{o}{=}\PYG{l+m+mf}{19.05}\PYG{l+m+mf}{.4}
  \PYG{n}{OS}\PYG{o}{=}\PYG{n}{Linux} \PYG{l+m+mf}{3.10}\PYG{l+m+mf}{.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1062.}\PYG{n}{el7}\PYG{o}{.}\PYG{n}{x86\PYGZus{}64} \PYG{c+c1}{\PYGZsh{}1 SMP Wed Aug 7 18:08:02 UTC 2019}
  \PYG{n}{RealMemory}\PYG{o}{=}\PYG{l+m+mi}{2031623} \PYG{n}{AllocMem}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{FreeMem}\PYG{o}{=}\PYG{l+m+mi}{1989520} \PYG{n}{Sockets}\PYG{o}{=}\PYG{l+m+mi}{2} \PYG{n}{Boards}\PYG{o}{=}\PYG{l+m+mi}{1}
  \PYG{n}{State}\PYG{o}{=}\PYG{n}{IDLE} \PYG{n}{ThreadsPerCore}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{TmpDisk}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{Weight}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{Owner}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A} \PYG{n}{MCS\PYGZus{}label}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A}
  \PYG{n}{Partitions}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{n}{TB}\PYG{o}{\PYGZhy{}}\PYG{n}{AEP}\PYG{o}{\PYGZhy{}}\PYG{n}{Mem}
  \PYG{n}{BootTime}\PYG{o}{=}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{n}{T15}\PYG{p}{:}\PYG{l+m+mi}{47}\PYG{p}{:}\PYG{l+m+mi}{56} \PYG{n}{SlurmdStartTime}\PYG{o}{=}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T19}\PYG{p}{:}\PYG{l+m+mi}{01}\PYG{p}{:}\PYG{l+m+mi}{59}
  \PYG{n}{CfgTRES}\PYG{o}{=}\PYG{n}{cpu}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{n}{mem}\PYG{o}{=}\PYG{l+m+mi}{2031623}\PYG{n}{M}\PYG{p}{,}\PYG{n}{billing}\PYG{o}{=}\PYG{l+m+mi}{40}
  \PYG{n}{AllocTRES}\PYG{o}{=}
  \PYG{n}{CapWatts}\PYG{o}{=}\PYG{n}{n}\PYG{o}{/}\PYG{n}{a}
  \PYG{n}{CurrentWatts}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{AveWatts}\PYG{o}{=}\PYG{l+m+mi}{0}
  \PYG{n}{ExtSensorsJoules}\PYG{o}{=}\PYG{n}{n}\PYG{o}{/}\PYG{n}{s} \PYG{n}{ExtSensorsWatts}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{ExtSensorsTemp}\PYG{o}{=}\PYG{n}{n}\PYG{o}{/}\PYG{n}{s}

\PYG{n}{NodeName}\PYG{o}{=}\PYG{n}{gnode01} \PYG{n}{Arch}\PYG{o}{=}\PYG{n}{x86\PYGZus{}64} \PYG{n}{CoresPerSocket}\PYG{o}{=}\PYG{l+m+mi}{20}
  \PYG{n}{CPUAlloc}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{CPUTot}\PYG{o}{=}\PYG{l+m+mi}{40} \PYG{n}{CPULoad}\PYG{o}{=}\PYG{l+m+mf}{0.01}
  \PYG{n}{AvailableFeatures}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
  \PYG{n}{ActiveFeatures}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
  \PYG{n}{Gres}\PYG{o}{=}\PYG{n}{gpu}\PYG{p}{:}\PYG{n}{v100}\PYG{p}{:}\PYG{l+m+mi}{2}
  \PYG{n}{NodeAddr}\PYG{o}{=}\PYG{n}{gnode01} \PYG{n}{NodeHostName}\PYG{o}{=}\PYG{n}{gnode01} \PYG{n}{Version}\PYG{o}{=}\PYG{l+m+mf}{19.05}\PYG{l+m+mf}{.4}
  \PYG{n}{OS}\PYG{o}{=}\PYG{n}{Linux} \PYG{l+m+mf}{3.10}\PYG{l+m+mf}{.0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1062.}\PYG{n}{el7}\PYG{o}{.}\PYG{n}{x86\PYGZus{}64} \PYG{c+c1}{\PYGZsh{}1 SMP Wed Aug 7 18:08:02 UTC 2019}
  \PYG{n}{RealMemory}\PYG{o}{=}\PYG{l+m+mi}{385560} \PYG{n}{AllocMem}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{FreeMem}\PYG{o}{=}\PYG{l+m+mi}{368966} \PYG{n}{Sockets}\PYG{o}{=}\PYG{l+m+mi}{2} \PYG{n}{Boards}\PYG{o}{=}\PYG{l+m+mi}{1}
  \PYG{n}{State}\PYG{o}{=}\PYG{n}{IDLE} \PYG{n}{ThreadsPerCore}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{TmpDisk}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{Weight}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{Owner}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A} \PYG{n}{MCS\PYGZus{}label}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A}
  \PYG{n}{Partitions}\PYG{o}{=}\PYG{n}{GPU}\PYG{o}{\PYGZhy{}}\PYG{n}{V100}
  \PYG{n}{BootTime}\PYG{o}{=}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{13}\PYG{n}{T16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{31} \PYG{n}{SlurmdStartTime}\PYG{o}{=}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T19}\PYG{p}{:}\PYG{l+m+mi}{54}\PYG{p}{:}\PYG{l+m+mi}{55}
  \PYG{n}{CfgTRES}\PYG{o}{=}\PYG{n}{cpu}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{n}{mem}\PYG{o}{=}\PYG{l+m+mi}{385560}\PYG{n}{M}\PYG{p}{,}\PYG{n}{billing}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{n}{gres}\PYG{o}{/}\PYG{n}{gpu}\PYG{o}{=}\PYG{l+m+mi}{2}
  \PYG{n}{AllocTRES}\PYG{o}{=}
  \PYG{n}{CapWatts}\PYG{o}{=}\PYG{n}{n}\PYG{o}{/}\PYG{n}{a}
  \PYG{n}{CurrentWatts}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{AveWatts}\PYG{o}{=}\PYG{l+m+mi}{0}
  \PYG{n}{ExtSensorsJoules}\PYG{o}{=}\PYG{n}{n}\PYG{o}{/}\PYG{n}{s} \PYG{n}{ExtSensorsWatts}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{ExtSensorsTemp}\PYG{o}{=}\PYG{n}{n}\PYG{o}{/}\PYG{n}{s}
\end{sphinxVerbatim}


\subsection{主要输出项}
\label{\detokenize{slurm/slurm:id15}}\label{\detokenize{slurm/slurm:id16}}\begin{itemize}
\item {} 
\sphinxAtStartPar
NodeName：节点名。

\item {} 
\sphinxAtStartPar
Arch：系统架构。

\item {} 
\sphinxAtStartPar
CoresPerSocket：12。

\item {} 
\sphinxAtStartPar
CPUAlloc：分配给的CPU核数。

\item {} 
\sphinxAtStartPar
CPUErr：出错的CPU核数。

\item {} 
\sphinxAtStartPar
CPUTot：总CPU核数。

\item {} 
\sphinxAtStartPar
CPULoad：CPU负载。

\item {} 
\sphinxAtStartPar
AvailableFeatures：可用特性。

\item {} 
\sphinxAtStartPar
ActiveFeatures：激活的特性。

\item {} 
\sphinxAtStartPar
Gres：通用资源。如上面Gres=gpu:v100:2指明了有两块V100 GPU。

\item {} 
\sphinxAtStartPar
NodeAddr：节点IP地址。

\item {} 
\sphinxAtStartPar
NodeHostName：节点名。

\item {} 
\sphinxAtStartPar
Version：Slurm版本。

\item {} 
\sphinxAtStartPar
OS：操作系统 。

\item {} 
\sphinxAtStartPar
RealMemory：实际物理内存，单位GB。

\item {} 
\sphinxAtStartPar
AllocMem：已分配内存，单位GB。

\item {} 
\sphinxAtStartPar
FreeMem：可用内存，单位GB。

\item {} 
\sphinxAtStartPar
Sockets：CPU颗数。

\item {} 
\sphinxAtStartPar
Boards：主板数。

\item {} 
\sphinxAtStartPar
State：状态。

\item {} 
\sphinxAtStartPar
ThreadsPerCore：每颗CPU核线程数。

\item {} 
\sphinxAtStartPar
TmpDisk：临时存盘硬盘大小。

\item {} 
\sphinxAtStartPar
Weight：权重。

\item {} 
\sphinxAtStartPar
BootTime：开机时间。

\item {} 
\sphinxAtStartPar
SlurmdStartTime：Slurmd守护进程启动时间。

\end{itemize}


\section{查看详细作业信息：scontrol show job}
\label{\detokenize{slurm/slurm:scontrol-show-job}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scontrol show job}}显示全部作业信息，\sphinxcode{\sphinxupquote{scontrol show job JOBID}}或\sphinxcode{\sphinxupquote{scontrol show job=JOBID}}显示作业号为JOBID的作业信息，输出类似下面：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{JobId}\PYG{o}{=}\PYG{l+m+mi}{77} \PYG{n}{JobName}\PYG{o}{=}\PYG{n}{gres\PYGZus{}test}\PYG{o}{.}\PYG{n}{bash}
   \PYG{n}{UserId}\PYG{o}{=}\PYG{n}{hmli}\PYG{p}{(}\PYG{l+m+mi}{10001}\PYG{p}{)} \PYG{n}{GroupId}\PYG{o}{=}\PYG{n}{nic}\PYG{p}{(}\PYG{l+m+mi}{10001}\PYG{p}{)} \PYG{n}{MCS\PYGZus{}label}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A}
   \PYG{n}{Priority}\PYG{o}{=}\PYG{l+m+mi}{4294901755} \PYG{n}{Nice}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{Account}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)} \PYG{n}{QOS}\PYG{o}{=}\PYG{n}{normal}
   \PYG{n}{JobState}\PYG{o}{=}\PYG{n}{RUNNING} \PYG{n}{Reason}\PYG{o}{=}\PYG{k+kc}{None} \PYG{n}{Dependency}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
   \PYG{n}{Requeue}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{Restarts}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{BatchFlag}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{Reboot}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{ExitCode}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{0}
   \PYG{n}{RunTime}\PYG{o}{=}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{11} \PYG{n}{TimeLimit}\PYG{o}{=}\PYG{n}{UNLIMITED} \PYG{n}{TimeMin}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A}
   \PYG{n}{SubmitTime}\PYG{o}{=}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T20}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{15} \PYG{n}{EligibleTime}\PYG{o}{=}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T20}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{15}
   \PYG{n}{AccrueTime}\PYG{o}{=}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T20}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{15}
   \PYG{n}{StartTime}\PYG{o}{=}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T20}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{16} \PYG{n}{EndTime}\PYG{o}{=}\PYG{n}{Unknown} \PYG{n}{Deadline}\PYG{o}{=}\PYG{n}{N}\PYG{o}{/}\PYG{n}{A}
   \PYG{n}{SuspendTime}\PYG{o}{=}\PYG{k+kc}{None} \PYG{n}{SecsPreSuspend}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{LastSchedEval}\PYG{o}{=}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T20}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{16}
   \PYG{n}{Partition}\PYG{o}{=}\PYG{n}{GPU}\PYG{o}{\PYGZhy{}}\PYG{n}{V100} \PYG{n}{AllocNode}\PYG{p}{:}\PYG{n}{Sid}\PYG{o}{=}\PYG{n}{login01}\PYG{p}{:}\PYG{l+m+mi}{1016}
   \PYG{n}{ReqNodeList}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)} \PYG{n}{ExcNodeList}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
   \PYG{n}{NodeList}\PYG{o}{=}\PYG{n}{gnode01}
   \PYG{n}{BatchHost}\PYG{o}{=}\PYG{n}{gnode01}
   \PYG{n}{NumNodes}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{NumCPUs}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{NumTasks}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{CPUs}\PYG{o}{/}\PYG{n}{Task}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{ReqB}\PYG{p}{:}\PYG{n}{S}\PYG{p}{:}\PYG{n}{C}\PYG{p}{:}\PYG{n}{T}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{o}{*}\PYG{p}{:}\PYG{o}{*}
   \PYG{n}{TRES}\PYG{o}{=}\PYG{n}{cpu}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{node}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{billing}\PYG{o}{=}\PYG{l+m+mi}{1}
   \PYG{n}{Socks}\PYG{o}{/}\PYG{n}{Node}\PYG{o}{=}\PYG{o}{*} \PYG{n}{NtasksPerN}\PYG{p}{:}\PYG{n}{B}\PYG{p}{:}\PYG{n}{S}\PYG{p}{:}\PYG{n}{C}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{o}{*}\PYG{p}{:}\PYG{o}{*} \PYG{n}{CoreSpec}\PYG{o}{=}\PYG{o}{*}
   \PYG{n}{MinCPUsNode}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{MinMemoryNode}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{MinTmpDiskNode}\PYG{o}{=}\PYG{l+m+mi}{0}
   \PYG{n}{Features}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)} \PYG{n}{DelayBoot}\PYG{o}{=}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{00}
   \PYG{n}{OverSubscribe}\PYG{o}{=}\PYG{n}{OK} \PYG{n}{Contiguous}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{n}{Licenses}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)} \PYG{n}{Network}\PYG{o}{=}\PYG{p}{(}\PYG{n}{null}\PYG{p}{)}
   \PYG{n}{Command}\PYG{o}{=}\PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{nic}\PYG{o}{/}\PYG{n}{hmli}\PYG{o}{/}\PYG{n}{gres\PYGZus{}test}\PYG{o}{.}\PYG{n}{bash}
   \PYG{n}{WorkDir}\PYG{o}{=}\PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{nic}\PYG{o}{/}\PYG{n}{hmli}
   \PYG{n}{StdErr}\PYG{o}{=}\PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{nic}\PYG{o}{/}\PYG{n}{hmli}\PYG{o}{/}\PYG{n}{job}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{77.}\PYG{n}{err}
   \PYG{n}{StdIn}\PYG{o}{=}\PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{null}
   \PYG{n}{StdOut}\PYG{o}{=}\PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{nic}\PYG{o}{/}\PYG{n}{hmli}\PYG{o}{/}\PYG{n}{job}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{77.}\PYG{n}{log}
   \PYG{n}{Power}\PYG{o}{=}
\end{sphinxVerbatim}


\subsection{主要输出项}
\label{\detokenize{slurm/slurm:id17}}\label{\detokenize{slurm/slurm:id18}}\begin{itemize}
\item {} 
\sphinxAtStartPar
JobId：作业号。

\item {} 
\sphinxAtStartPar
JobName：作业名。

\item {} 
\sphinxAtStartPar
UserId：用户名（用户ID）。

\item {} 
\sphinxAtStartPar
GroupId：用户组（组ID）。

\item {} 
\sphinxAtStartPar
MCS\_label：MCS标记。

\item {} 
\sphinxAtStartPar
Priority：优先级，越大越优先，如果为0则表示被管理员挂起，不允许运行。

\item {} 
\sphinxAtStartPar
Nice：Nice值，越小越优先，\sphinxhyphen{}20到19。

\item {} 
\sphinxAtStartPar
Account：记账用户名。

\item {} 
\sphinxAtStartPar
QOS：作业的服务质量。

\item {} 
\sphinxAtStartPar
JobState：作业状态。
\begin{itemize}
\item {} 
\sphinxAtStartPar
PENDING：排队中。

\item {} 
\sphinxAtStartPar
RUNNING：运行中。

\item {} 
\sphinxAtStartPar
CANCELLED：已取消。

\item {} 
\sphinxAtStartPar
CONFIGURING：配置中。

\item {} 
\sphinxAtStartPar
COMPLETING：完成中。

\item {} 
\sphinxAtStartPar
COMPLETED：已完成。

\item {} 
\sphinxAtStartPar
FAILED：已失败。

\item {} 
\sphinxAtStartPar
TIMEOUT：超时。

\item {} 
\sphinxAtStartPar
NODE FAILURE：节点失效。

\item {} 
\sphinxAtStartPar
SPECIAL EXIT STATE：特殊退出状态。

\end{itemize}

\item {} 
\sphinxAtStartPar
Reason：原因。

\item {} 
\sphinxAtStartPar
Dependency：依赖关系。

\item {} 
\sphinxAtStartPar
Requeue：节点失效时，是否重排队，0为否，1为是。

\item {} 
\sphinxAtStartPar
Restarts：失败时，是否重运行，0为否，1为是。

\item {} 
\sphinxAtStartPar
BatchFlag：是否为批处理作业，0为否，1为是。

\item {} 
\sphinxAtStartPar
Reboot：节点空闲时是否重启节点，0为否，1为是。

\item {} 
\sphinxAtStartPar
ExitCode：作业退出代码。

\item {} 
\sphinxAtStartPar
RunTime：已运行时间。

\item {} 
\sphinxAtStartPar
TimeLimit：作业允许的剩余运行时间。

\item {} 
\sphinxAtStartPar
TimeMin：最小时间。

\item {} 
\sphinxAtStartPar
SubmitTime：提交时间。

\item {} 
\sphinxAtStartPar
EligibleTime：获得认可时间。

\item {} 
\sphinxAtStartPar
StartTime：开始运行时间。

\item {} 
\sphinxAtStartPar
EndTime：预计结束时间。

\item {} 
\sphinxAtStartPar
Deadline：截止时间。

\item {} 
\sphinxAtStartPar
PreemptTime：先占时间。

\item {} 
\sphinxAtStartPar
SuspendTime：挂起时间。

\item {} 
\sphinxAtStartPar
SecsPreSuspend：0。

\item {} 
\sphinxAtStartPar
Partition：对列名。

\item {} 
\sphinxAtStartPar
AllocNode：Sid：分配的节点：系统ID号。

\item {} 
\sphinxAtStartPar
ReqNodeList：需要的节点列表，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
ExcNodeList：排除的节点列表，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
NodeList：实际运行节点列表，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
BatchHost：批处理节点名。

\item {} 
\sphinxAtStartPar
NumNodes：节点数。

\item {} 
\sphinxAtStartPar
NumCPUs：CPU核数。

\item {} 
\sphinxAtStartPar
NumTasks：任务数。

\item {} 
\sphinxAtStartPar
CPUs/Task：CPU核数/任务数。

\item {} 
\sphinxAtStartPar
ReqB:S:C:T：所需的主板数:每主板CPU颗数:每颗CPU核数:每颗CPU核的线程数，<baseboard\_count>:<socket\_per\_baseboard\_count>:<core\_per\_socket\_count>:<thread\_per\_core\_count>。

\item {} 
\sphinxAtStartPar
TRES：显示分配给作业的可被追踪的资源。

\item {} 
\sphinxAtStartPar
Socks/Node：每节点CPU颗数。

\item {} 
\sphinxAtStartPar
NtasksPerN:B:S:C：每主板数:每主板CPU颗数:每颗CPU的核数:每颗CPU核的线程数启动的作业数，<tasks\_per\_node>:<tasks\_per\_baseboard>:<tasks\_per\_socket>:<tasks\_per\_core>。

\item {} 
\sphinxAtStartPar
CoreSpec：各节点系统预留的CPU核数，如未包含，则显示*。

\item {} 
\sphinxAtStartPar
MinCPUsNode：每节点最小CPU核数。

\item {} 
\sphinxAtStartPar
MinMemoryNode：每节点最小内存大小，0表示未限制。

\item {} 
\sphinxAtStartPar
MinTmpDiskNode：每节点最小临时存盘硬盘大小，0表示未限制。

\item {} 
\sphinxAtStartPar
Features：特性。

\item {} 
\sphinxAtStartPar
Gres：通用资源。

\item {} 
\sphinxAtStartPar
Reservation：预留资源。

\item {} 
\sphinxAtStartPar
OverSubscribe：是否允许与其它作业共享资源，OK允许，NO不允许。

\item {} 
\sphinxAtStartPar
Contiguous：是否要求分配连续节点，OK是，NO否。

\item {} 
\sphinxAtStartPar
Licenses：软件授权。

\item {} 
\sphinxAtStartPar
Network：网络。

\item {} 
\sphinxAtStartPar
Command：作业命令。

\item {} 
\sphinxAtStartPar
WorkDir：工作目录。

\item {} 
\sphinxAtStartPar
StdErr：标准出错输出文件。

\item {} 
\sphinxAtStartPar
StdIn：标准输入文件。

\item {} 
\sphinxAtStartPar
StdOut：标准输出文件。

\end{itemize}


\section{查看服务质量(QoS)}
\label{\detokenize{slurm/slurm:qos}}
\sphinxAtStartPar
服务质量(Quality Of Service\sphinxhyphen{}QoS)，或者理解为资源限制或者优先级，只有达到QoS要求时作业才能运行，QoS将在以下三个方面影响作业运行：
\begin{itemize}
\item {} 
\sphinxAtStartPar
作业调度优先级

\item {} 
\sphinxAtStartPar
作业抢占

\item {} 
\sphinxAtStartPar
作业限制

\end{itemize}

\sphinxAtStartPar
可以用\sphinxcode{\sphinxupquote{sacctmgr show | list qos}}查看。


\section{查看作业屏幕输出：speek}
\label{\detokenize{slurm/slurm:speek}}
\sphinxAtStartPar
查看作业屏幕输出的命令\sphinxcode{\sphinxupquote{speek}}（类似LSF的\sphinxcode{\sphinxupquote{bpeek}}），基本用法\sphinxcode{\sphinxupquote{speek {[}\sphinxhyphen{}e{]} {[}\sphinxhyphen{}f{]} 作业号}}。默认显示正常屏幕输出，如加\sphinxhyphen{}f参数，则连续监测输出；如加\sphinxhyphen{}e参数，则监测错误日志。

\sphinxAtStartPar
注：该\sphinxcode{\sphinxupquote{speek}}命令是本人写的，不是slurm官方命令，在其它系统上不一定有。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
\PYG{c+c1}{\PYGZsh{}Author: HM Li \PYGZlt{}hmli@ustc.edu.cn\PYGZgt{}}
\PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}\PYGZsh{}} \PYGZhy{}lt \PYG{l+m}{1} \PYG{o}{]} \PYG{p}{;} \PYG{k}{then}
    \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}Usage: speek [\PYGZhy{}e] [\PYGZhy{}f] jobid\PYGZdq{}}
    \PYG{n+nb}{echo} \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{} \PYGZhy{}e: show error log.\PYGZbs{}n \PYGZhy{}f: output appended data as the file grows.\PYGZbs{}n\PYGZbs{}nYour jobs are:\PYGZdq{}}
    \PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}USER} !\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}root\PYGZsq{}} \PYG{o}{]}\PYG{p}{;} \PYG{k}{then}
        squeue \PYGZhy{}u \PYG{n+nv}{\PYGZdl{}USER} \PYGZhy{}t r \PYGZhy{}o \PYG{l+s+s2}{\PYGZdq{}\PYGZpc{}.8i \PYGZpc{}10P \PYGZpc{}12j \PYGZpc{}19S \PYGZpc{}.12M \PYGZpc{}.7C \PYGZpc{}.5D \PYGZpc{}R\PYGZdq{}}
    \PYG{k}{else}
        squeue \PYGZhy{}t r \PYGZhy{}o \PYG{l+s+s2}{\PYGZdq{}\PYGZpc{}.8i \PYGZpc{}10u \PYGZpc{}10P \PYGZpc{}12j \PYGZpc{}19S \PYGZpc{}.12M  \PYGZpc{}.7C \PYGZpc{}.5D \PYGZpc{}R\PYGZdq{}}
    \PYG{k}{fi}
    \PYG{n+nb}{exit}
\PYG{k}{fi}
\PYG{n+nv}{NO}\PYG{o}{=}\PYG{l+m}{1}
\PYG{n+nv}{STD}\PYG{o}{=}StdOut
\PYG{k}{while} \PYG{n+nb}{getopts} \PYG{l+s+s1}{\PYGZsq{}ef\PYGZsq{}} OPT\PYG{p}{;} \PYG{k}{do}
    \PYG{k}{case} \PYG{n+nv}{\PYGZdl{}OPT} \PYG{k}{in}
        e\PYG{o}{)}
           \PYG{n+nv}{STD}\PYG{o}{=}StdErr
           \PYG{p}{;}\PYG{p}{;}
        f\PYG{o}{)}
           \PYG{n+nv}{T}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}f\PYGZsq{}}
           \PYG{p}{;}\PYG{p}{;}
    \PYG{k}{esac}
\PYG{k}{done}
\PYG{n+nv}{JOBID}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{p}{!\PYGZsh{}}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{F}\PYG{o}{=}\PYG{l+s+sb}{`}scontrol show job \PYG{n+nv}{\PYGZdl{}JOBID} \PYG{l+m}{2}\PYGZgt{}/dev/null \PYG{p}{|} awk \PYGZhy{}v \PYG{n+nv}{STD}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}STD} \PYGZhy{}F\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}if(\PYGZdl{}1\PYGZti{}\PYGZsq{}}STD\PYG{l+s+s1}{\PYGZsq{}) print \PYGZdl{}2\PYGZcb{}\PYGZsq{}}\PYG{l+s+sb}{`}
\PYG{k}{if} \PYG{o}{[} \PYGZhy{}f \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}F}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{]}\PYG{p}{;} \PYG{k}{then}
    tail \PYG{n+nv}{\PYGZdl{}T} \PYG{n+nv}{\PYGZdl{}F}
\PYG{k}{else}
    \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Job }\PYG{n+nv}{\PYGZdl{}JOBID}\PYG{l+s+s2}{ has no }\PYG{n+nv}{\PYGZdl{}STD}\PYG{l+s+s2}{ file or you have no authority to access.}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{fi}
\end{sphinxVerbatim}


\section{提交作业命令共同说明}
\label{\detokenize{slurm/slurm:id19}}
\sphinxAtStartPar
提交作业的命令主要有\sphinxcode{\sphinxupquote{salloc}}、\sphinxcode{\sphinxupquote{sbatch}}与\sphinxcode{\sphinxupquote{srun}}，其多数参数、输入输出变量等都是一样的。


\subsection{主要参数}
\label{\detokenize{slurm/slurm:slurmoption}}\label{\detokenize{slurm/slurm:id20}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}A, \sphinxhyphen{}\sphinxhyphen{}account=<account>：指定此作业的责任资源为账户<account>，即账单（与计算费对应）记哪个名下，只有账户属于多个账单组才有权指定。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}accel\sphinxhyphen{}bind=<options>：\sphinxcode{\sphinxupquote{srun特有}}，控制如何绑定作业到GPU、网络等特定资源，支持同时多个选项，支持的选项如下：
\begin{itemize}
\item {} 
\sphinxAtStartPar
g：绑定到离分配的CPU最近的GPU

\item {} 
\sphinxAtStartPar
m：绑定到离分配的CPU最近的MIC

\item {} 
\sphinxAtStartPar
n：绑定到离分配的CPU最近的网卡

\item {} 
\sphinxAtStartPar
v：详细模式，显示如何绑定GPU和网卡等等信息

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}acctg\sphinxhyphen{}freq：指定作业记账和剖面信息采样间隔。支持的格式为\sphinxhyphen{}\sphinxhyphen{}acctg\sphinxhyphen{}freq=<datatype>=<interval>，其中<datatype>=<interval>指定了任务抽样间隔或剖面抽样间隔。多个<datatype>=<interval>可以采用,分隔（默认为30秒）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
task=<interval>：以秒为单位的任务抽样（需要jobacct\_gather插件启用）和任务剖面（需要acct\_gather\_profile插件启用）间隔。

\item {} 
\sphinxAtStartPar
energy=<interval>：以秒为单位的能源剖面抽样间隔，需要acct\_gather\_energy插件启用。

\item {} 
\sphinxAtStartPar
network=<interval>：以秒为单位的InfiniBand网络剖面抽样间隔，需要acct\_gather\_infiniband插件启用。

\item {} 
\sphinxAtStartPar
filesystem=<interval>：以秒为单位的文件系统剖面抽样间隔，需要acct\_gather\_filesystem插件启用。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}B \sphinxhyphen{}\sphinxhyphen{}extra\sphinxhyphen{}node\sphinxhyphen{}info=<sockets{[}:cores{[}:threads{]}{]}>：选择满足<sockets{[}:cores{[}:threads{]}{]}>的节点，*表示对应选项不做限制。对应限制可以采用下面对应选项：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}sockets\sphinxhyphen{}per\sphinxhyphen{}node=<sockets>

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}cores\sphinxhyphen{}per\sphinxhyphen{}socket=<cores>

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}threads\sphinxhyphen{}per\sphinxhyphen{}core=<threads>

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}bcast{[}=<dest\_path>{]}：\sphinxcode{\sphinxupquote{srun特有}}，复制可执行程序到分配的计算节点的{[}<dest\_path>{]}目录。如指定了<dest\_path>，则复制可执行程序到此；如没指定则复制到当前工作目录下的“slurm\_bcast\_<job\_id>.<step\_id>”。如\sphinxcode{\sphinxupquote{srun \sphinxhyphen{}\sphinxhyphen{}bcast=/tmp/mine \sphinxhyphen{}N3 a.out}}将从当前目录复制a.out到每个分配的节点的/tmp/min并执行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}begin=<time>：设定开始分配资源运行的时间。时间格式可为HH:MM:SS，或添加AM、PM等，也可采用MMDDYY、MM/DD/YY或YYYY\sphinxhyphen{}MM\sphinxhyphen{}DD格式指定日期，含有日期及时间的格式为：YYYY\sphinxhyphen{}MM\sphinxhyphen{}DD{[}THH:MM{[}:SS{]}{]}，也可以采用类似now+时间单位的方式，时间单位可以为seconds（默认）、minutes、hours、days和weeks、today、tomorrow等，例如：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}begin=16:00：16:00开始。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}begin=now+1hour：1小时后开始。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}begin=now+60：60秒后开始（默认单位为秒）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}begin=2017\sphinxhyphen{}02\sphinxhyphen{}20T12:34:00：2017\sphinxhyphen{}02\sphinxhyphen{}20T12:34:00开始。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}bell：分配资源时终端响铃，参见\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}bell。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}cpu\sphinxhyphen{}bind={[}quiet,verbose,{]}type：\sphinxcode{\sphinxupquote{srun特有}}，设定CPU绑定模式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}comment=<string>：作业说明。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}contiguous：需分配到连续节点，一般来说连续节点之间网络会快一点，如在同一个IB交换机内，但有可能导致开始运行时间推迟（需等待足够多的连续节点）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}cores\sphinxhyphen{}per\sphinxhyphen{}socket=<cores>：分配的节点需要每颗CPU至少<cores>CPU核。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}gpu=<ncpus>：每颗GPU需<ncpus>个CPU核，与\sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}task不兼容。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}c, \sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}task=<ncpus>：每个进程需<ncpus>颗CPU核，一般运行OpenMP等多线程程序时需，普通MPI程序不需。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}deadline=<OPT>：如果在此deadline（start > (deadline \sphinxhyphen{} time{[}\sphinxhyphen{}min{]}）之前没有结束，那么移除此作业。默认没有deadline，有效的时间格式为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
HH:MM{[}:SS{]} {[}AM|PM{]}

\item {} 
\sphinxAtStartPar
MMDD{[}YY{]}或MM/DD{[}/YY{]}或MM.DD{[}.YY{]}

\item {} 
\sphinxAtStartPar
MM/DD{[}/YY{]}\sphinxhyphen{}HH:MM{[}:SS{]}

\item {} 
\sphinxAtStartPar
YYYY\sphinxhyphen{}MM\sphinxhyphen{}DD{[}THH:MM{[}:SS{]}{]}{]}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}d, \sphinxhyphen{}\sphinxhyphen{}dependency=<dependency\_list>：满足依赖条件<dependency\_list>后开始分配。<dependency\_list>可以为<type:job\_id{[}:job\_id{]}{[},type:job\_id{[}:job\_id{]}{]}>或<type:job\_id{[}:job\_id{]}{[}?type:job\_id{[}:job\_id{]}{]}>。依赖条件如果用,分隔，则各依赖条件都需要满足；如果采用?分隔，那么只要任意条件满足即可。可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
after:job\_id{[}:jobid…{]}：当指定作业号的作业结束后开始运行。

\item {} 
\sphinxAtStartPar
afterany:job\_id{[}:jobid…{]}：当指定作业号的任意作业结束后开始运行。

\item {} 
\sphinxAtStartPar
aftercorr:job\_id{[}:jobid…{]}：当相应任务号任务结束后，此作业组中的开始运行。

\item {} 
\sphinxAtStartPar
afternotok:job\_id{[}:jobid…{]}：当指定作业号的作业结束时具有异常状态（非零退出码、节点失效、超时等）时。

\item {} 
\sphinxAtStartPar
afterok:job\_id{[}:jobid…{]}：当指定的作业正常结束（退出码为0）时开始运行。

\item {} 
\sphinxAtStartPar
expand:job\_id：分配给此作业的资源将扩展给指定作业。

\item {} 
\sphinxAtStartPar
singleton：等任意通账户的相同作业名的前置作业结束时。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}D, \sphinxhyphen{}\sphinxhyphen{}chdir=<path>：在切换到<path>工作目录后执行命令。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}e, \sphinxhyphen{}\sphinxhyphen{}error=<mode>：设定标准错误如何重定向。非交互模式下，默认srun重定向标准错误到与标准输出同样的文件（如指定）。此参数可以指定重定向到不同文件。如果指定的文件已经存在，那么将被覆盖。参见IO重定向。\sphinxcode{\sphinxupquote{salloc}}无此选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}epilog=<executable>：\sphinxcode{\sphinxupquote{srun特有}}，作业结束后执行<executable>程序做相应处理。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}E, \sphinxhyphen{}\sphinxhyphen{}preserve\sphinxhyphen{}env：将环境变量\sphinxcode{\sphinxupquote{SLURM\_NNODES}}和\sphinxcode{\sphinxupquote{SLURM\_NTASKS}}传递给可执行文件，而无需通过计算命令行参数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}exclusive{[}=user|mcs{]}：排他性运行，独占性运行，此节点不允许其他{[}user{]}用户或mcs选项的作业共享运行作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}export=<{[}ALL,{]}environment variables|ALL|NONE>：\sphinxcode{\sphinxupquote{sbatch与srun特有}}，将环境变量传递给应用程序
\begin{itemize}
\item {} 
\sphinxAtStartPar
ALL：复制所有提交节点的环境变量，为默认选项。

\item {} 
\sphinxAtStartPar
NONE：所有环境变量都不被传递，可执行程序必须采用绝对路径。一般用于当提交时使用的集群与运行集群不同时。

\item {} 
\sphinxAtStartPar
{[}ALL,{]}environment variables：复制全部环境变量及特定的环境变量及其值，可以有多个以,分隔的变量。如：“\sphinxhyphen{}\sphinxhyphen{}export=EDITOR,ARG1=test”。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}export\sphinxhyphen{}file=<filename | fd>：\sphinxcode{\sphinxupquote{sbatch特有}}，将特定文件中的变量设置传递到计算节点，这允许在定义环境变量时有特殊字符。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}F, \sphinxhyphen{}\sphinxhyphen{}nodefile=<node file>：类似\sphinxhyphen{}\sphinxhyphen{}nodelist指定需要运行的节点，但在一个文件中含有节点列表。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}G, \sphinxhyphen{}\sphinxhyphen{}gpus={[}<type>:{]}<number>：设定使用的GPU类型及数目，如\sphinxhyphen{}\sphinxhyphen{}gpus=v100:2。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}node={[}<type>:{]}<number>：设定单个节点使用的GPU类型及数目。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}socket={[}<type>:{]}<number>：设定每个socket需要的GPU类型及数目。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}task={[}<type>:{]}<number>：设定每个任务需要的GPU类型及数目。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}gres=<list>：设定通用消费资源，可以以,分隔。每个<list>格式为“name{[}{[}:type{]}:count{]}”。name是可消费资源；count是资源个数，默认为1；

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}H, \sphinxhyphen{}\sphinxhyphen{}hold：设定作业将被提交为挂起状态。挂起的作业可以利用scontrol release <job\_id>使其排队运行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}h, \sphinxhyphen{}\sphinxhyphen{}help：显示帮助信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}hint=<type>：绑定任务到应用提示：
\begin{itemize}
\item {} 
\sphinxAtStartPar
compute\_bound：选择设定计算边界应用：采用每个socket的所有CPU核，每颗CPU核一个进程。

\item {} 
\sphinxAtStartPar
memory\_bound：选择设定内存边界应用：仅采用每个socket的1颗CPU核，每颗CPU核一个进程。

\item {} 
\sphinxAtStartPar
multithread：在in\sphinxhyphen{}core multi\sphinxhyphen{}threading是否采用额外的线程，对通信密集型应用有益。仅当task/affinity插件启用时。

\item {} 
\sphinxAtStartPar
help：显示帮助信息

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}I, \sphinxhyphen{}\sphinxhyphen{}immediate{[}=<seconds>{]}：\sphinxcode{\sphinxupquote{salloc与srun特有}}，在<seconds>秒内资源未满足的话立即退出。格式可以为“\sphinxhyphen{}I60”，但不能之间有空格是“\sphinxhyphen{}I 60”。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}ignore\sphinxhyphen{}pbs：\sphinxcode{\sphinxupquote{sbatch特有}}，忽略批处理脚本中的“\#PBS”选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}i, \sphinxhyphen{}\sphinxhyphen{}input=<mode>：\sphinxcode{\sphinxupquote{sbatch与srun特有}}，指定标准输入如何重定向。默认，srun对所有任务重定向标准输入为从终端。参见IO重定向。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}J, \sphinxhyphen{}\sphinxhyphen{}job\sphinxhyphen{}name=<jobname>：设定作业名<jobname>，默认为命令名。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}jobid=<jobid>：\sphinxcode{\sphinxupquote{srun特有}}，初始作业步到某个已分配的作业号<jobid>下的作业下，类似设置了\sphinxcode{\sphinxupquote{SLURM\_JOB\_ID}}环境变量。仅对作业步申请有效。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}K, \sphinxhyphen{}\sphinxhyphen{}kill\sphinxhyphen{}command{[}=signal{]}：\sphinxcode{\sphinxupquote{salloc特有}}，设定需要终止时的signal，默认，如没指定，则对于交互式作业为SIGHUP，对于非交互式作业为SIGTERM。格式类似可以为“\sphinxhyphen{}K1”，但不能包含空格为“\sphinxhyphen{}K 1”。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}K,–kill\sphinxhyphen{}on\sphinxhyphen{}bad\sphinxhyphen{}exit{[}=0|1{]}：\sphinxcode{\sphinxupquote{srun特有}}，设定是否任何一个任务退出码为非0时，是否终止作业步。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}k, \sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}kill：如果分配的节点失效，那么不会自动终止。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}L, \sphinxhyphen{}\sphinxhyphen{}licenses=<license>：设定使用的<license>。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}l, \sphinxhyphen{}\sphinxhyphen{}label：\sphinxcode{\sphinxupquote{srun特有}}，在标注正常输出或标准错误输出的行前面添加作业号。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}mem=<size{[}units{]}>：设定每个节点的内存大小，后缀可以为{[}K|M|G|T{]}，默认为MB。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}cpu=<size{[}units{]}>：设定分配的每颗CPU对应最小内存，后缀可以为{[}K|M|G|T{]}，默认为MB。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}gpu=<size{[}units{]}>：设定分配的每颗GPU对应最小内存，后缀可以为{[}K|M|G|T{]}，默认为MB。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}mincpus=<n>：设定每个节点最小的逻辑CPU核/处理器。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}mpi=<mpi\_type>：\sphinxcode{\sphinxupquote{srun特有}}，指定使用的MPI环境，<mpi\_type>可以主要为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
list：列出可用的MPI以便选择。

\item {} 
\sphinxAtStartPar
pmi2：启用PMI2支持

\item {} 
\sphinxAtStartPar
pmix：启用PMIx支持

\item {} 
\sphinxAtStartPar
none：默认选项，多种其它MPI实现有效。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}multi\sphinxhyphen{}prog：\sphinxcode{\sphinxupquote{srun特有}}，让不同任务运行不同的程序及参数，需指定一个配置文件，参见MULTIPLE PROGRAM CONFIGURATION。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}N, \sphinxhyphen{}\sphinxhyphen{}nodes=<minnodes{[}\sphinxhyphen{}maxnodes{]}>：采用特定节点数运行作业，如没指定maxnodes则需特定节点数，注意，这里是节点数，不是CPU核数，实际分配的是节点数×每节点CPU核数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}nice{[}=adjustment{]}：设定NICE调整值。负值提高优先级，正值降低优先级。调整范围为：+/\sphinxhyphen{}2147483645。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}n, \sphinxhyphen{}\sphinxhyphen{}ntasks=<number>：设定所需要的任务总数。默认是每个节点1个任务，注意是节点，不是CPU核。仅对作业起作用，不对作业步起作用。\sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}task选项可以改变此默认选项。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}ntasks\sphinxhyphen{}per\sphinxhyphen{}core=<ntasks>：每颗CPU核运行<ntasks>个任务，需与\sphinxhyphen{}n, \sphinxhyphen{}\sphinxhyphen{}ntasks=<number>配合，并自动绑定<ntasks>个任务到每个CPU核。仅对作业起作用，不对作业步起作用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}ntasks\sphinxhyphen{}per\sphinxhyphen{}node=<ntasks>：每个节点运行<ntasks>个任务，需与\sphinxhyphen{}n, \sphinxhyphen{}\sphinxhyphen{}ntasks=<number>配合。仅对作业起作用，不对作业步起作用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}ntasks\sphinxhyphen{}per\sphinxhyphen{}socket=<ntasks>：每颗CPU运行<ntasks>个任务，需与\sphinxhyphen{}n, \sphinxhyphen{}\sphinxhyphen{}ntasks=<number>配合，并绑定<ntasks>个任务到每颗CPU。仅对作业起作用，不对作业步起作用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}bell：\sphinxcode{\sphinxupquote{salloc特有}}，资源分配时不终端响铃。参见\sphinxhyphen{}\sphinxhyphen{}bell。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}shell：\sphinxcode{\sphinxupquote{salloc特有}}，分配资源后立即退出，而不运行命令。但Slurm作业仍旧被生成，在其激活期间，且保留这些激活的资源。用户会获得一个没有附带进程和任务的作业号，用户可以采用提交srun命令到这些资源。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}o, \sphinxhyphen{}\sphinxhyphen{}output=<mode>：\sphinxcode{\sphinxupquote{sbatch与srun特有}}，指定标准输出重定向。在非交互模式中，默认srun收集各任务的标准输出，并发送到吸附的终端上。采用\sphinxhyphen{}\sphinxhyphen{}output可以将其重定向到同一个文件、每个任务一个文件或/dev/null等。参见IO重定向。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}open\sphinxhyphen{}mode=<append|truncate>：\sphinxcode{\sphinxupquote{sbtach与srun特有}}，对标准输出和标准错误输出采用追加模式还是覆盖模式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}O, \sphinxhyphen{}\sphinxhyphen{}overcommit：采用此选项可以使得每颗CPU运行不止一个任务。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}open\sphinxhyphen{}mode=<append|truncate>：标准输出和标准错误输出打开文件的方式：
\begin{itemize}
\item {} 
\sphinxAtStartPar
append：追加。

\item {} 
\sphinxAtStartPar
truncate：截断覆盖。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}p, \sphinxhyphen{}\sphinxhyphen{}partition=<partition\_names>：使用<partition\_names>队列

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}prolog=<executable>：\sphinxcode{\sphinxupquote{srun特有}}，作业开始运行前执行<executable>程序，做相应处理。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Q, \sphinxhyphen{}\sphinxhyphen{}quiet：采用安静模式运行，一般信息将不显示，但错误信息仍将被显示。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}qos=<qos>：需要特定的服务质量(QS)。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}quit\sphinxhyphen{}on\sphinxhyphen{}interrupt：\sphinxcode{\sphinxupquote{srun特有}}，当SIGINT (Ctrl\sphinxhyphen{}C)时立即退出。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}r, \sphinxhyphen{}\sphinxhyphen{}relative=<n>：\sphinxcode{\sphinxupquote{srun特有}}，在当前分配的第n节点上运行作业步。该选项可用于分配一些作业步到当前作业占用的节点外的节点，节点号从0开始。\sphinxhyphen{}r选项不能与\sphinxhyphen{}w或\sphinxhyphen{}x同时使用。仅对作业步有效。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}reservation=<name>：从<name>预留资源分配。

\item {} 
\sphinxAtStartPar
–requeue：\sphinxcode{\sphinxupquote{sbtach特有}}，当非配的节点失效或被更高级作业抢占资源后，重新运行该作业。相当于重新运行批处理脚本，小心已运行的结果被覆盖等。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}requeue：任何情况下都不重新运行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}S, \sphinxhyphen{}\sphinxhyphen{}core\sphinxhyphen{}spec=<num>：指定预留的不被作业使用的各节点CPU核数。但也会被记入费用。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}signal=<sig\_num>{[}@<sig\_time>{]}：设定到其终止时间前信号时间<sig\_time>秒时的信号。由于Slurm事件处理的时间精度，信号有可能比设定时间早60秒。信号可以为10或USER1，信号时间sig\_time必须在0到65535之间，如没指定，则默认为60秒。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}sockets\sphinxhyphen{}per\sphinxhyphen{}node=<sockets>：设定每个节点的CPU颗数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}T, \sphinxhyphen{}\sphinxhyphen{}threads=<nthreads>：\sphinxcode{\sphinxupquote{srun特有}}，限制从srun进程发送到分配节点上的并发线程数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}t, \sphinxhyphen{}\sphinxhyphen{}time=<time>：作业最大运行总时间<time>，到时间后将被终止掉。时间<time>的格式可以为：分钟、分钟:秒、小时:分钟:秒、天\sphinxhyphen{}小时、天\sphinxhyphen{}小时:分钟、天\sphinxhyphen{}小时:分钟:秒

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}task\sphinxhyphen{}epilog=<executable>：\sphinxcode{\sphinxupquote{srun特有}}，任务终止后立即执行<executable>，对应于作业步分配。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}task\sphinxhyphen{}prolog=<executable>：\sphinxcode{\sphinxupquote{srun特有}}，任务开始前立即执行<executable>，对应于作业步分配。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}test\sphinxhyphen{}only：\sphinxcode{\sphinxupquote{sbatch与srun特有}}，测试批处理脚本，并预计将被执行的时间，但并不实际执行脚本。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}thread\sphinxhyphen{}spec=<num>：设定指定预留的不被作业使用的各节点线程数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}threads\sphinxhyphen{}per\sphinxhyphen{}core=<threads>：每颗CPU核运行<threads>个线程。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}time\sphinxhyphen{}min=<time>：设定作业分配的最小时间，设定后作业的运行时间将使得\sphinxhyphen{}\sphinxhyphen{}time设定的时间不少于\sphinxhyphen{}\sphinxhyphen{}time\sphinxhyphen{}min设定的。时间格式为：minutes、minutes:seconds、hours:minutes:seconds、days\sphinxhyphen{}hours、days\sphinxhyphen{}hours:minutes和days\sphinxhyphen{}hours:minutes:seconds。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}usage：显示简略帮助信息

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}tmp=<size{[}units{]}>：设定/tmp目录最小磁盘空间，后缀可以为{[}K|M|G|T{]}，默认为MB。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}u, \sphinxhyphen{}\sphinxhyphen{}usage：显示简要帮助信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}u, \sphinxhyphen{}\sphinxhyphen{}unbuffered：\sphinxcode{\sphinxupquote{srun特有}}，该选项使得输出可以不被缓存立即显示出来。默认应用的标准输出被glibc缓存，除非被刷新(flush)或输出被设定为步缓存。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}use\sphinxhyphen{}min\sphinxhyphen{}nodes：设定如果给了一个节点数范围，分配时，选择较小的数。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}V, \sphinxhyphen{}\sphinxhyphen{}version：显示版本信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}v, \sphinxhyphen{}\sphinxhyphen{}verbose：显示详细信息，多个v会显示更详细的详细。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}W, \sphinxhyphen{}\sphinxhyphen{}wait=<seconds>：设定在第一个任务结束后多久结束全部任务。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}w, \sphinxhyphen{}\sphinxhyphen{}nodelist=<host1,host2,… or filename>：在特定<host1,host2>节点或filename文件中指定的节点上运行。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}wait\sphinxhyphen{}all\sphinxhyphen{}nodes=<value>：\sphinxcode{\sphinxupquote{salloc与sbatch特有}}，控制当节点准备好时何时运行命令。默认，当分配的资源准备好后\sphinxcode{\sphinxupquote{salloc}}命令立即返回。<value>可以为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
0：当分配的资源可以分配时立即执行，比如有节点以重启好。

\item {} 
\sphinxAtStartPar
1：只有当分配的所有节点都准备好时才执行

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}X, \sphinxhyphen{}\sphinxhyphen{}disable\sphinxhyphen{}status：\sphinxcode{\sphinxupquote{srun特有}}，禁止在srun收到SIGINT (Ctrl\sphinxhyphen{}C)时显示任务状态。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}x, \sphinxhyphen{}\sphinxhyphen{}exclude=<host1,host2,… or filename>：在特定<host1,host2>节点或filename文件中指定的节点之外的节点上运行。

\end{itemize}


\subsection{IO重定向}
\label{\detokenize{slurm/slurm:io}}\label{\detokenize{slurm/slurm:slurmio}}
\sphinxAtStartPar
默认标准输出文件和标准出错文件将从所有任务中被重定向到\sphinxcode{\sphinxupquote{sbatch和srun}} \sphinxcode{\sphinxupquote{（salloc不存在IO重定向）}}的标准输出文件和标准出错文件，标准输入文件从srun的标准输输入文件重定向到所有任务。如果标准输入仅仅是几个任务需要，建议采用读文件方式而不是重定向方式，以免输入错误数据。

\sphinxAtStartPar
以上行为可以通过\sphinxhyphen{}\sphinxhyphen{}output、\sphinxhyphen{}\sphinxhyphen{}error和\sphinxhyphen{}\sphinxhyphen{}input(\sphinxhyphen{}o、\sphinxhyphen{}e、\sphinxhyphen{}i)等选项改变，有效的格式为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
all：标准输出和标准出错从所有任务定向到srun，标准输入文件从srun的标准输输入文件重定向到所有任务（默认）。

\item {} 
\sphinxAtStartPar
none：标准输出和标准出错不从任何任务定向到srun，标准输入文件不从srun定向到任何任务。

\item {} 
\sphinxAtStartPar
taskid：标准输出和/或标准出错仅从任务号为taskid的任务定向到srun，标准输入文件仅从srun定向到任务号为taskid任务。

\item {} 
\sphinxAtStartPar
filename: srun将所有任务的标准输出和标准出错重定向到filename文件，标准输入文件将从filename文件重定向到全部任务。

\item {} 
\sphinxAtStartPar
格式化字符：srun允许生成采用格式化字符命名的上述IO文件，如可以结合作业号、作业步、节点或任务等。
\begin{itemize}
\item {} 
\sphinxAtStartPar
\textbackslash{}：不处理任何代替符。

\item {} 
\sphinxAtStartPar
\%\%：字符“\%”。

\item {} 
\sphinxAtStartPar
\%A：作业组的主作业分配号。

\item {} 
\sphinxAtStartPar
\%a：作业组ID号。

\item {} 
\sphinxAtStartPar
\%J：运行作业的作业号.步号（如128.0）。

\item {} 
\sphinxAtStartPar
\%j：运行作业的作业号

\item {} 
\sphinxAtStartPar
\%s：运行作业的作业步号。

\item {} 
\sphinxAtStartPar
\%N：短格式节点名，每个节点将生成的不同的IO文件。

\item {} 
\sphinxAtStartPar
\%n：当前作业相关的节点标记（如“0”是运行作业的第一个节点），每个节点将生成的不同的IO文件。

\item {} 
\sphinxAtStartPar
\%t：与当前作业相关的任务标记(rank)，每个rank将生成一个不同的IO文件。

\item {} 
\sphinxAtStartPar
\%u：用户名。

\end{itemize}

\sphinxAtStartPar
在\%与格式化标记符之间的数字可以用于生成前导零，如：
\begin{itemize}
\item {} 
\sphinxAtStartPar
job\%J.out：job128.0.out。

\item {} 
\sphinxAtStartPar
job\%4j.out：job0128.out。

\item {} 
\sphinxAtStartPar
job\%j\sphinxhyphen{}\%2t.out：job128\sphinxhyphen{}00.out、job128\sphinxhyphen{}01.out、…。

\end{itemize}

\end{itemize}


\section{交互式提交并行作业：srun}
\label{\detokenize{slurm/slurm:srun}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{srun}}可以交互式提交运行并行作业，提交后，作业等待运行，等运行完毕后，才返回终端。语法为：\sphinxcode{\sphinxupquote{srun {[}OPTIONS...{]} executable {[}args...{]}}}


\subsection{主要输入环境变量}
\label{\detokenize{slurm/slurm:id21}}
\sphinxAtStartPar
一些提交选项可通过环境变量来设置，命令行的选项优先级高于设置的环境变量，将覆盖掉环境变量的设置。环境变量与对应的参数如下：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_ACCOUNT}}：类似\sphinxhyphen{}A, \sphinxhyphen{}\sphinxhyphen{}account。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_ACCTG\_FREQ}}：类似\sphinxhyphen{}\sphinxhyphen{}acctg\sphinxhyphen{}freq。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_BCAST}}：类似\sphinxhyphen{}\sphinxhyphen{}bcast。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_COMPRESS}}：类似\sphinxhyphen{}\sphinxhyphen{}compress。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CORE\_SPEC}}：类似\sphinxhyphen{}\sphinxhyphen{}core\sphinxhyphen{}spec。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPU\_BIND}}：类似\sphinxhyphen{}\sphinxhyphen{}cpu\sphinxhyphen{}bind。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPUS\_PER\_GPU}}：类似\sphinxhyphen{}c, \sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}gpu。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPUS\_PER\_TASK}}：类似\sphinxhyphen{}c, \sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}task。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_DEBUG}}：类似\sphinxhyphen{}v, \sphinxhyphen{}\sphinxhyphen{}verbose。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_DEPENDENCY}}：类似\sphinxhyphen{}P, \sphinxhyphen{}\sphinxhyphen{}dependency=<jobid>。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_DISABLE\_STATUS}}：类似\sphinxhyphen{}X, \sphinxhyphen{}\sphinxhyphen{}disable\sphinxhyphen{}status。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_DIST\_PLANESIZE}}：类似\sphinxhyphen{}m plane。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_DISTRIBUTION}}：类似\sphinxhyphen{}m, \sphinxhyphen{}\sphinxhyphen{}distribution。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_EPILOG}}：类似\sphinxhyphen{}\sphinxhyphen{}epilog。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_EXCLUSIVE}}：类似\sphinxhyphen{}\sphinxhyphen{}exclusive。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_EXIT\_ERROR}}：Slurm出错时的退出码。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_EXIT\_IMMEDIATE}}：当\sphinxhyphen{}\sphinxhyphen{}immediate使用时且资源当前无效时的Slurm退出码。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GEOMETRY}}：类似\sphinxhyphen{}g, \sphinxhyphen{}\sphinxhyphen{}geometry。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS}}：类似\sphinxhyphen{}G, \sphinxhyphen{}\sphinxhyphen{}gpus。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPU\_BIND}}：类似\sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}bind。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPU\_FREQ}}：类似\sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}freq。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_NODE}}：类似\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}node。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_TASK}}：类似\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}task。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GRES}}：类似\sphinxhyphen{}\sphinxhyphen{}gres，参见\sphinxcode{\sphinxupquote{SLURM\_STEP\_GRES}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_HINT}}：类似\sphinxhyphen{}\sphinxhyphen{}hint。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_IMMEDIATE}}：类似\sphinxhyphen{}I, \sphinxhyphen{}\sphinxhyphen{}immediate。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_ID}}：类似\sphinxhyphen{}\sphinxhyphen{}jobid。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NAME}}：类似\sphinxhyphen{}J, \sphinxhyphen{}\sphinxhyphen{}job\sphinxhyphen{}name。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NODELIST}}：类似\sphinxhyphen{}w, –nodelist=<host1,host2,… or filename>，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NUM\_NODES}}：分配的总节点数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_KILL\_BAD\_EXIT}}：类似\sphinxhyphen{}K, \sphinxhyphen{}\sphinxhyphen{}kill\sphinxhyphen{}on\sphinxhyphen{}bad\sphinxhyphen{}exit。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_LABELIO}}：类似\sphinxhyphen{}l, \sphinxhyphen{}\sphinxhyphen{}label。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_LINUX\_IMAGE}}：类似\sphinxhyphen{}\sphinxhyphen{}linux\sphinxhyphen{}image。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_BIND}}：类似\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_PER\_CPU}}：类似\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}cpu。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_PER\_NODE}}：类似\sphinxhyphen{}\sphinxhyphen{}mem。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MPI\_TYPE}}：类似\sphinxhyphen{}\sphinxhyphen{}mpi。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NETWORK}}：类似\sphinxhyphen{}\sphinxhyphen{}network。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NNODES}}：类似\sphinxhyphen{}N, \sphinxhyphen{}\sphinxhyphen{}nodes，即将废弃。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NO\_KILL}}：类似\sphinxhyphen{}k, \sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}kill。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS}}：类似\sphinxhyphen{}n, \sphinxhyphen{}\sphinxhyphen{}ntasks。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS\_PER\_CORE}}：类似\sphinxhyphen{}\sphinxhyphen{}ntasks\sphinxhyphen{}per\sphinxhyphen{}core。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS\_PER\_SOCKET}}：类似\sphinxhyphen{}\sphinxhyphen{}ntasks\sphinxhyphen{}per\sphinxhyphen{}socket。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS\_PER\_NODE}}：类似\sphinxhyphen{}\sphinxhyphen{}ntasks\sphinxhyphen{}per\sphinxhyphen{}node。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_OPEN\_MODE}}：类似\sphinxhyphen{}\sphinxhyphen{}open\sphinxhyphen{}mode。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_OVERCOMMIT}}：类似\sphinxhyphen{}O, \sphinxhyphen{}\sphinxhyphen{}overcommit。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_PARTITION}}：类似\sphinxhyphen{}p, \sphinxhyphen{}\sphinxhyphen{}partition。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_PROFILE}}：类似\sphinxhyphen{}\sphinxhyphen{}profile。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_PROLOG}}：类似\sphinxhyphen{}\sphinxhyphen{}prolog，\sphinxcode{\sphinxupquote{仅限srun}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_QOS}}：类似\sphinxhyphen{}\sphinxhyphen{}qos。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_REMOTE\_CWD}}：类似\sphinxhyphen{}D, \sphinxhyphen{}\sphinxhyphen{}chdir=。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_RESERVATION}}：类似\sphinxhyphen{}\sphinxhyphen{}reservation。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_RESV\_PORTS}}：类似\sphinxhyphen{}\sphinxhyphen{}resv\sphinxhyphen{}ports。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_SIGNAL}}：类似\sphinxhyphen{}\sphinxhyphen{}signal。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STDERRMODE}}：类似\sphinxhyphen{}e, \sphinxhyphen{}\sphinxhyphen{}error。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STDINMODE}}：类似\sphinxhyphen{}i, \sphinxhyphen{}\sphinxhyphen{}input。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_SRUN\_REDUCE\_TASK\_EXIT\_MSG}}：如被设置，并且非0,那么具有相同退出码的连续的任务退出消息只显示一次。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STEP\_GRES}}：类似\sphinxhyphen{}\sphinxhyphen{}gres（仅对作业步有效，不影响作业分配），参见\sphinxcode{\sphinxupquote{SLURM\_GRES}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STEP\_KILLED\_MSG\_NODE\_ID=ID}}：如被设置，当作业或作业步被信号终止时只特定ID的节点下显示信息。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STDOUTMODE}}：类似\sphinxhyphen{}o, \sphinxhyphen{}\sphinxhyphen{}output。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_TASK\_EPILOG}}：类似\sphinxhyphen{}\sphinxhyphen{}task\sphinxhyphen{}epilog。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_TASK\_PROLOG}}：类似\sphinxhyphen{}\sphinxhyphen{}task\sphinxhyphen{}prolog。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_TEST\_EXEC}}：如被定义，在计算节点执行之前先在本地节点上测试可执行程序。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_THREAD\_SPEC}}：类似\sphinxhyphen{}\sphinxhyphen{}thread\sphinxhyphen{}spec。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_THREADS}}：类似\sphinxhyphen{}T, \sphinxhyphen{}\sphinxhyphen{}threads。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_TIMELIMIT}}：类似\sphinxhyphen{}t, \sphinxhyphen{}\sphinxhyphen{}time。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_UNBUFFEREDIO}}：类似\sphinxhyphen{}u, \sphinxhyphen{}\sphinxhyphen{}unbuffered。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_USE\_MIN\_NODES}}：类似\sphinxhyphen{}\sphinxhyphen{}use\sphinxhyphen{}min\sphinxhyphen{}nodes。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_WAIT}}：类似\sphinxhyphen{}W, \sphinxhyphen{}\sphinxhyphen{}wait。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_WORKING\_DIR}}：类似\sphinxhyphen{}D, \sphinxhyphen{}\sphinxhyphen{}chdir。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SRUN\_EXPORT\_ENV}}：类似\sphinxhyphen{}\sphinxhyphen{}export，将覆盖掉\sphinxcode{\sphinxupquote{SLURM\_EXPORT\_ENV}}。

\end{itemize}


\subsection{主要输出环境变量}
\label{\detokenize{slurm/slurm:id22}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{srun}}会在执行的节点上设置如下环境变量：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CLUSTER\_NAME}}：集群名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPU\_BIND\_VERBOSE}}：\sphinxhyphen{}\sphinxhyphen{}cpu\sphinxhyphen{}bind详细情况(quiet、verbose)。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPU\_BIND\_TYPE}}：\sphinxhyphen{}\sphinxhyphen{}cpu\sphinxhyphen{}bind类型(none、rank、map\sphinxhyphen{}cpu:、mask\sphinxhyphen{}cpu:)。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPU\_BIND\_LIST}}：\sphinxhyphen{}\sphinxhyphen{}cpu\sphinxhyphen{}bind映射或掩码列表。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPU\_FREQ\_REQ}}：需要的CPU频率资源，参见\sphinxhyphen{}\sphinxhyphen{}cpu\sphinxhyphen{}freq和输入环境变量\sphinxcode{\sphinxupquote{SLURM\_CPU\_FREQ\_REQ}}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPUS\_ON\_NODE}}：节点上的CPU颗数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPUS\_PER\_GPU}}：每颗GPU对应的CPU颗数，参见\sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}gpu选项指定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPUS\_PER\_TASK}}：每作业的CPU颗数，参见\sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}task选项指定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_DISTRIBUTION}}：分配的作业的分布类型，参见\sphinxhyphen{}m, \sphinxhyphen{}\sphinxhyphen{}distribution。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS}}：需要的GPU颗数，仅提交时有\sphinxhyphen{}G, \sphinxhyphen{}\sphinxhyphen{}gpus时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPU\_BIND}}：指定绑定任务到GPU，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}bind参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPU\_FREQ}}：需求的GPU频率，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}freq参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_NODE}}：需要的每个节点的GPU颗数，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}node参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_SOCKET}}：需要的每个socket的GPU颗数，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}socket参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_TASK}}：需要的每个任务的GPU颗数，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}task参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GTIDS}}：此节点上分布的全局任务号，从0开始，以,分隔。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_ACCOUNT}}：作业的记账名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_CPUS\_PER\_NODE}}：每个节点的CPU颗数，格式类似40(x3),3，顺序对应\sphinxcode{\sphinxupquote{SLURM\_JOB\_NODELIST}}节点名顺序。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_DEPENDENCY}}：依赖关系，参见\sphinxhyphen{}\sphinxhyphen{}dependency选项。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_ID}}：作业号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NAME}}：作业名，参见\sphinxhyphen{}\sphinxhyphen{}job\sphinxhyphen{}name选项或srun启动的命令名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_PARTITION}}：作业使用的队列名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_QOS}}：作业的服务质量QOS。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_RESERVATION}}：作业的高级资源预留。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_LAUNCH\_NODE\_IPADDR}}：任务初始启动节点的IP地址。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_LOCALID}}：节点本地任务号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_BIND\_LIST}}：\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind映射或掩码列表（<list of IDs or masks for this node>）。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_BIND\_PREFER}}：\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bin prefer优先权。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_BIND\_TYPE}}：\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind类型（none、rank、map\sphinxhyphen{}mem:、mask\sphinxhyphen{}mem:）。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_BIND\_VERBOSE}}：内存绑定详细情况，参见\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind verbosity（quiet、verbose）。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_PER\_GPU}}：每颗GPU需求的内存，参见\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}gpu。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NODE\_ALIASES}}：分配的节点名、通信IP地址和节点名，每组内采用:分隔，组间通过,分隔，如：\sphinxcode{\sphinxupquote{SLURM\_NODE\_ALIASES}}=0:1.2.3.4:foo,ec1:1.2.3.5:bar。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NODEID}}：当前节点的相对节点号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NODELIST}}：分配的节点列表，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS}}：任务总数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_PRIO\_PROCESS}}：作业提交时的调度优先级值（nice值）。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_PROCID}}：当前MPI秩号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_SRUN\_COMM\_HOST}}：节点的通信IP。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_SRUN\_COMM\_PORT}}：srun的通信端口。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STEP\_LAUNCHER\_PORT}}：作业步启动端口。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STEP\_NODELIST}}：作业步节点列表，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STEP\_NUM\_NODES}}：作业步的节点总数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STEP\_NUM\_TASKS}}：作业步的任务总数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STEP\_TASKS\_PER\_NODE}}：作业步在每个节点上的任务总数，格式类似40(x3),3，顺序对应\sphinxcode{\sphinxupquote{SLURM\_JOB\_NODELIST}}节点名顺序。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STEP\_ID}}：当前作业的作业步号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_SUBMIT\_DIR}}：提交作业的目录，或有可能由\sphinxhyphen{}D,–chdir参数指定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_SUBMIT\_HOST}}：提交作业的节点名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_TASK\_PID}}：任务启动的进程号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_TASKS\_PER\_NODE}}：每个节点上启动的任务数，以\sphinxcode{\sphinxupquote{SLURM\_NODELIST}}中的节点顺序显示，以,分隔。如果两个或多个连续节点上的任务数相同，数后跟着(x\#)，其中\#是对应的节点数，如\sphinxcode{\sphinxupquote{SLURM\_TASKS\_PER\_NODE}}=2(x3),1”表示，前三个节点上的作业数为3，第四个节点上的任务数为1。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_UMASK}}：作业提交时的umask掩码。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURMD\_NODENAME}}：任务运行的节点名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SRUN\_DEBUG}}：srun命令的调试详细信息级别，默认为3（info级）。

\end{itemize}


\subsection{多程序运行配置}
\label{\detokenize{slurm/slurm:id23}}
\sphinxAtStartPar
Slurm支持一次申请多个节点，在不同节点上同时启动执行不同任务。为实现次功能，需要生成一个配置文件，在配置文件中做相应设置。

\sphinxAtStartPar
配置文件中的注释必需第一列为\#，配置文件包含以空格分隔的以下域（字段）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
任务范围(Task rank)：一个或多个任务秩，多个值的话可以用逗号,分隔。范围可以用两个用\sphinxhyphen{}分隔的整数表示，小数在前，大数在后。如果最后一行为*，则表示全部其余未在前面声明的秩。如没有指明可执行程序，则会显示错误信息：“No executable program specified for this task”。

\item {} 
\sphinxAtStartPar
需要执行的可执行程序(Executable)：也许需要绝对路径指明。

\item {} 
\sphinxAtStartPar
可执行程序的参数(Arguments)：“\%t”将被替换为任务号；“\%o”将被替换为任务号偏移（如配置的秩为“1\sphinxhyphen{}5”，则偏移值为“0\sphinxhyphen{}4”）。单引号可以防止内部的字符被解释。此域为可选项，任何在命令行中需要添加的程序参数都将加在配置文件中的此部分。

\end{itemize}

\sphinxAtStartPar
例如，配置文件silly.conf内容为：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} srun multiple program configuration file}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} srun \PYGZhy{}n8 \PYGZhy{}l \PYGZhy{}\PYGZbs{}\PYGZhy{}multi\PYGZhy{}prog silly.conf}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{l+m+mi}{4}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}       \PYG{n}{hostname}
\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{7}       \PYG{n}{echo}  \PYG{n}{task}\PYG{p}{:}\PYG{o}{\PYGZpc{}}\PYG{n}{t}
\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}     \PYG{n}{echo}  \PYG{n}{offset}\PYG{p}{:}\PYG{o}{\PYGZpc{}}\PYG{n}{o}
\end{sphinxVerbatim}

\sphinxAtStartPar
运行：\sphinxcode{\sphinxupquote{srun \sphinxhyphen{}n8 \sphinxhyphen{}l \sphinxhyphen{}\textbackslash{}\sphinxhyphen{}multi\sphinxhyphen{}prog silly.conf}}

\sphinxAtStartPar
输出结果：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{n}{offset}\PYG{p}{:}\PYG{l+m+mi}{0}
\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{task}\PYG{p}{:}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2}\PYG{p}{:} \PYG{n}{offset}\PYG{p}{:}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{3}\PYG{p}{:} \PYG{n}{offset}\PYG{p}{:}\PYG{l+m+mi}{2}
\PYG{l+m+mi}{4}\PYG{p}{:} \PYG{n}{node1}
\PYG{l+m+mi}{5}\PYG{p}{:} \PYG{n}{node2}
\PYG{l+m+mi}{6}\PYG{p}{:} \PYG{n}{node4}
\PYG{l+m+mi}{7}\PYG{p}{:} \PYG{n}{task}\PYG{p}{:}\PYG{l+m+mi}{7}
\end{sphinxVerbatim}


\subsection{常见例子}
\label{\detokenize{slurm/slurm:id24}}\begin{itemize}
\item {} 
\sphinxAtStartPar
使用8个CPU核(\sphinxhyphen{}n8)运行作业，并在标准输出上显示任务号(\sphinxhyphen{}l)：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{srun \sphinxhyphen{}n8 \sphinxhyphen{}l hostname}}

\sphinxAtStartPar
输出结果：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{n}{node0}
\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{node0}
\PYG{l+m+mi}{2}\PYG{p}{:} \PYG{n}{node1}
\PYG{l+m+mi}{3}\PYG{p}{:} \PYG{n}{node1}
\PYG{l+m+mi}{4}\PYG{p}{:} \PYG{n}{node2}
\PYG{l+m+mi}{5}\PYG{p}{:} \PYG{n}{node2}
\PYG{l+m+mi}{6}\PYG{p}{:} \PYG{n}{node3}
\PYG{l+m+mi}{7}\PYG{p}{:} \PYG{n}{node3}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在脚本中使用\sphinxhyphen{}r2参数使其在第2号（分配的节点号从0开始）开始的两个节点上运行，并采用实时分配模式而不是批处理模式运行：

\sphinxAtStartPar
脚本\sphinxcode{\sphinxupquote{test.sh}}内容：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}NODELIST}
srun \PYGZhy{}lN2 \PYGZhy{}r2 hostname
srun \PYGZhy{}lN2 hostname
\end{sphinxVerbatim}

\sphinxAtStartPar
运行： \sphinxcode{\sphinxupquote{salloc \sphinxhyphen{}N4 test.sh}}

\sphinxAtStartPar
输出结果：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dev}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}
\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{n}{node9}
\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{node10}
\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{n}{node7}
\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{node8}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在分配的节点上并行运行两个作业步：

\sphinxAtStartPar
脚本\sphinxcode{\sphinxupquote{test.sh}}内容：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
srun \PYGZhy{}lN2 \PYGZhy{}n4 \PYGZhy{}r \PYG{l+m}{2} sleep \PYG{l+m}{60} \PYG{p}{\PYGZam{}}
srun \PYGZhy{}lN2 \PYGZhy{}r \PYG{l+m}{0} sleep \PYG{l+m}{60} \PYG{p}{\PYGZam{}}
sleep \PYG{l+m}{1}
squeue
squeue \PYGZhy{}s
\PYG{n+nb}{wait}
\end{sphinxVerbatim}

\sphinxAtStartPar
运行： \sphinxcode{\sphinxupquote{salloc \sphinxhyphen{}N4 test.sh}}

\sphinxAtStartPar
输出结果：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{JOBID} \PYG{n}{PARTITION}     \PYG{n}{NAME}     \PYG{n}{USER}  \PYG{n}{ST}      \PYG{n}{TIME}  \PYG{n}{NODES} \PYG{n}{NODELIST}
\PYG{l+m+mi}{65641}     \PYG{n}{batch}  \PYG{n}{test}\PYG{o}{.}\PYG{n}{sh}   \PYG{n}{grondo}   \PYG{n}{R}      \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{01}      \PYG{l+m+mi}{4} \PYG{n}{dev}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}

\PYG{n}{STEPID}     \PYG{n}{PARTITION}     \PYG{n}{USER}      \PYG{n}{TIME} \PYG{n}{NODELIST}
\PYG{l+m+mf}{65641.0}        \PYG{n}{batch}   \PYG{n}{grondo}      \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{01} \PYG{n}{dev}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{]}
\PYG{l+m+mf}{65641.1}        \PYG{n}{batch}   \PYG{n}{grondo}      \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{01} \PYG{n}{dev}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
运行MPICH作业：

\sphinxAtStartPar
脚本\sphinxcode{\sphinxupquote{test.sh}}内容：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{n+nv}{MACHINEFILE}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nodes.}\PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}ID}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} 生成MPICH所需的包含节点名的machinfile文件}
srun \PYGZhy{}l /bin/hostname \PYG{p}{|} sort \PYGZhy{}n \PYG{p}{|} awk ’\PYG{o}{\PYGZob{}}print \PYG{n+nv}{\PYGZdl{}2}\PYG{o}{\PYGZcb{}}’ \PYGZgt{} \PYG{n+nv}{\PYGZdl{}MACHINEFILE}

\PYG{c+c1}{\PYGZsh{} 运行MPICH作业}
mpirun \PYGZhy{}np \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}NTASKS} \PYGZhy{}machinefile \PYG{n+nv}{\PYGZdl{}MACHINEFILE} mpi\PYGZhy{}app

rm \PYG{n+nv}{\PYGZdl{}MACHINEFILE}
\end{sphinxVerbatim}

\sphinxAtStartPar
采用2个节点（\sphinxhyphen{}N2）共4个CPU核（\sphinxhyphen{}n4）运行：\sphinxcode{\sphinxupquote{salloc \sphinxhyphen{}N2 \sphinxhyphen{}n4 test.sh}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
利用不同节点号（\sphinxcode{\sphinxupquote{SLURM\_NODEID}}）运行不同作业，节点号从0开始：

\sphinxAtStartPar
脚本\sphinxcode{\sphinxupquote{test.sh}}内容：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{case} \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}NODEID} \PYG{k}{in}
     \PYG{l+m}{0}\PYG{o}{)}
        \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}I am running on \PYGZdq{}}
        hostname
        \PYG{p}{;}\PYG{p}{;}
     \PYG{l+m}{1}\PYG{o}{)}
        hostname
        \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}is where I am running\PYGZdq{}}
        \PYG{p}{;}\PYG{p}{;}
 \PYG{k}{esac}
\end{sphinxVerbatim}

\sphinxAtStartPar
运行： \sphinxcode{\sphinxupquote{srun \sphinxhyphen{}N2 test.sh}}
\begin{quote}

\sphinxAtStartPar
输出：
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dev0} \PYG{o+ow}{is} \PYG{n}{where} \PYG{n}{I} \PYG{n}{am} \PYG{n}{running} \PYG{n}{I} \PYG{n}{am} \PYG{n}{running} \PYG{n}{on} \PYG{n}{ev1}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
利用多核选项控制任务执行：

\sphinxAtStartPar
采用2个节点（\sphinxhyphen{}N2），每节点4颗CPU每颗CPU 2颗CPU核（\sphinxhyphen{}B 4\sphinxhyphen{}4:2\sphinxhyphen{}2），运行作业：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{srun \sphinxhyphen{}N2 \sphinxhyphen{}B 4\sphinxhyphen{}4:2\sphinxhyphen{}2 a.out}}

\item {} 
\sphinxAtStartPar
运行GPU作业： 脚本\sphinxcode{\sphinxupquote{gpu.sh}}内容：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
srun \PYGZhy{}n1 \PYGZhy{}p GPU\PYGZhy{}V100 \PYGZhy{}\PYGZhy{}gres\PYG{o}{=}gpu:v100:2 prog1 \PYG{p}{\PYGZam{}}
\PYG{n+nb}{wait}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxhyphen{}p GPU\sphinxhyphen{}V100指定采用GPU队列GPU\sphinxhyphen{}V100，–gres=gpu:v100:2指明每个节点使用2块NVIDIA V100 GPU卡。
\begin{itemize}
\item {} 
\sphinxAtStartPar
排它性独占运行作业：

\sphinxAtStartPar
脚本\sphinxcode{\sphinxupquote{my.sh}}内容：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
srun \PYGZhy{}\PYGZhy{}exclusive \PYGZhy{}n4 prog1 \PYG{p}{\PYGZam{}}
srun \PYGZhy{}\PYGZhy{}exclusive \PYGZhy{}n3 prog2 \PYG{p}{\PYGZam{}}
srun \PYGZhy{}\PYGZhy{}exclusive \PYGZhy{}n1 prog3 \PYG{p}{\PYGZam{}}
srun \PYGZhy{}\PYGZhy{}exclusive \PYGZhy{}n1 prog4 \PYG{p}{\PYGZam{}}
\PYG{n+nb}{wait}
\end{sphinxVerbatim}


\section{批处理方式提交作业：sbatch}
\label{\detokenize{slurm/slurm:sbatch}}
\sphinxAtStartPar
Slurm支持利用\sphinxcode{\sphinxupquote{sbatch}}命令采用批处理方式运行作业，\sphinxcode{\sphinxupquote{sbatch}}命令在脚本正确传递给作业调度系统后立即退出，同时获取到一个作业号。作业等所需资源满足后开始运行。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sbatch}}提交一个批处理作业脚本到Slurm。批处理脚本名可以在命令行上通过传递给\sphinxcode{\sphinxupquote{sbatch}}，如没有指定文件名，则\sphinxcode{\sphinxupquote{sbatch}}从标准输入中获取脚本内容。

\sphinxAtStartPar
脚本文件基本格式：
\begin{itemize}
\item {} 
\sphinxAtStartPar
第一行以\#!/bin/sh等指定该脚本的解释程序，/bin/sh可以变为/bin/bash、/bin/csh等。

\item {} 
\sphinxAtStartPar
在可执行命令之前的每行“\#SBATCH”前缀后跟的参数作为作业调度系统参数。在任何非注释及空白之后的“\#SBATCH”将不再作为Slurm参数处理。

\end{itemize}

\sphinxAtStartPar
默认，标准输出和标准出错都定向到同一个文件\sphinxcode{\sphinxupquote{slurm\sphinxhyphen{}\%j.out}}，“\%j”将被作业号代替。

\sphinxAtStartPar
脚本\sphinxcode{\sphinxupquote{myscript}}内容：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}time=1}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}p serial}
srun hostname \PYG{p}{|}sort
\end{sphinxVerbatim}

\sphinxAtStartPar
采用4个节点（\sphinxhyphen{}N4）运行：\sphinxcode{\sphinxupquote{sbatch \sphinxhyphen{}p batch \sphinxhyphen{}N4 myscript}}

\sphinxAtStartPar
在这里，虽然脚本中利用“\#SBATCH \sphinxhyphen{}p serial”指定了使用serial队列，但命令行中的\sphinxcode{\sphinxupquote{\sphinxhyphen{}p batch}}优先级更高，因此实际提交到batch队列。

\sphinxAtStartPar
提交成功后有类似输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{salloc}\PYG{p}{:} \PYG{n}{Granted} \PYG{n}{job} \PYG{n}{allocation} \PYG{l+m+mi}{65537}
\end{sphinxVerbatim}

\sphinxAtStartPar
其中65537为分配的作业号。

\sphinxAtStartPar
程序结束后的作业日志文件\sphinxcode{\sphinxupquote{slurm\sphinxhyphen{}65537.out}}显示：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{node1}
\PYG{n}{node2}
\PYG{n}{node3}
\PYG{n}{node4}
\end{sphinxVerbatim}

\sphinxAtStartPar
从标准输入获取脚本内容，可采用以下两种方式之一：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
运行\sphinxcode{\sphinxupquote{sbatch \sphinxhyphen{}N4}}，显示等待后输入：

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
srun hostname \PYG{l+s+se}{\PYGZbs{}|}sort
\end{sphinxVerbatim}

\sphinxAtStartPar
输入以上内容后按CTRL+D终止输入。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
运行\sphinxcode{\sphinxupquote{sbatch \sphinxhyphen{}N4 <<EOF}}，

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{} \PYG{c+c1}{\PYGZsh{}!/bin/sh}
\PYGZgt{} srun hostname \PYG{p}{|} sort
\PYGZgt{} EOF

  \PYGZhy{}  第一个EOF表示输入内容的开始标识符

  \PYGZhy{}  最后的EOF表示输入内容的终止标识符，在两个EOF之间的内容为实际执行的内容。

  \PYGZhy{}  \PYGZgt{}实际上是每行输入回车后自动在下一行出现的提示符。
\end{sphinxVerbatim}

\sphinxAtStartPar
以上两种方式输入结束后将显示：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sbatch}\PYG{p}{:} \PYG{n}{Submitted} \PYG{n}{batch} \PYG{n}{job} \PYG{l+m+mi}{65541}
\end{sphinxVerbatim}

\sphinxAtStartPar
常见主要选项参见{\hyperref[\detokenize{slurm/slurm:slurmoption}]{\emph{9.1}}}。


\subsection{主要输入环境变量}
\label{\detokenize{slurm/slurm:id25}}\label{\detokenize{slurm/slurm:id26}}
\sphinxAtStartPar
一些选项可通过环境变量来设置，命令行的选项优先级高于设置的环境变量，将覆盖掉环境变量的设置。环境变量与对应的参数如下：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_ACCOUNT}}：类似\sphinxhyphen{}A、\sphinxhyphen{}\sphinxhyphen{}account。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_ACCTG\_FREQ}}：类似\sphinxhyphen{}\sphinxhyphen{}acctg\sphinxhyphen{}freq。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_ARRAY\_INX}}：类似\sphinxhyphen{}a、\sphinxhyphen{}\sphinxhyphen{}array。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_BATCH}}：类似\sphinxhyphen{}\sphinxhyphen{}batch。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_CLUSTERS 或 SLURM\_CLUSTERS}}：类似\sphinxhyphen{}\sphinxhyphen{}clusters。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_CONSTRAINT}}：类似\sphinxhyphen{}C, \sphinxhyphen{}\sphinxhyphen{}constraint。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_CORE\_SPEC}}：类似\sphinxhyphen{}\sphinxhyphen{}core\sphinxhyphen{}spec。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_CPUS\_PER\_GPU}}：类似\sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}gpu。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_DEBUG}}：类似\sphinxhyphen{}v、\sphinxhyphen{}\sphinxhyphen{}verbose。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_DISTRIBUTION}}：类似\sphinxhyphen{}m、\sphinxhyphen{}\sphinxhyphen{}distribution。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_EXCLUSIVE}}：类似\sphinxhyphen{}\sphinxhyphen{}exclusive。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_EXPORT}}：类似\sphinxhyphen{}\sphinxhyphen{}export。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_GEOMETRY}}：类似\sphinxhyphen{}g、\sphinxhyphen{}\sphinxhyphen{}geometry。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_GET\_USER\_ENV}}：类似\sphinxhyphen{}\sphinxhyphen{}get\sphinxhyphen{}user\sphinxhyphen{}env。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_GPUS}}：类似 \sphinxhyphen{}G, \sphinxhyphen{}\sphinxhyphen{}gpus。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_GPU\_BIND}}：类似 \sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}bind。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_GPU\_FREQ}}：类似 \sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}freq。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_GPUS\_PER\_NODE}}：类似 \sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}node。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_GPUS\_PER\_TASK}}：类似 \sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}task。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_GRES}}：类似 \sphinxhyphen{}\sphinxhyphen{}gres。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_GRES\_FLAGS}}：类似\sphinxhyphen{}\sphinxhyphen{}gres\sphinxhyphen{}flags。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_HINT 或 SLURM\_HINT}}：类似\sphinxhyphen{}\sphinxhyphen{}hint。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_IGNORE\_PBS}}：类似\sphinxhyphen{}\sphinxhyphen{}ignore\sphinxhyphen{}pbs。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_JOB\_NAME}}：类似\sphinxhyphen{}J、\sphinxhyphen{}\sphinxhyphen{}job\sphinxhyphen{}name。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_MEM\_BIND}}：类似\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_MEM\_PER\_CPU}}：类似\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}cpu。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_MEM\_PER\_GPU}}：类似\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}gpu。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_MEM\_PER\_NODE}}：类似\sphinxhyphen{}\sphinxhyphen{}mem。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_NETWORK}}：类似\sphinxhyphen{}\sphinxhyphen{}network。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_NO\_KILL}}：类似\sphinxhyphen{}k, –no\sphinxhyphen{}kill。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_NO\_REQUEUE}}：类似\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}requeue。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_OPEN\_MODE}}：类似\sphinxhyphen{}\sphinxhyphen{}open\sphinxhyphen{}mode。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_OVERCOMMIT}}：类似\sphinxhyphen{}O、\sphinxhyphen{}\sphinxhyphen{}overcommit。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_PARTITION}}：类似\sphinxhyphen{}p、\sphinxhyphen{}\sphinxhyphen{}partition。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_PROFILE}}：类似\sphinxhyphen{}\sphinxhyphen{}profile。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_QOS}}：类似\sphinxhyphen{}\sphinxhyphen{}qos。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_RAMDISK\_IMAGE}}：类似\sphinxhyphen{}\sphinxhyphen{}ramdisk\sphinxhyphen{}image。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_RESERVATION}}：类似\sphinxhyphen{}\sphinxhyphen{}reservation。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_REQUEUE}}：类似\sphinxhyphen{}\sphinxhyphen{}requeue。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_SIGNAL}}：类似\sphinxhyphen{}\sphinxhyphen{}signal。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_THREAD\_SPEC}}：类似\sphinxhyphen{}\sphinxhyphen{}thread\sphinxhyphen{}spec。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_TIMELIMIT}}：类似\sphinxhyphen{}t、\sphinxhyphen{}\sphinxhyphen{}time。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_USE\_MIN\_NODES}}：类似\sphinxhyphen{}\sphinxhyphen{}use\sphinxhyphen{}min\sphinxhyphen{}nodes。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_WAIT}}：类似\sphinxhyphen{}W、\sphinxhyphen{}\sphinxhyphen{}wait。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_WAIT\_ALL\_NODES}}：类似\sphinxhyphen{}\sphinxhyphen{}wait\sphinxhyphen{}all\sphinxhyphen{}nodes。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_WAIT4SWITCH}}：需要交换的最大时间，参见See\sphinxhyphen{}\sphinxhyphen{}switches。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_EXIT\_ERROR}}：设定Slurm出错时的退出码。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_STEP\_KILLED\_MSG\_NODE\_ID=ID}}：如果设置，当作业或作业步被信号终止时，只有指定ID的节点记录。

\end{itemize}


\subsection{主要输出环境变量}
\label{\detokenize{slurm/slurm:id27}}\label{\detokenize{slurm/slurm:id28}}
\sphinxAtStartPar
Slurm将在作业脚本中输出以下变量，作业脚本可以使用这些变量：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_MEM\_BIND}}：\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind选项设定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_MEM\_BIND\_VERBOSE}}：如\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind选项包含verbose选项时，则由其设定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_MEM\_BIND\_LIST}}：内存绑定时设定的bit掩码。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_MEM\_BIND\_PREFER}}：\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bin prefer优先权。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SBATCH\_MEM\_BIND\_TYPE}}：由\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind选项设定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_ARRAY\_TASK\_ID}}：作业组ID（索引）号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_ARRAY\_TASK\_MAX}}：作业组最大ID号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_ARRAY\_TASK\_MIN}}：作业组最小ID号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_ARRAY\_TASK\_STEP}}：作业组索引步进间隔。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_ARRAY\_JOB\_ID}}：作业组主作业号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CLUSTER\_NAME}}：集群名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPUS\_ON\_NODE}}：分配的节点上的CPU颗数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPUS\_PER\_GPU}}：每个任务的CPU颗数，只有\sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}gpu选项设定时才有。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPUS\_PER\_TASK}}：每个任务的CPU颗数，只有\sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}task选项设定时才有。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_DISTRIBUTION}}：类似\sphinxhyphen{}m, \sphinxhyphen{}\sphinxhyphen{}distribution。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_EXPORT\_ENV}}：类似\sphinxhyphen{}e, \sphinxhyphen{}\sphinxhyphen{}export。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPU\_BIND}}：指定绑定任务到GPU，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}bind参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPU\_FREQ}}：需求的GPU频率，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}freq参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS}} Number of GPUs requested. Only set if the \sphinxhyphen{}G, \sphinxhyphen{}\sphinxhyphen{}gpus option is specified.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPU\_BIND}}：需要的任务绑定到GPU，仅提交时有–gpu\sphinxhyphen{}bind参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_NODE}}：需要的每个节点的GPU颗数，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}node参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_SOCKET}}：需要的每个socket的GPU颗数，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}socket参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_TASK}}：需要的每个任务的GPU颗数，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}task参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GTIDS}}：在此节点上运行的全局任务号。以0开始，逗号,分隔。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_ACCOUNT}}：作业的记账账户名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_ID}}：作业号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_CPUS\_PER\_NODE}}：每个节点上的CPU颗数，格式类似40(x3),3，顺序对应\sphinxcode{\sphinxupquote{SLURM\_JOB\_NODELIST}}节点名顺序。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_DEPENDENCY}}：作业依赖信息，由\sphinxhyphen{}\sphinxhyphen{}dependency选项设置。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NAME}}：作业名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NODELIST}}：分配的节点名列表，格式类似node{[}1\sphinxhyphen{}10,11,13\sphinxhyphen{}28{]}。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NUM\_NODES}}：分配的节点总数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_PARTITION}}：使用的队列名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_QOS}}：需要的服务质量(QOS)。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_RESERVATION}}：作业预留。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_LOCALID}}：节点本地任务号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_PER\_CPU}}：类似\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}cpu，每颗CPU需要的内存。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_PER\_GPU}}：类似\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}gpu，每颗GPU需要的内存。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_PER\_NODE}}：类似\sphinxhyphen{}\sphinxhyphen{}mem，每个节点的内存。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NODE\_ALIASES}}：分配的节点名、通信IP地址和主机名组合，类似 \sphinxcode{\sphinxupquote{SLURM\_NODE\_ALIASES}}=ec0:1.2.3.4:foo,ec1:1.2.3.5:bar。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NODEID}}：分配的节点号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS}}：类似\sphinxhyphen{}n, \sphinxhyphen{}\sphinxhyphen{}ntasks，总任务数，CPU核数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS\_PER\_CORE}}：每个CPU核分配的任务数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS\_PER\_NODE}}：每个节点上的任务数 。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS\_PER\_SOCKET}}：每颗CPU上的任务数，仅\sphinxhyphen{}\sphinxhyphen{}ntasks\sphinxhyphen{}per\sphinxhyphen{}socket选项设定时设定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_PRIO\_PROCESS}}：进程的调度优先级（nice值）。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_PROCID}}：当前进程的MPI秩。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_PROFILE}}：类似\sphinxhyphen{}\sphinxhyphen{}profile。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_RESTART\_COUNT}}：因为系统失效等导致的重启次数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_SUBMIT\_DIR}}：sbatch启动目录，即提交作业时目录，或提交时由\sphinxhyphen{}D, \sphinxhyphen{}\sphinxhyphen{}chdir参数指定的。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_SUBMIT\_HOST}}：sbatch启动的节点名，即提交作业时节点。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_TASKS\_PER\_NODE}}：每节点上的任务数，以\sphinxcode{\sphinxupquote{SLURM\_NODELIST}}中的节点顺序显示，以,分隔。如果两个或多个连续节点上的任务数相同，数后跟着(x\#)，其中\#是对应的节点数，如“\sphinxcode{\sphinxupquote{SLURM\_TASKS\_PER\_NODE}}=2(x3),1”表示前三个节点上的作业数为3，第四个节点上的任务数为1。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_TASK\_PID}}：任务的进程号PID。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURMD\_NODENAME}}：执行作业脚本的节点名。

\end{itemize}


\subsection{串行作业提交}
\label{\detokenize{slurm/slurm:id29}}
\sphinxAtStartPar
对于串行程序，用户可类似下面两者之一：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
直接采用\sphinxcode{\sphinxupquote{sbatch \sphinxhyphen{}n1 \sphinxhyphen{}o job\sphinxhyphen{}\%j.log \sphinxhyphen{}e job\sphinxhyphen{}\%j.err yourprog}}方式运行

\item {} 
\sphinxAtStartPar
编写命名为\sphinxcode{\sphinxupquote{serial\_job.sh}}（此脚本名可以按照用户喜好命名）的串行作业脚本，其内容如下：

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{c+c1}{\PYGZsh{}An example for serial job.}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}J job\PYGZus{}name}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}o job\PYGZhy{}\PYGZpc{}j.log}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}e job\PYGZhy{}\PYGZpc{}j.err}

\PYG{n+nb}{echo} Running on hosts
\PYG{n+nb}{echo} Time is \PYG{l+s+sb}{`}date\PYG{l+s+sb}{`}
\PYG{n+nb}{echo} Directory is \PYG{n+nv}{\PYGZdl{}PWD}
\PYG{n+nb}{echo} This job runs on the following nodes:
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}NODELIST}

module load intel/2019.update5

\PYG{n+nb}{echo} This job has allocated \PYG{l+m}{1} cpu core.

./yourprog
\end{sphinxVerbatim}

\sphinxAtStartPar
必要时需在脚本文件中利用\sphinxcode{\sphinxupquote{module}}命令设置所需的环境，如上面的\sphinxcode{\sphinxupquote{module load intel/2019.update5}}。

\sphinxAtStartPar
作业脚本编写完成后，可以按照下面命令提交作业：
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmli@login01:\textasciitilde{}/work\$ sbatch \sphinxhyphen{}n1 \sphinxhyphen{}p serail serial\_job.sh}}
\end{quote}


\subsection{OpenMP共享内存并行作业提交}
\label{\detokenize{slurm/slurm:openmp}}
\sphinxAtStartPar
对于OpenMP共享内存并行程序，可编写命名为\sphinxcode{\sphinxupquote{omp\_job.sh}}的作业脚本，内容如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{c+c1}{\PYGZsh{}An example for serial job.}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}J job\PYGZus{}name}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}o job\PYGZhy{}\PYGZpc{}j.log}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}e job\PYGZhy{}\PYGZpc{}j.err}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}N 1 \PYGZhy{}n 8}

\PYG{n+nb}{echo} Running on hosts
\PYG{n+nb}{echo} Time is \PYG{l+s+sb}{`}date\PYG{l+s+sb}{`}
\PYG{n+nb}{echo} Directory is \PYG{n+nv}{\PYGZdl{}PWD}
\PYG{n+nb}{echo} This job runs on the following nodes:
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}NODELIST}

module load intel/2016.3.210
\PYG{n+nb}{echo} This job has allocated \PYG{l+m}{1} cpu core.
\PYG{n+nb}{export} \PYG{n+nv}{OMP\PYGZus{}NUM\PYGZus{}THREADS}\PYG{o}{=}\PYG{l+m}{8}
./yourprog
\end{sphinxVerbatim}

\sphinxAtStartPar
相对于串行作业脚本，主要增加\sphinxcode{\sphinxupquote{export OMP\_NUM\_THREADS=8}}和 \sphinxcode{\sphinxupquote{\#SBATCH \sphinxhyphen{}N 1 \sphinxhyphen{}n 8}}，表示使用一个节点内部的八个核，从而保证是在同一个节点内部，需几个核就设置\sphinxhyphen{}n为几。\sphinxhyphen{}n后跟的不能超过单节点内CPU核数。

\sphinxAtStartPar
作业脚本编写完成后，可以按照下面命令提交作业：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmli@login01:\textasciitilde{}/work\$ sbatch omp\_job.sh}}


\subsection{MPI并行作业提交}
\label{\detokenize{slurm/slurm:mpi}}
\sphinxAtStartPar
与串行作业类似，对于MPI并行作业，则需编写类似下面脚本\sphinxcode{\sphinxupquote{mpi\_job.sh}}：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{c+c1}{\PYGZsh{}An example for MPI job.}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}J job\PYGZus{}name}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}o job\PYGZhy{}\PYGZpc{}j.log}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}e job\PYGZhy{}\PYGZpc{}j.err}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}N 1 \PYGZhy{}n 8}

\PYG{n+nb}{echo} Time is \PYG{l+s+sb}{`}date\PYG{l+s+sb}{`}
\PYG{n+nb}{echo} Directory is \PYG{n+nv}{\PYGZdl{}PWD}
\PYG{n+nb}{echo} This job runs on the following nodes:
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}NODELIST}
\PYG{n+nb}{echo} This job has allocated \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}CPUS\PYGZus{}PER\PYGZus{}NODE} cpu cores.

module load intelmpi/5.1.3.210
\PYG{c+c1}{\PYGZsh{}module load mpich/3.2/intel/2016.3.210}
\PYG{c+c1}{\PYGZsh{}module load openmpi/2.0.0/intel/2016.3.210}
\PYG{n+nv}{MPIRUN}\PYG{o}{=}mpirun \PYG{c+c1}{\PYGZsh{}Intel mpi and Open MPI}
\PYG{c+c1}{\PYGZsh{}MPIRUN=mpiexec \PYGZsh{}MPICH}
\PYG{n+nv}{MPIOPT}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}env I\PYGZus{}MPI\PYGZus{}FABRICS shm:ofa\PYGZdq{}} \PYG{c+c1}{\PYGZsh{}Intel MPI 2018}
\PYG{c+c1}{\PYGZsh{}MPIOPT=\PYGZdq{}\PYGZhy{}env I\PYGZus{}MPI\PYGZus{}FABRICS shm:ofi\PYGZdq{} \PYGZsh{}Intel MPI 2019}
\PYG{c+c1}{\PYGZsh{}MPIOPT=\PYGZdq{}\PYGZhy{}\PYGZhy{}mca plm\PYGZus{}rsh\PYGZus{}agent ssh \PYGZhy{}\PYGZhy{}mca btl self,openib,sm\PYGZdq{} \PYGZsh{}Open MPI}
\PYG{c+c1}{\PYGZsh{}MPIOPT=\PYGZdq{}\PYGZhy{}iface ib0\PYGZdq{} \PYGZsh{}MPICH3}
\PYG{c+c1}{\PYGZsh{}目前新版的MPI可以自己找寻高速网络配置，可以设置MPIOPT为空，如去掉下行的\PYGZsh{}}
\PYG{n+nv}{MPIOPT}\PYG{o}{=}
\PYG{n+nv}{\PYGZdl{}MPIRUN} \PYG{n+nv}{\PYGZdl{}MPIOPT} ./yourprog
\end{sphinxVerbatim}

\sphinxAtStartPar
与串行程序的脚本相比，主要不同之处在于需采用mpirun或mpiexec的命令格式提交并行可执行程序。采用不同MPI提交时，需要打开上述对应的选项。

\sphinxAtStartPar
与串行作业类似，可使用下面方式提交：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmli@login01:\textasciitilde{}/work\$ sbatch mpi\_job.sh}}


\subsection{GPU作业提交}
\label{\detokenize{slurm/slurm:gpu}}
\sphinxAtStartPar
运行GPU作业，需要提交时利用\sphinxhyphen{}\sphinxhyphen{}gres=gpu等指明需要的GPU资源并用\sphinxhyphen{}p指明采用等GPU队列。

\sphinxAtStartPar
脚本\sphinxcode{\sphinxupquote{gpu\_job.sh}}内容：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{c+c1}{\PYGZsh{}An example for gpu job.}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}J job\PYGZus{}name}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}o job\PYGZhy{}\PYGZpc{}j.log}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}e job\PYGZhy{}\PYGZpc{}j.err}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}N 1 \PYGZhy{}n 8 \PYGZhy{}p GPU\PYGZhy{}V100 \PYGZhy{}\PYGZhy{}gres=gpu:v100:2}
./your\PYGZhy{}gpu\PYGZhy{}prog
\PYG{n+nb}{wait}
\end{sphinxVerbatim}

\sphinxAtStartPar
上面\sphinxhyphen{}p GPU\sphinxhyphen{}V100指定采用GPU队列GPU\sphinxhyphen{}V100，\sphinxhyphen{}\sphinxhyphen{}gres=gpu:v100:2指明每个节点使用2块NVIDIA V100 GPU卡。


\subsection{作业获取的节点名及对应CPU核数解析}
\label{\detokenize{slurm/slurm:cpu}}
\sphinxAtStartPar
作业调度系统主要负责分配节点及该节点分配的CPU核数等，在Slurm作业脚本中利用环境变量可以获取分配到的节点名(\sphinxcode{\sphinxupquote{SLURM\_JOB\_NODELIST}}及对应核数(\sphinxcode{\sphinxupquote{SLURM\_JOB\_CPUS\_PER\_NODE}})或对应的任务数(\sphinxcode{\sphinxupquote{SLURM\_TASKS\_PER\_NODE}})，然后根据自己程序原始的命令在Slurm脚本中进行修改就成。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NODELIST}}及\sphinxcode{\sphinxupquote{SLURM\_TASKS\_PER\_NODE}}有一定的格式，以下为一个参考解析脚本，可以在自己的Slurm脚本中参考获取自己的节点等信息。

\sphinxAtStartPar
上面只是例子，要加在自己的Slurm脚本中，而不是先提交上面这个脚本获取节点名后放到slurm脚本中，其原因在于除非提交时指定节点名，否则每次提交后获取的节点名等是有可能变的。比如针对star\sphinxhyphen{}cmm+软件，原来的方式是：
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/STATCMM+PATH/bin/starccm+ \sphinxhyphen{}rsh ssh \sphinxhyphen{}batch \sphinxhyphen{}power \sphinxhyphen{}on cnode400:40,cnode432:40 FireAndSmokeResampled.sim >residual.log}}
\end{quote}

\sphinxAtStartPar
则可以改为下面脚本：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
\PYG{c+c1}{\PYGZsh{}Auther HM\PYGZus{}Li\PYGZlt{}hmli@ustc.edu.cn\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}SLURM\PYGZus{}JOB\PYGZus{}NODELIST=cnode[001\PYGZhy{}003,005,440\PYGZhy{}441]}
\PYG{n+nv}{BASENAME}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SLURM\PYGZus{}JOB\PYGZus{}NODELIST}\PYG{p}{\PYGZpc{}[*}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{LIST}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SLURM\PYGZus{}JOB\PYGZus{}NODELIST}\PYG{p}{\PYGZsh{}*[}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{LIST}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIST}\PYG{p}{\PYGZpc{}]}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{IDLIST}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
\PYG{k}{for} i \PYG{k}{in} \PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}LIST} \PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{},\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}
\PYG{k}{do}
   \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYG{n+nv}{\PYGZdl{}i} \PYG{o}{=}\PYGZti{} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZsq{}} \PYG{o}{]}\PYG{o}{]}\PYG{p}{;} \PYG{k}{then}
      \PYG{n+nv}{IDLIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}IDLIST}\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}seq \PYGZhy{}w \PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}i} \PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}\PYG{l+s+sb}{`}
   \PYG{k}{else}
      \PYG{n+nv}{IDLIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}IDLIST}\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{n+nv}{\PYGZdl{}i}
   \PYG{k}{fi}
\PYG{k}{done}
\PYG{n+nv}{NODELIST}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
\PYG{k}{for} i \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}IDLIST}
\PYG{k}{do}
    \PYG{n+nv}{NODELIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NODELIST}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{n+nv}{\PYGZdl{}BASENAME}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}i}
\PYG{k}{done}
\PYG{n+nb}{echo} \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{}Node list: \PYGZbs{}n\PYGZbs{}t\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}NODELIST}

\PYG{c+c1}{\PYGZsh{}SLURM\PYGZus{}TASKS\PYGZus{}PER\PYGZus{}NODE=\PYGZsq{}40(x3),23,20(x2)\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{}SLURM\PYGZus{}JOB\PYGZus{}CPUS\PYGZus{}PER\PYGZus{}NODE=\PYGZsq{}40(x3),23,20(x2)\PYGZsq{}}
\PYG{n+nv}{CORELIST}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
\PYG{k}{for} i \PYG{k}{in} \PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}CUPS\PYGZus{}PER\PYGZus{}NODE}\PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{},\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}
\PYG{k}{do}
  \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYG{n+nv}{\PYGZdl{}i} \PYG{o}{=}\PYGZti{} \PYG{l+s+s1}{\PYGZsq{}x\PYGZsq{}} \PYG{o}{]}\PYG{o}{]}\PYG{p}{;} \PYG{k}{then}
     \PYG{n+nb}{read} CORES NODES \PYG{o}{\PYGZlt{}\PYGZlt{}\PYGZlt{}}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}i}\PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{}(x)\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}
     \PYG{k}{for} n \PYG{k}{in} \PYG{l+s+sb}{`}seq \PYG{l+m}{1} \PYG{n+nv}{\PYGZdl{}NODES}\PYG{l+s+sb}{`}
     \PYG{k}{do}
         \PYG{n+nv}{CORELIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}CORELIST}\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{n+nv}{\PYGZdl{}CORES}
     \PYG{k}{done}
  \PYG{k}{else}
     \PYG{n+nv}{CORELIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}CORELIST}\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{n+nv}{\PYGZdl{}i}
  \PYG{k}{fi}
\PYG{k}{done}
\PYG{n+nb}{echo} \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZbs{}nCPU Core list: \PYGZbs{}n\PYGZbs{}t}\PYG{n+nv}{\PYGZdl{}CORELIST}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n+nb}{echo} \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}nNode list with corresponding CPU Cores: \PYGZdq{}}
\PYG{n+nv}{CARR}\PYG{o}{=}\PYG{o}{(}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CORELIST}\PYG{l+s+si}{\PYGZcb{}}\PYG{o}{)}
\PYG{n+nv}{i}\PYG{o}{=}\PYG{l+m}{0}
\PYG{k}{for} n \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}NODELIST}
  \PYG{k}{do}
    \PYG{n+nb}{echo} \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}t\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}n}: \PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CARR}\PYG{p}{[}\PYG{n+nv}{\PYGZdl{}i}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}
    \PYG{n+nv}{i}\PYG{o}{=}\PYG{k}{\PYGZdl{}((}\PYG{n+nv}{\PYGZdl{}i}\PYG{o}{+}\PYG{l+m}{1}\PYG{k}{))}
 \PYG{k}{done}
\end{sphinxVerbatim}


\section{分配式提交作业：salloc}
\label{\detokenize{slurm/slurm:salloc}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salloc}}将获取作业的分配后执行命令，当命令结束后释放分配的资源。其基本语法为：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salloc {[}options{]} {[}<command> {[}command args{]}{]}}}

\sphinxAtStartPar
command可以是任何是用户想要用的程序，典型的为xterm或包含\sphinxcode{\sphinxupquote{srun}}命令的shell。如果后面没有跟命令，那么将执行Slurm系统slurm.conf配置文件中通过SallocDefaultCommand设定的命令。如果SallocDefaultCommand没有设定，那么将执行用户的默认shell。

\sphinxAtStartPar
注意：\sphinxcode{\sphinxupquote{salloc}}逻辑上包括支持保存和存储终端行设置，并且设计为采用前台方式执行。如果需要后台执行\sphinxcode{\sphinxupquote{salloc}}，可以设定标准输入为某个文件，如：\sphinxcode{\sphinxupquote{salloc \sphinxhyphen{}n16 a.out </dev/null \&}}。


\subsection{作业获取的节点名及对应CPU核数解析}
\label{\detokenize{slurm/slurm:cpu-1}}\label{\detokenize{slurm/slurm:id30}}
\sphinxAtStartPar
作业调度系统主要负责分配节点及该节点分配的CPU核数等，在Slurm作业脚本中利用环境变量可以获取分配到的节点名(\sphinxcode{\sphinxupquote{SLURM\_JOB\_NODELIST}}及对应核数(\sphinxcode{\sphinxupquote{SLURM\_JOB\_CPUS\_PER\_NODE}})或对应的任务数(\sphinxcode{\sphinxupquote{SLURM\_TASKS\_PER\_NODE}})，然后根据自己程序原始的命令在Slurm脚本中进行修改就成。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NODELIST}}及\sphinxcode{\sphinxupquote{SLURM\_TASKS\_PER\_NODE}}有一定的格式，以下为一个参考解析脚本，可以在自己的Slurm脚本中参考获取自己的节点等信息。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
\PYG{c+c1}{\PYGZsh{}Auther HM\PYGZus{}Li\PYGZlt{}hmli@ustc.edu.cn\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{}SLURM\PYGZus{}JOB\PYGZus{}NODELIST=cnode[001\PYGZhy{}003,005,440\PYGZhy{}441]}
\PYG{n+nv}{BASENAME}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SLURM\PYGZus{}JOB\PYGZus{}NODELIST}\PYG{p}{\PYGZpc{}[*}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{LIST}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SLURM\PYGZus{}JOB\PYGZus{}NODELIST}\PYG{p}{\PYGZsh{}*[}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{LIST}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIST}\PYG{p}{\PYGZpc{}]}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{IDLIST}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
\PYG{k}{for} i \PYG{k}{in} \PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}LIST} \PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{},\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}
\PYG{k}{do}
  \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYG{n+nv}{\PYGZdl{}i} \PYG{o}{=}\PYGZti{} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZsq{}} \PYG{o}{]}\PYG{o}{]}\PYG{p}{;} \PYG{k}{then}
     \PYG{n+nv}{IDLIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}IDLIST}\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}seq \PYGZhy{}w \PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}i} \PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}\PYG{l+s+sb}{`}
  \PYG{k}{else}
     \PYG{n+nv}{IDLIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}IDLIST}\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{n+nv}{\PYGZdl{}i}
  \PYG{k}{fi}
\PYG{k}{done}
\PYG{n+nv}{NODELIST}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
\PYG{k}{for} i \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}IDLIST}
\PYG{k}{do}
   \PYG{n+nv}{NODELIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NODELIST}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{n+nv}{\PYGZdl{}BASENAME}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}i}
\PYG{k}{done}
\PYG{n+nb}{echo} \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{}Node list: \PYGZbs{}n\PYGZbs{}t\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}NODELIST}

\PYG{c+c1}{\PYGZsh{}SLURM\PYGZus{}TASKS\PYGZus{}PER\PYGZus{}NODE=\PYGZsq{}40(x3),23,20(x2)\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{}SLURM\PYGZus{}JOB\PYGZus{}CPUS\PYGZus{}PER\PYGZus{}NODE=\PYGZsq{}40(x3),23,20(x2)\PYGZsq{}}
\PYG{n+nv}{CORELIST}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
\PYG{k}{for} i \PYG{k}{in} \PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}CUPS\PYGZus{}PER\PYGZus{}NODE}\PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{},\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}
\PYG{k}{do}
  \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYG{n+nv}{\PYGZdl{}i} \PYG{o}{=}\PYGZti{} \PYG{l+s+s1}{\PYGZsq{}x\PYGZsq{}} \PYG{o}{]}\PYG{o}{]}\PYG{p}{;} \PYG{k}{then}
    \PYG{n+nb}{read} CORES NODES \PYG{o}{\PYGZlt{}\PYGZlt{}\PYGZlt{}}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}i} \PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{}(x)\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}
    \PYG{k}{for} n \PYG{k}{in} \PYG{l+s+sb}{`}seq \PYG{l+m}{1} \PYG{n+nv}{\PYGZdl{}NODES}\PYG{l+s+sb}{`}
    \PYG{k}{do}
       \PYG{n+nv}{CORELIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}CORELIST}\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{n+nv}{\PYGZdl{}CORES}
    \PYG{k}{done}
  \PYG{k}{else}
    \PYG{n+nv}{CORELIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}CORELIST}\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{n+nv}{\PYGZdl{}i}
  \PYG{k}{fi}
\PYG{k}{done}
\PYG{n+nb}{echo} \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZbs{}nCPU Core list: \PYGZbs{}n\PYGZbs{}t}\PYG{n+nv}{\PYGZdl{}CORELIST}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n+nb}{echo} \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}nNode list with corresponding CPU Cores: \PYGZdq{}}
\PYG{n+nv}{CARR}\PYG{o}{=}\PYG{o}{(}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CORELIST}\PYG{l+s+si}{\PYGZcb{}}\PYG{o}{)}
\PYG{n+nv}{i}\PYG{o}{=}\PYG{l+m}{0}
\PYG{k}{for} n \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}NODELIST}
\PYG{k}{do}
   \PYG{n+nb}{echo} \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}t\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}n}: \PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CARR}\PYG{p}{[}\PYG{n+nv}{\PYGZdl{}i}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}
   \PYG{n+nv}{i}\PYG{o}{=}\PYG{k}{\PYGZdl{}((}\PYG{n+nv}{\PYGZdl{}i}\PYG{o}{+}\PYG{l+m}{1}\PYG{k}{))}
\PYG{k}{done}
\end{sphinxVerbatim}

\sphinxAtStartPar
上面只是例子，要加在自己的Slurm脚本中，而不是先提交上面这个脚本获取节点名后放到slurm脚本中，其原因在于除非提交时指定节点名，否则每次提交后获取的节点名等是有可能变的。比如针对star\sphinxhyphen{}cmm+软件，原来的方式是：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/STATCMM+PATH/bin/starccm+ \sphinxhyphen{}rsh ssh \sphinxhyphen{}batch \sphinxhyphen{}power \sphinxhyphen{}on cnode400:40,cnode432:40 FireAndSmokeResampled.sim >residual.log}}

\sphinxAtStartPar
则可以改为下面脚本：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{c+c1}{\PYGZsh{}An example for MPI job.}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}J job\PYGZus{}name}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}o job\PYGZhy{}\PYGZpc{}j.log}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}e job\PYGZhy{}\PYGZpc{}j.err}
\PYG{n+nb}{echo} This job runs on the following nodes:
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}NODELIST}
\PYG{n+nb}{echo} This job has allocated \PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}CPUS\PYGZus{}PER\PYGZus{}NODE} cpu cores.

\PYG{n+nv}{BASENAME}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SLURM\PYGZus{}JOB\PYGZus{}NODELIST}\PYG{p}{\PYGZpc{}[*}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{LIST}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SLURM\PYGZus{}JOB\PYGZus{}NODELIST}\PYG{p}{\PYGZsh{}*[}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{LIST}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIST}\PYG{p}{\PYGZpc{}]}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{IDLIST}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
\PYG{k}{for} i \PYG{k}{in} \PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}LIST} \PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{},\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}
\PYG{k}{do}
  \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYG{n+nv}{\PYGZdl{}i} \PYG{o}{=}\PYGZti{} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZsq{}} \PYG{o}{]}\PYG{o}{]}\PYG{p}{;} \PYG{k}{then}
     \PYG{n+nv}{T}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}i}\PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}
     \PYG{n+nv}{IDLIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}IDLIST}\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{l+s+sb}{`}seq \PYGZhy{}w \PYG{n+nv}{\PYGZdl{}T}\PYG{l+s+sb}{`}
  \PYG{k}{else}
     \PYG{n+nv}{IDLIST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}IDLIST}\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{n+nv}{\PYGZdl{}i}
  \PYG{k}{fi}
\PYG{k}{done}
\PYG{n+nv}{NODEOPT}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
\PYG{k}{for} i \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}IDLIST}
\PYG{k}{do}
   \PYG{n+nv}{NODEOPT}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NODEOPT},\PYG{n+nv}{\PYGZdl{}BASENAME}\PYG{n+nv}{\PYGZdl{}i}:40
\PYG{k}{done}
\PYG{n+nv}{NODEOPT}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NODEOPT}\PYG{p}{:}\PYG{n+nv}{1}\PYG{l+s+si}{\PYGZcb{}} \PYG{c+c1}{\PYGZsh{}trim the first ,}

/STARCMM+PATH/bin/starccm+ \PYGZhy{}rsh ssh \PYGZhy{}batch \PYGZhy{}power \PYGZhy{}on \PYG{n+nv}{\PYGZdl{}NODEOPT} FireAndSmokeResampled.sim \PYGZgt{} residual.log
\end{sphinxVerbatim}


\subsection{主要选项}
\label{\detokenize{slurm/slurm:id31}}
\sphinxAtStartPar
常见主要选项参见{\hyperref[\detokenize{slurm/slurm:slurmoption}]{\emph{10.1}}}。


\subsection{主要输入环境变量}
\label{\detokenize{slurm/slurm:id32}}\label{\detokenize{slurm/slurm:id33}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_ACCOUNT}}：类似\sphinxhyphen{}A, \sphinxhyphen{}\sphinxhyphen{}account

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_ACCTG\_FREQ}}：类似\sphinxhyphen{}\sphinxhyphen{}acctg\sphinxhyphen{}freq

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_BELL}}：类似\sphinxhyphen{}\sphinxhyphen{}bell

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_CLUSTERS}}、\sphinxcode{\sphinxupquote{SLURM\_CLUSTERS}}：类似\sphinxhyphen{}\sphinxhyphen{}clusters。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_CONSTRAINT}}：类似\sphinxhyphen{}C, \sphinxhyphen{}\sphinxhyphen{}constraint。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_CORE\_SPEC}}：类似 \sphinxhyphen{}\sphinxhyphen{}core\sphinxhyphen{}spec。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_CPUS\_PER\_GPU}}：类似 \sphinxhyphen{}\sphinxhyphen{}cpus\sphinxhyphen{}per\sphinxhyphen{}gpu。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_DEBUG}}：类似\sphinxhyphen{}v, \sphinxhyphen{}\sphinxhyphen{}verbose。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_EXCLUSIVE}}：类似\sphinxhyphen{}\sphinxhyphen{}exclusive。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_GEOMETRY}}：类似\sphinxhyphen{}g, \sphinxhyphen{}\sphinxhyphen{}geometry。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_GPUS}}：类似 \sphinxhyphen{}G, \sphinxhyphen{}\sphinxhyphen{}gpus。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_GPU\_BIND}}：类似 \sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}bind。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_GPU\_FREQ}}：类似 \sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}freq。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_GPUS\_PER\_NODE}}：类似 \sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}node。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_GPUS\_PER\_TASK}}：类似 \sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}task。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_GRES}}：类似 \sphinxhyphen{}\sphinxhyphen{}gres。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_GRES\_FLAGS}}：类似\sphinxhyphen{}\sphinxhyphen{}gres\sphinxhyphen{}flags。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_HINT}}、\sphinxcode{\sphinxupquote{SLURM\_HINT}}：类似\sphinxhyphen{}\sphinxhyphen{}hint。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_IMMEDIATE}}：类似\sphinxhyphen{}I, \sphinxhyphen{}\sphinxhyphen{}immediate。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_KILL\_CMD}}：类似\sphinxhyphen{}K, \sphinxhyphen{}\sphinxhyphen{}kill\sphinxhyphen{}command。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_MEM\_BIND}}：类似\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_MEM\_PER\_CPU}}：类似 \sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}cpu。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_MEM\_PER\_GPU}}：类似 \sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}gpu

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_MEM\_PER\_NODE}}：类似 \sphinxhyphen{}\sphinxhyphen{}mem。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_NETWORK}}：类似\sphinxhyphen{}\sphinxhyphen{}network。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_NO\_BELL}}：类似\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}bell。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_OVERCOMMIT}}：类似\sphinxhyphen{}O, \sphinxhyphen{}\sphinxhyphen{}overcommit。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_PARTITION}}：类似\sphinxhyphen{}p, \sphinxhyphen{}\sphinxhyphen{}partition。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_PROFILE}}：类似\sphinxhyphen{}\sphinxhyphen{}profile。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_QOS}}：类似\sphinxhyphen{}\sphinxhyphen{}qos。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_RESERVATION}}：类似\sphinxhyphen{}\sphinxhyphen{}reservation。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_SIGNAL}}：类似\sphinxhyphen{}\sphinxhyphen{}signal。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_SPREAD\_JOB}}：类似\sphinxhyphen{}\sphinxhyphen{}spread\sphinxhyphen{}job。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_THREAD\_SPEC}}：类似\sphinxhyphen{}\sphinxhyphen{}thread\sphinxhyphen{}spec。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_TIMELIMIT}}：类似\sphinxhyphen{}t, \sphinxhyphen{}\sphinxhyphen{}time。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_USE\_MIN\_NODES}}：类似\sphinxhyphen{}\sphinxhyphen{}use\sphinxhyphen{}min\sphinxhyphen{}nodes。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SALLOC\_WAIT\_ALL\_NODES}}：类似\sphinxhyphen{}\sphinxhyphen{}wait\sphinxhyphen{}all\sphinxhyphen{}nodes。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_EXIT\_ERROR}}：错误退出代码。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_EXIT\_IMMEDIATE}}：当\sphinxhyphen{}\sphinxhyphen{}immediate选项时指定的立即退出代码。

\end{itemize}


\subsection{主要输出环境变量}
\label{\detokenize{slurm/slurm:id34}}\label{\detokenize{slurm/slurm:id35}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CLUSTER\_NAME}}：集群名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPUS\_PER\_GPU}}：每颗GPU分配的CPU数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_CPUS\_PER\_TASK}}：每个任务分配的CPU数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_DISTRIBUTION}}：类似\sphinxhyphen{}m, \sphinxhyphen{}\sphinxhyphen{}distribution。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS}}：需要的GPU颗数，仅提交时有\sphinxhyphen{}G, \sphinxhyphen{}\sphinxhyphen{}gpus时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPU\_BIND}}：指定绑定任务到GPU，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}bind参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPU\_FREQ}}：需求的GPU频率，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpu\sphinxhyphen{}freq参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_NODE}}：需要的每个节点的GPU颗数，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}node参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_SOCKET}}：需要的每个socket的GPU颗数，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}socket参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_GPUS\_PER\_TASK}}：需要的每个任务的GPU颗数，仅提交时具有\sphinxhyphen{}\sphinxhyphen{}gpus\sphinxhyphen{}per\sphinxhyphen{}task参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_ACCOUNT}}：账户名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_ID}}（\sphinxcode{\sphinxupquote{SLURM\_JOBID}}为向后兼容）：作业号。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_CPUS\_PER\_NODE}}：分配的每个节点CPU数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NODELIST}}（\sphinxcode{\sphinxupquote{SLURM\_NODELIST}}为向后兼容）：分配的节点名列表。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_NUM\_NODES}}（\sphinxcode{\sphinxupquote{SLURM\_NNODES}}为向后兼容）：作业分配的节点数。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_PARTITION}}：作业使用的队列名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_QOS}}：作业的QOS。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_JOB\_RESERVATION}}：预留的作业资源。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_BIND}}：\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind选项设定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_BIND\_VERBOSE}}：如\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind选项包含verbose选项时，则由其设定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_BIND\_LIST}}：内存绑定时设定的bit掩码。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_BIND\_PREFER}}：\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bin prefer优先权。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_BIND\_TYPE}}：由\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}bind选项设定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_PER\_CPU}}：类似\sphinxhyphen{}\sphinxhyphen{}mem。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_PER\_GPU}}：每颗GPU需要的内存，仅提交时有\sphinxhyphen{}\sphinxhyphen{}mem\sphinxhyphen{}per\sphinxhyphen{}gpu参数时。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_MEM\_PER\_NODE}}：类似\sphinxhyphen{}\sphinxhyphen{}mem。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_SUBMIT\_DIR}}：运行\sphinxcode{\sphinxupquote{salloc}}时的目录，或提交时由\sphinxhyphen{}D, \sphinxhyphen{}\sphinxhyphen{}chdir参数指定。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_SUBMIT\_HOST}}：运行salloc时的节点名。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NODE\_ALIASES}}：分配的节点名、通信地址和主机名，格式类似 \sphinxcode{\sphinxupquote{SLURM\_NODE\_ALIASES}}=ec0:1.2.3.4:foo,ec1:1.2.3.5:bar。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS}}：类似\sphinxhyphen{}n, \sphinxhyphen{}\sphinxhyphen{}ntasks。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS\_PER\_CORE}}：\sphinxhyphen{}\sphinxhyphen{}ntasks\sphinxhyphen{}per\sphinxhyphen{}core选项设定的值。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS\_PER\_NODE}}：\sphinxhyphen{}\sphinxhyphen{}ntasks\sphinxhyphen{}per\sphinxhyphen{}node选项设定的值。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_NTASKS\_PER\_SOCKET}}：\sphinxhyphen{}\sphinxhyphen{}ntasks\sphinxhyphen{}per\sphinxhyphen{}socket选项设定的值。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_PROFILE}}：类似\sphinxhyphen{}\sphinxhyphen{}profile。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SLURM\_TASKS\_PER\_NODE}}：每个节点的任务数。值以,分隔，并与\sphinxcode{\sphinxupquote{SLURM\_NODELIST}} 顺序一致。如果连续的节点有相同的任务数，那么数后面跟有“(x\#)”，其中“\#”是重复次数。如： \sphinxcode{\sphinxupquote{SLURM\_TASKS\_PER\_NODE =2(x3),1}} 。

\end{itemize}


\subsection{例子}
\label{\detokenize{slurm/slurm:id36}}\begin{itemize}
\item {} 
\sphinxAtStartPar
获取分配，并打开csh，以便srun可以交互式输入：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salloc \sphinxhyphen{}N16 csh}}

\sphinxAtStartPar
将输出：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
salloc: Granted job allocation 65537
（在此，将等待用户输入，csh退出后结束） salloc: Relinquishing job
allocation 65537
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
获取分配并并行运行应用：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salloc \sphinxhyphen{}N5 srun \sphinxhyphen{}n10 myprogram}}

\item {} 
\sphinxAtStartPar
生成三个不同组件的异构作业，每个都是独立节点：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salloc \sphinxhyphen{}w node{[}2\sphinxhyphen{}3{]} : \sphinxhyphen{}w node4 : \sphinxhyphen{}w node{[}5\sphinxhyphen{}7{]} bash}}

\sphinxAtStartPar
将输出：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{salloc}\PYG{p}{:} \PYG{n}{job} \PYG{l+m+mi}{32294} \PYG{n}{queued} \PYG{o+ow}{and} \PYG{n}{waiting} \PYG{k}{for} \PYG{n}{resources} \PYG{n}{salloc}\PYG{p}{:} \PYG{n}{job} \PYG{l+m+mi}{32294}
\PYG{n}{has} \PYG{n}{been} \PYG{n}{allocated} \PYG{n}{resources} \PYG{n}{salloc}\PYG{p}{:} \PYG{n}{Granted} \PYG{n}{job} \PYG{n}{allocation} \PYG{l+m+mi}{32294}
\end{sphinxVerbatim}


\section{将文件同步到各节点：sbcast}
\label{\detokenize{slurm/slurm:sbcast}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sbcast}}命令可以将文件同步到各计算节点对应目录。

\sphinxAtStartPar
当前，用户主目录是共享的，一般不需要此命令，如果用户需要将某些文件传递到分配给作业的各节点\sphinxcode{\sphinxupquote{/tmp}}等非共享目录，那么可以考虑此命令。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sbcast}}命令的基本语法为：\sphinxcode{\sphinxupquote{sbcast {[}\sphinxhyphen{}CfFjpstvV{]} SOURCE DEST}}。

\sphinxAtStartPar
此命令仅对批处理作业或在Slurm资源分配后生成的shell中起作用。SOURCE是当前节点上文件名，DEST为分配给此作业的对应节点将要复制到文件全路径。


\subsection{主要参数}
\label{\detokenize{slurm/slurm:id37}}\label{\detokenize{slurm/slurm:id38}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}C {[}library{]},
\sphinxhyphen{}\sphinxhyphen{}compress{[}=library{]}：设定采用压缩传递，及其使用的压缩库，{[}library{]}可以为lz4（默认）、zlib。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}f, \sphinxhyphen{}\sphinxhyphen{}force：强制模式，如果目标文件存在，那么将直接覆盖。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}F number,
\sphinxhyphen{}\sphinxhyphen{}fanout=number：设定用于文件传递时的消息扇出，当前最大值为8。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}j jobID{[}.stepID{]}, \sphinxhyphen{}\sphinxhyphen{}jobid=jobID{[}.stepID{]}：指定使用的作业号。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}p, \sphinxhyphen{}\sphinxhyphen{}preserve：保留源文件的修改时间、访问时间和模式等。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}s size,
\sphinxhyphen{}\sphinxhyphen{}size=size：设定广播时使用的块大小。size可以具有k或m后缀，默认单位为比特。默认大小为文件大小或8MB。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}t seconds, fB\sphinxhyphen{}\sphinxhyphen{}timeout=seconds：设定消息的超时时间。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}v, \sphinxhyphen{}\sphinxhyphen{}verbose：显示冗余信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}V, \sphinxhyphen{}\sphinxhyphen{}version：显示版本信息。

\end{itemize}


\subsection{主要环境变量}
\label{\detokenize{slurm/slurm:id39}}\begin{itemize}
\item {} 
\sphinxAtStartPar
SBCAST\_COMPRESS：类似\sphinxhyphen{}C, \sphinxhyphen{}\sphinxhyphen{}compress。

\item {} 
\sphinxAtStartPar
SBCAST\_FANOUT：类似\sphinxhyphen{}F number, fB\sphinxhyphen{}\sphinxhyphen{}fanout=number。

\item {} 
\sphinxAtStartPar
SBCAST\_FORCE：类似\sphinxhyphen{}f, \sphinxhyphen{}\sphinxhyphen{}force。

\item {} 
\sphinxAtStartPar
SBCAST\_PRESERVE：类似\sphinxhyphen{}p, \sphinxhyphen{}\sphinxhyphen{}preserve。

\item {} 
\sphinxAtStartPar
SBCAST\_SIZE：类似\sphinxhyphen{}s size, \sphinxhyphen{}\sphinxhyphen{}size=size。

\item {} 
\sphinxAtStartPar
SBCAST\_TIMEOUT：类似\sphinxhyphen{}t seconds, fB\sphinxhyphen{}\sphinxhyphen{}timeout=seconds。

\end{itemize}


\subsection{例子}
\label{\detokenize{slurm/slurm:id40}}\label{\detokenize{slurm/slurm:id41}}
\sphinxAtStartPar
将\sphinxcode{\sphinxupquote{my.prog}}传到\sphinxcode{\sphinxupquote{/tmp/my.proc}}，且执行：
\begin{itemize}
\item {} 
\sphinxAtStartPar
生成脚本\sphinxcode{\sphinxupquote{my.job}}：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
sbcast my.prog /tmp/my.prog
srun /tmp/my.prog
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
提交：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sbatch \sphinxhyphen{}\sphinxhyphen{}nodes=8 my.job}}

\end{itemize}


\section{吸附到作业步：sattach}
\label{\detokenize{slurm/slurm:sattach}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sattach}}可以吸附到一个运行中的Slurm作业步，通过吸附，可以获取所有任务的IO流等，有时也可用于并行调试器。

\sphinxAtStartPar
基本语法：\sphinxcode{\sphinxupquote{sattach {[}options{]} <jobid.stepid>}}


\subsection{主要参数}
\label{\detokenize{slurm/slurm:id42}}\label{\detokenize{slurm/slurm:id43}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}h, \sphinxhyphen{}\sphinxhyphen{}help：显示帮助信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}input\sphinxhyphen{}filter{[}={]}<task number>、 \sphinxhyphen{}\sphinxhyphen{}output\sphinxhyphen{}filter{[}={]}<task number>、\sphinxhyphen{}\sphinxhyphen{}error\sphinxhyphen{}filter{[}={]}<task number>：仅传递标准输入到一个单独任务或打印一个单个任务中的标准输出或标准错误输出。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}l, \sphinxhyphen{}\sphinxhyphen{}label：在每行前显示其对应的任务号。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}layout：联系slurmctld获得任务层信息，打印层信息后退出吸附作业步。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}pty：在伪终端上执行0号任务。与\sphinxhyphen{}\sphinxhyphen{}input\sphinxhyphen{}filter、\sphinxhyphen{}\sphinxhyphen{}output\sphinxhyphen{}filter或\sphinxhyphen{}\sphinxhyphen{}error\sphinxhyphen{}filter不兼容。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}Q, \sphinxhyphen{}\sphinxhyphen{}quiet：安静模式。不显示一般的sattach信息，但错误信息仍旧显示。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}u, \sphinxhyphen{}\sphinxhyphen{}usage：显示简要帮助信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}V, \sphinxhyphen{}\sphinxhyphen{}version：显示版本信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}v, \sphinxhyphen{}\sphinxhyphen{}verbose：显示冗余信息。

\end{itemize}


\subsection{主要输入环境变量}
\label{\detokenize{slurm/slurm:id44}}\label{\detokenize{slurm/slurm:id45}}\begin{itemize}
\item {} 
\sphinxAtStartPar
SLURM\_CONF：Slurm配置文件。

\item {} 
\sphinxAtStartPar
SLURM\_EXIT\_ERROR：Slurm退出错误代码。

\end{itemize}


\subsection{例子}
\label{\detokenize{slurm/slurm:id46}}\label{\detokenize{slurm/slurm:id47}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sattach 15.0}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sattach \sphinxhyphen{}\{\}\sphinxhyphen{}output\sphinxhyphen{}filter 5 65386.15}}

\end{itemize}


\section{查看记账信息：sacct}
\label{\detokenize{slurm/slurm:sacct}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sacct}}显示激活的或已完成作业或作业步的记账（与机时费对应）信息。

\sphinxAtStartPar
主要参数：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}b, \sphinxhyphen{}\sphinxhyphen{}brief：显示简要信息，主要包含：作业号jobid、状态status和退出码exitcode。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}c, \sphinxhyphen{}\sphinxhyphen{}completion：显示作业完成信息而非记账信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}e, \sphinxhyphen{}\sphinxhyphen{}helpformat：显示当采用 \sphinxhyphen{}\sphinxhyphen{}format指定格式化输出的可用格式。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}E end\_time, \sphinxhyphen{}\sphinxhyphen{}endtime=end\_time：显示在end\_time时间之前（不限作业状态）的作业。有效时间格式：
\begin{itemize}
\item {} 
\sphinxAtStartPar
HH:MM{[}:SS{]} {[}AM|PM{]}

\item {} 
\sphinxAtStartPar
MMDD{[}YY{]} or MM/DD{[}/YY{]} or MM.DD{[}.YY{]}

\item {} 
\sphinxAtStartPar
MM/DD{[}/YY{]}\sphinxhyphen{}HH:MM{[}:SS{]}

\item {} 
\sphinxAtStartPar
YYYY\sphinxhyphen{}MM\sphinxhyphen{}DD{[}THH:MM{[}:SS{]}{]}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}i, \sphinxhyphen{}\sphinxhyphen{}nnodes=N：显示在特定节点数上运行的作业(N = min{[}\sphinxhyphen{}max){]}。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}j job(.step), \sphinxhyphen{}\sphinxhyphen{}jobs=job(.step)：限制特定作业号（步）的信息，作业号（步）可以以,分隔。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}l, \sphinxhyphen{}\sphinxhyphen{}long：显示详细信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}n, \sphinxhyphen{}\sphinxhyphen{}noheader：不显示信息头（显示出的信息的第一行，表示个列含义）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}N node\_list, \sphinxhyphen{}\sphinxhyphen{}nodelist=node\_list：显示运行在特定节点的作业记账信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}\sphinxhyphen{}name=jobname\_list：显示特定作业名的作业记账信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}o, \sphinxhyphen{}\sphinxhyphen{}format：以特定格式显示作业记账信息，格式间采用,分隔，利用\sphinxhyphen{}e, \sphinxhyphen{}\sphinxhyphen{}helpformat可以查看可用的格式。各项格式中\%NUMBER可以限定格式占用的字符数，比如format=name\%30，显示name列最多30个字符，如数字前有\sphinxhyphen{}则该列左对齐（默认时右对齐）。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}r, \sphinxhyphen{}\sphinxhyphen{}partition：显示特定队列的作业记账信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}R reason\_list, \sphinxhyphen{}\sphinxhyphen{}reason=reason\_list：显示由于reason\_list（以,分隔）原因没有被调度的作业记账信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}s state\_list, \sphinxhyphen{}\sphinxhyphen{}state=state\_list：显示state\_list（以,分隔）状态的作业记账信息。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}S, \sphinxhyphen{}\sphinxhyphen{}starttime：显示特定时间之后开始运行的作业记账信息，有效时间格式参见前面\sphinxhyphen{}E参数。

\end{itemize}


\section{其它常用作业管理命令}
\label{\detokenize{slurm/slurm:id48}}

\subsection{终止作业：scancel job\_id}
\label{\detokenize{slurm/slurm:scancel-job-id}}
\sphinxAtStartPar
如果想终止一个作业，可利用\sphinxcode{\sphinxupquote{scancel job\_id}}来取消，job\_list可以为以,分隔的作业ID，如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmli@login01:\textasciitilde{}\$ scancel 7}}


\subsection{挂起排队中尚未运行的作业：scontrol hold job\_list}
\label{\detokenize{slurm/slurm:scontrol-hold-job-list}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scontrol hold job\_list}}（job\_list可以为以,分隔的作业ID或jobname=作业名）命令可使得排队中尚未运行的作业（设置优先级为0）暂停被分配运行，被挂起的作业将不被执行，这样可以让其余作业优先得到资源运行。被挂起的作业在用\sphinxcode{\sphinxupquote{squeue}}命令查询显示的时NODELIST(REASON)状态标志为JobHeldUser（被用户自己挂起）或JobHeldAdmin（被系统管理员挂起），利用\sphinxcode{\sphinxupquote{scontrol release job\_list}}可取消挂起。下面命令将挂起作业号为7的作业：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmli@login01:\textasciitilde{}/work\$ scontrol hold 7}}


\subsection{继续排队被挂起的尚未运行作业：scontrol release job\_list}
\label{\detokenize{slurm/slurm:scontrol-release-job-list}}
\sphinxAtStartPar
被挂起的作业可以利用\sphinxcode{\sphinxupquote{scontrol release job\_list}}来取消挂起，重新进入等待运行状态，job\_list可以为以,分隔的作业ID或jobname=作业名。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmli@login01:\textasciitilde{}/work\$ scontrol release 7}}


\subsection{重新运行作业：scontrol requeue job\_list}
\label{\detokenize{slurm/slurm:scontrol-requeue-job-list}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{scontrol requeue job\_list}}重新使得运行中的、挂起的或停止的作业重新进入排队等待运行，job\_list可以为以,分隔的作业ID。
\sphinxcode{\sphinxupquote{hmli@login01:\textasciitilde{}/work\$ scontrol requeue 7}}


\subsection{重新挂起作业：scontrol requeuehold job\_list}
\label{\detokenize{slurm/slurm:scontrol-requeuehold-job-list}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{scontrol requeuehold job\_list}}重新使得运行中的、挂起的或停止的作业重新进入排队，并被挂起等待运行，job\_list可以为以,分隔的作业ID。之后可利用\sphinxcode{\sphinxupquote{scontrol release job\_list}}使其运行。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmli@login01:\textasciitilde{}/work\$ scontrol requeuehold 7}}


\subsection{最优先等待运行作业：scontrol top job\_id}
\label{\detokenize{slurm/slurm:scontrol-top-job-id}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{scontrol top job\_list}}可以使得尚未开始运行的job\_list作业排到用户自己排队作业的最前面，最优先运行，job\_list可以为以,分隔的作业ID。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmli@login01:\textasciitilde{}/work\$ scontrol top 7}}


\subsection{等待某个作业运行完：scontrol wait\_job job\_id}
\label{\detokenize{slurm/slurm:scontrol-wait-job-job-id}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{scontrol wait\_job job\_id}}可以等待某个job\_id结束后开始运行，一般用于脚本中。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmli@login01:\textasciitilde{}/work\$ scontrol wait\_job 7}}


\subsection{更新作业信息：scontrol update SPECIFICATION}
\label{\detokenize{slurm/slurm:scontrol-update-specification}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{scontrol update SPECIFICATION}}可以更新作业、作业步等信息，SPECIFICATION格式为\sphinxcode{\sphinxupquote{scontaol show job}}显示出的，如下面命令将更新作业号为7的作业名为NewJobName：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scontrol update JobId=7 JobName=NewJobName}}

\sphinxstepscope


\chapter{LSF作业调度系统}
\label{\detokenize{lsf/lsf:lsf}}\label{\detokenize{lsf/lsf::doc}}
\sphinxAtStartPar
曙光TC4600百万亿次超级计算系统利用IBM Spectrum LSF 10.1.0进行资源和作业调度管理，所有需要运行的作业均必须通过作业提交命令\sphinxcode{\sphinxupquote{bsub}}提交，提交后可利用相关命令查询作业状态等。为了利用\sphinxcode{\sphinxupquote{bsub}}提交作业，需要在\sphinxcode{\sphinxupquote{bsub}}中指定各选项和需要执行的程序。注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
不要在登录节点(tc4600)上不通过作业调度管理系统直接运行作业（编译等日常操作除外），以免影响其余用户的正常使用。

\item {} 
\sphinxAtStartPar
如果不通过作业调度管理系统直接在计算节点上运行将会被监护进程直接杀掉。

\end{itemize}


\section{作业运行的条件}
\label{\detokenize{lsf/lsf:id1}}
\sphinxAtStartPar
作业提交后需要一段时间等待作业调度系统调度运行，一般为先提交的先运行，并且作业运行需要满足多个基本条件：
\begin{itemize}
\item {} 
\sphinxAtStartPar
系统有空闲资源，满足程序运行需要。可以利用\sphinxcode{\sphinxupquote{bhosts}}命令查看，ok状态的才可以接受作业运行。

\item {} 
\sphinxAtStartPar
用户作业没有超过系统设置的允许用户运行的作业数，可以利用\sphinxcode{\sphinxupquote{busers}}命令查看。

\item {} 
\sphinxAtStartPar
用户作业没有超过所使用的作业队列的允许作业核数的限制，可以利用\sphinxcode{\sphinxupquote{bqueues}}命令查看。

\item {} 
\sphinxAtStartPar
用户作业没有被挂起等。利用\sphinxcode{\sphinxupquote{bjobs}}命令查看。

\item {} 
\sphinxAtStartPar
作业调度管理系统工作正常。

\end{itemize}

\sphinxAtStartPar
当系统作业繁忙时，如果提交需要核数很多的作业，也许需要长时间才可以运行甚至根本无法获取到足够资源来运行，请考虑选择合适的并行规模。

\sphinxAtStartPar
作业如不运行，请先请运行\sphinxcode{\sphinxupquote{bjobs \sphinxhyphen{}l JobID}}或\sphinxcode{\sphinxupquote{bjobs \sphinxhyphen{}p JobID}}查看输出信息中PENDING
REASONS部分及提交时设置的参数等，并结合运行上述几个命令查看原因。

\sphinxAtStartPar
如果上述条件都符合，也许作业调度管理系统存在问题，请与超算中心工作人员联系处理。


\section{查看队列情况：bqueues}
\label{\detokenize{lsf/lsf:bqueues}}
\sphinxAtStartPar
用户在使用时，首先需要了解哪些队列可以使用，利用\sphinxcode{\sphinxupquote{bqueues}}可以查看现有队列信息。

\sphinxAtStartPar
具体队列会根据需要更改，请注意登录系统后的提示，或运行\sphinxcode{\sphinxupquote{bqueues \sphinxhyphen{}l}}查看。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bqueues}}

\sphinxAtStartPar
将输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QUEUE\PYGZus{}NAME} \PYG{n}{PRIO} \PYG{n}{STATUS}       \PYG{n}{MAX}  \PYG{n}{JL}\PYG{o}{/}\PYG{n}{U}  \PYG{n}{JL}\PYG{o}{/}\PYG{n}{P} \PYG{n}{JL}\PYG{o}{/}\PYG{n}{H} \PYG{n}{NJOBS}  \PYG{n}{PEND}   \PYG{n}{RUN}  \PYG{n}{SUSP}
\PYG{n}{long}        \PYG{l+m+mi}{59}  \PYG{n}{Open}\PYG{p}{:}\PYG{n}{Active}  \PYG{l+m+mi}{1200} \PYG{l+m+mi}{1200}    \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}
\PYG{n}{normal}      \PYG{l+m+mi}{58}  \PYG{n}{Open}\PYG{p}{:}\PYG{n}{Inact}   \PYG{l+m+mi}{1440}  \PYG{l+m+mi}{192}    \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}   \PYG{l+m+mi}{360}     \PYG{l+m+mi}{0}   \PYG{l+m+mi}{360}     \PYG{l+m+mi}{0}
\PYG{n}{small}       \PYG{l+m+mi}{57}  \PYG{n}{Closed}\PYG{p}{:}\PYG{n}{Active} \PYG{l+m+mi}{720}  \PYG{l+m+mi}{120}    \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}  \PYG{l+m+mi}{1976}  \PYG{l+m+mi}{1476}   \PYG{l+m+mi}{500}     \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
其中，主要列的含义为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
QUEUE\_NAME：队列名

\item {} 
\sphinxAtStartPar
PRIO：优先级，数字越大优先级越高

\item {} 
\sphinxAtStartPar
STATUS：状态
\begin{itemize}
\item {} 
\sphinxAtStartPar
Open：队列开放，可以接受提交新作业

\item {} 
\sphinxAtStartPar
Active：队列已激活，队列中未开始运行的作业可以开始运行

\item {} 
\sphinxAtStartPar
Closed：队列已关闭，不接受提交新作业

\item {} 
\sphinxAtStartPar
Inact：队列未激活，可接受提交新作业，但队列中的等待运行的作业不会开始运行

\end{itemize}

\item {} 
\sphinxAtStartPar
MAX：队列对应的最大作业槽数（Job
Slot，一般与CPU核数一致，以下通称CPU核数），\sphinxhyphen{}表示无限

\item {} 
\sphinxAtStartPar
JL/U：单个用户同时可以使用的CPU核数

\item {} 
\sphinxAtStartPar
JL/P：每个处理器可以接受的CPU核数

\item {} 
\sphinxAtStartPar
JL/H：每个节点可以接受的CPU核数

\item {} 
\sphinxAtStartPar
NJOBS：排队、运行和被挂起的总作业所占CPU核数

\item {} 
\sphinxAtStartPar
PEND：排队中的作业所需CPU核数

\item {} 
\sphinxAtStartPar
RUN：运行中的作业所占CPU核数

\item {} 
\sphinxAtStartPar
SUSP：被挂起的作业所占CPU核数

\item {} 
\sphinxAtStartPar
RSV：为排队作业预留的CPU核数

\end{itemize}


\subsection{查看队列详细情况：bqueues \sphinxhyphen{}l}
\label{\detokenize{lsf/lsf:bqueues-l}}
\sphinxAtStartPar
队列策略也许会调整，利用\sphinxcode{\sphinxupquote{bqueues \sphinxhyphen{}l {[}队列名{]}}}查看各队列的详细情况：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QUEUE}\PYG{p}{:} \PYG{n}{small}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Maximum} \PYG{n}{number} \PYG{n}{of} \PYG{n}{job} \PYG{n}{slots} \PYG{n}{that} \PYG{n}{each} \PYG{n}{user} \PYG{n}{can} \PYG{n}{use} \PYG{o+ow}{in} \PYG{n}{this} \PYG{n}{queue} \PYG{o+ow}{is} \PYG{l+m+mf}{720.}
 \PYG{n}{on} \PYG{n}{nodes}\PYG{p}{:} \PYG{n}{node1}\PYG{o}{\PYGZti{}}\PYG{n}{node67}

\PYG{n}{PARAMETERS}\PYG{o}{/}\PYG{n}{STATISTICS}
\PYG{n}{PRIO} \PYG{n}{NICE} \PYG{n}{STATUS}          \PYG{n}{MAX} \PYG{n}{JL}\PYG{o}{/}\PYG{n}{U} \PYG{n}{JL}\PYG{o}{/}\PYG{n}{P} \PYG{n}{JL}\PYG{o}{/}\PYG{n}{H} \PYG{n}{NJOBS}  \PYG{n}{PEND}   \PYG{n}{RUN} \PYG{n}{SSUSP} \PYG{n}{USUSP}  \PYG{n}{RSV}
 \PYG{l+m+mi}{57}   \PYG{l+m+mi}{20}  \PYG{n}{Open}\PYG{p}{:}\PYG{n}{Active}     \PYG{l+m+mi}{720}  \PYG{l+m+mi}{120}    \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}  \PYG{l+m+mi}{1964}  \PYG{l+m+mi}{1464}   \PYG{l+m+mi}{500}     \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{0}
\PYG{n}{Interval} \PYG{k}{for} \PYG{n}{a} \PYG{n}{host} \PYG{n}{to} \PYG{n}{accept} \PYG{n}{two} \PYG{n}{jobs} \PYG{o+ow}{is} \PYG{l+m+mi}{0} \PYG{n}{seconds}

 \PYG{n}{PROCLIMIT}
 \PYG{l+m+mi}{48}

\PYG{n}{SCHEDULING} \PYG{n}{PARAMETERS}
           \PYG{n}{r15s}   \PYG{n}{r1m}  \PYG{n}{r15m}   \PYG{n}{ut}      \PYG{n}{pg}    \PYG{n}{io}   \PYG{n}{ls}    \PYG{n}{it}    \PYG{n}{tmp}    \PYG{n}{swp}    \PYG{n}{mem}
 \PYG{n}{loadSched}   \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}       \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}      \PYG{o}{\PYGZhy{}}      \PYG{o}{\PYGZhy{}}
 \PYG{n}{loadStop}    \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}       \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}      \PYG{o}{\PYGZhy{}}      \PYG{o}{\PYGZhy{}}

          \PYG{n}{adapter\PYGZus{}windows}     \PYG{n}{poe} \PYG{n}{nrt\PYGZus{}windows}
 \PYG{n}{loadSched}             \PYG{o}{\PYGZhy{}}       \PYG{o}{\PYGZhy{}}           \PYG{o}{\PYGZhy{}}
 \PYG{n}{loadStop}              \PYG{o}{\PYGZhy{}}       \PYG{o}{\PYGZhy{}}           \PYG{o}{\PYGZhy{}}

\PYG{n}{SCHEDULING} \PYG{n}{POLICIES}\PYG{p}{:}  \PYG{n}{EXCLUSIVE}

\PYG{n}{USERS}\PYG{p}{:} \PYG{n}{paiduigroup}\PYG{o}{/} \PYG{n}{scc\PYGZus{}group}\PYG{o}{/}
\PYG{n}{HOSTS}\PYG{p}{:}  \PYG{n}{node1} \PYG{n}{node2} \PYG{n}{node3} \PYG{n}{node4} \PYG{n}{node5} \PYG{n}{node6} \PYG{n}{node7} \PYG{n}{node8} \PYG{n}{node9} \PYG{n}{node10} \PYG{n}{node11} \PYG{n}{node12}
\PYG{n}{RES\PYGZus{}REQ}\PYG{p}{:}  \PYG{n}{span}\PYG{p}{[}\PYG{n}{ptile}\PYG{o}{=}\PYG{l+m+mi}{24}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
QUEUE：队列名，跟着的下一行是描述

\item {} 
\sphinxAtStartPar
PRIO：优先值，越大越优先

\item {} 
\sphinxAtStartPar
NICE：作业运行时的nice值，即作业运行时的操作系统调度优先值，从\sphinxhyphen{}20到19，越小越优先

\item {} 
\sphinxAtStartPar
RUNLIMIT：作业单CPU运行时间限制，以系统中的某个节点为基准，如为1440.0 min则表示可以运行一天（60*24）

\item {} 
\sphinxAtStartPar
CPULIMIT：单个作业运行时间限制，以系统中的某个节点E5410作为参考，运行机时（核数*墙上时间）为345600.0 CPU分钟，即如用8 CPU核计算，允许运行30天

\item {} 
\sphinxAtStartPar
PROCLIMIT：单个作业核数限制，\sphinxcode{\sphinxupquote{2 4 8}}，表示使用此队列时，最少使用2个核，最多使用8核，如提交时没用\sphinxhyphen{}n指定具体核数，则使用默认4核

\item {} 
\sphinxAtStartPar
PROCESSLIMIT：单个作业最大核数限制，为8

\item {} 
\sphinxAtStartPar
MEMLIMIT：每个进程能使用的内存数，默认以KB为单位

\item {} 
\sphinxAtStartPar
THREADLIMIT：作业最大线程数

\item {} 
\sphinxAtStartPar
USERS：有权使用的用户

\item {} 
\sphinxAtStartPar
HOSTS：对应的节点

\end{itemize}


\section{查看各节点的运行情况：lsload}
\label{\detokenize{lsf/lsf:lsload}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{lsload}}命令可查看当前各节点的运行情况，例如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lsload}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HOST\PYGZus{}NAME}     \PYG{n}{status}  \PYG{n}{r15s}   \PYG{n}{r1m}  \PYG{n}{r15m}    \PYG{n}{ut}   \PYG{n}{pg}   \PYG{n}{ls}  \PYG{n}{it}   \PYG{n}{tmp}   \PYG{n}{swp}   \PYG{n}{mem}
\PYG{n}{node1}         \PYG{n}{ok}       \PYG{l+m+mf}{0.0}   \PYG{l+m+mf}{0.0}   \PYG{l+m+mf}{0.0}   \PYG{l+m+mi}{0}\PYG{o}{\PYGZpc{}}   \PYG{l+m+mf}{0.5}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{25}  \PYG{l+m+mi}{227}\PYG{n}{G}   \PYG{l+m+mi}{32}\PYG{n}{G}   \PYG{l+m+mi}{62}\PYG{n}{G}
\PYG{n}{node2}         \PYG{n}{locku}    \PYG{l+m+mf}{0.1}   \PYG{l+m+mf}{0.0}   \PYG{l+m+mf}{0.0}   \PYG{l+m+mi}{0}\PYG{o}{\PYGZpc{}}   \PYG{l+m+mf}{0.4}   \PYG{l+m+mi}{0}   \PYG{l+m+mi}{60}  \PYG{l+m+mi}{227}\PYG{n}{G}   \PYG{l+m+mi}{32}\PYG{n}{G}   \PYG{l+m+mi}{62}\PYG{n}{G}
\PYG{n}{node4}         \PYG{n}{unavail}   \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}      \PYG{o}{\PYGZhy{}}   \PYG{o}{\PYGZhy{}}    \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}     \PYG{o}{\PYGZhy{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
HOST\_NAME：节点名。

\item {} 
\sphinxAtStartPar
status：状态。

\item {} 
\sphinxAtStartPar
status列：
\begin{itemize}
\item {} 
\sphinxAtStartPar
ok：表示可以接受新作业，只有这种状态可以接受新作业

\item {} 
\sphinxAtStartPar
closed：表示系统在运行，但已被调度系统关闭，不接受新作业

\item {} 
\sphinxAtStartPar
locku：表示在进行排他性运行

\item {} 
\sphinxAtStartPar
busy：表示负载超过限定

\item {} 
\sphinxAtStartPar
unavail、\sphinxhyphen{}ok：作业调度系统服务有问题

\end{itemize}

\item {} 
\sphinxAtStartPar
r15s、r1m、r15m列：分别表示15秒、1分钟、15分钟平均负载

\item {} 
\sphinxAtStartPar
ut：利用率

\item {} 
\sphinxAtStartPar
tmp：目录大小

\item {} 
\sphinxAtStartPar
swp：swp虚拟内存大小

\item {} 
\sphinxAtStartPar
mem：内存大小

\item {} 
\sphinxAtStartPar
io：硬盘读写（\sphinxhyphen{}l选项时才出现）

\end{itemize}

\sphinxAtStartPar
查看node2节点：\sphinxcode{\sphinxupquote{lsload node2}}


\section{查看各节点的空闲情况：bhosts}
\label{\detokenize{lsf/lsf:bhosts}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{bhosts}}命令可查看当前各节点的空闲情况，例如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bhosts}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HOST\PYGZus{}NAME}  \PYG{n}{STATUS}  \PYG{n}{JL}\PYG{o}{/}\PYG{n}{U}  \PYG{n}{MAX}  \PYG{n}{NJOBS}  \PYG{n}{RUN}  \PYG{n}{SSUSP}  \PYG{n}{USUSP}  \PYG{n}{RSV}
\PYG{n}{node12}         \PYG{n}{closed}   \PYG{o}{\PYGZhy{}}    \PYG{l+m+mi}{16}       \PYG{l+m+mi}{2}    \PYG{l+m+mi}{2}      \PYG{l+m+mi}{0}      \PYG{l+m+mi}{0}    \PYG{l+m+mi}{0}
\PYG{n}{node10}         \PYG{n}{ok}       \PYG{o}{\PYGZhy{}}    \PYG{l+m+mi}{16}       \PYG{l+m+mi}{2}    \PYG{l+m+mi}{1}      \PYG{l+m+mi}{0}      \PYG{l+m+mi}{0}    \PYG{l+m+mi}{0}
\PYG{n}{node14}         \PYG{n}{ok}       \PYG{o}{\PYGZhy{}}    \PYG{l+m+mi}{16}       \PYG{l+m+mi}{2}    \PYG{l+m+mi}{1}      \PYG{l+m+mi}{0}      \PYG{l+m+mi}{0}    \PYG{l+m+mi}{0}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
HOST\_NAME：节点名。

\item {} 
\sphinxAtStartPar
STATUS：状态。
\begin{itemize}
\item {} 
\sphinxAtStartPar
ok：表示可以接收新作业，只有这种状态可以接受新作业

\item {} 
\sphinxAtStartPar
closed：表示已被作业占满，不接受新作业

\item {} 
\sphinxAtStartPar
unavail和unreach：系统停机或作业调度系统服务有问题

\end{itemize}

\item {} 
\sphinxAtStartPar
JL/U：允许每个用户的作业核数。\sphinxhyphen{}表示未限制。

\item {} 
\sphinxAtStartPar
MAX：允许最大作业核数。

\item {} 
\sphinxAtStartPar
NJOBS：当前运行的作业数。

\item {} 
\sphinxAtStartPar
RUN：当前运行作业占据的核数。

\item {} 
\sphinxAtStartPar
SSUSP：被系统挂起的作业占据的核数。

\item {} 
\sphinxAtStartPar
USUSP：被用户挂起的作业占据的核数。

\item {} 
\sphinxAtStartPar
RSV：预留的核数。

\end{itemize}

\sphinxAtStartPar
查看node1节点：\sphinxcode{\sphinxupquote{bhosts node1}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bhosts \sphinxhyphen{}l}}会显示节点详细信息，其中slots表示目前最大可以接受作业槽数（默认一般与CPU核数一致）

\sphinxAtStartPar
即使有节点状态为ok状态，也不一定表示您的作业可以运行，具体运行条件参见{\hyperref[\detokenize{lsf/lsf:run}]{\emph{{[}run{]}}}}作业运行条件。


\section{查看用户信息：busers}
\label{\detokenize{lsf/lsf:busers}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{busers}}可以查看用户信息，例如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{busers hmli}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{USER}\PYG{o}{/}\PYG{n}{GROUP} \PYG{n}{JL}\PYG{o}{/}\PYG{n}{P} \PYG{n}{MAX} \PYG{n}{NJOBS} \PYG{n}{PEND} \PYG{n}{RUN} \PYG{n}{SSUSP} \PYG{n}{USUSP} \PYG{n}{RSV}
\PYG{n}{hmli}           \PYG{o}{\PYGZhy{}}     \PYG{l+m+mi}{320}     \PYG{l+m+mi}{40}     \PYG{l+m+mi}{32}    \PYG{l+m+mi}{8}      \PYG{l+m+mi}{0}     \PYG{l+m+mi}{0}    \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
其中：
\begin{itemize}
\item {} 
\sphinxAtStartPar
USER/GROUP：用户或组名。

\item {} 
\sphinxAtStartPar
JL/U：允许每个用户的作业核数。\sphinxhyphen{}表示未限制。

\item {} 
\sphinxAtStartPar
MAX：允许最大作业核数。

\item {} 
\sphinxAtStartPar
NJOBS：当前运行的作业数。

\item {} 
\sphinxAtStartPar
PEND：当前挂起作业占据的核数。

\item {} 
\sphinxAtStartPar
RUN：当前运行作业占据的核数。

\item {} 
\sphinxAtStartPar
SSUSP：被系统挂起的作业占据的核数。

\item {} 
\sphinxAtStartPar
USUSP：被用户挂起的作业占据的核数。

\item {} 
\sphinxAtStartPar
RSV：预留的核数。

\end{itemize}


\section{提交作业：bsub}
\label{\detokenize{lsf/lsf:bsub}}
\sphinxAtStartPar
用户需要利用\sphinxcode{\sphinxupquote{bsub}}提交作业，其基本格式为\sphinxcode{\sphinxupquote{bsub {[}options{]} command {[}arguments{]}}}。其中options设置队列、CPU核数等的选项，必须在command之前，否则将作为command的参数；arguments为设置作业的可执行程序本身所需要的参数，必须在command之后，否则将作为设置队列等的选项。下面将给出常用的几种提交方式。

\sphinxAtStartPar
注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
作业提交后，应经常检查一下作业的CPU、内存等利用率，判断实际运行效率：
\begin{itemize}
\item {} 
\sphinxAtStartPar
可以\sphinxcode{\sphinxupquote{ssh}}到对应运行作业的节点运行\sphinxcode{\sphinxupquote{top}}命令；

\item {} 
\sphinxAtStartPar
查看Ganglia系统监控：\sphinxurl{http://scc.ustc.edu.cn/ganglia}。

\end{itemize}

\item {} 
\sphinxAtStartPar
请不要ssh到节点后直接运行作业，以免影响作业调度系统分配到此节点的作业。

\end{itemize}


\subsection{提交到特定队列：bsub \sphinxhyphen{}q}
\label{\detokenize{lsf/lsf:bsub-q}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{\sphinxhyphen{}q}}选项可以指定提交到哪个队列，，请注意参看登录后的提示或运行\sphinxcode{\sphinxupquote{bqueues \sphinxhyphen{}l}}命令查看，现有的队列为：
\begin{itemize}
\item {} 
\sphinxAtStartPar
normal：所需要的CPU核数大于1个且不超过16个时

\item {} 
\sphinxAtStartPar
long：所需要的CPU核数超过32个时

\item {} 
\sphinxAtStartPar
serial：所需要的CPU核数为一个时

\end{itemize}

\sphinxAtStartPar
比如想提交到normal队列使用2个CPU核运行程序executable1，可以：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}q normal \sphinxhyphen{}n 2 executable1}}

\sphinxAtStartPar
如果提交成功，将显示类似下面的输出：

\sphinxAtStartPar
Job <79722> is submitted to queue <normal>.

\sphinxAtStartPar
其中79722为此作业的作业号，以后可利用此作业号来进行查询及终止等操作。

\sphinxAtStartPar
如提交不成功，则显示相应提示。


\subsection{提交串行作业：bsub \sphinxhyphen{}n 1}
\label{\detokenize{lsf/lsf:bsub-n-1}}
\sphinxAtStartPar
我校超算系统鼓励运行并行作业，允许运行的串行作业资源较少，有些系统不允许运行串行作业。

\sphinxAtStartPar
运行串行作业，请使用支持串行队列的队列（假如serial队列支持串行），比如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}q serial \sphinxhyphen{}n 1 executable\sphinxhyphen{}serial}}


\subsection{指明所需要的CPU核数：bsub \sphinxhyphen{}n}
\label{\detokenize{lsf/lsf:cpu-bsub-n}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{\sphinxhyphen{}n min\textbackslash{}\_proc{[},max\textbackslash{}\_proc{]}}}选项指定所需要的CPU核数（一般来说核数和进程数一致），比如下面指定利用24个CPU核（由\sphinxcode{\sphinxupquote{\sphinxhyphen{}n 24}}指定）运行MPI（由\sphinxcode{\sphinxupquote{mpijob}}指明为运行MPI程序）程序：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}q small \sphinxhyphen{}n 24 mpijob executable\sphinxhyphen{}mpi1}}

\sphinxAtStartPar
最少采用24最大采用72 CPU核数运行：\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}n 24,72}}

\sphinxAtStartPar
当作业调度尝试开始运行时：
\begin{itemize}
\item {} 
\sphinxAtStartPar
如空闲资源满足72 CPU核，那么将采用72 CPU核运行；

\item {} 
\sphinxAtStartPar
如空闲资源不满足72 CPU核，但满足24 CPU核，则用24 CPU核运行。

\end{itemize}

\sphinxAtStartPar
由于每个节点的CPU核数为24，建议单个作业所使用的核数最好为24或12的整数倍，以尽量保证自己的程序占据独立的节点或半个节点，尽量避免相互影响。以上仅仅是建议，具体申请核数应考虑作业实际情况。即使同一个计算软件，在计算不同条件时，也有可能不一样，请务必仔细研究自己所使用的软件。


\subsection{提交到特定节点：bsub \sphinxhyphen{}m “host\_name”}
\label{\detokenize{lsf/lsf:bsub-m-host-name}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{\sphinxhyphen{}m}}选项可以指定作业在特定节点上运行，如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}m ``node1 node3''}}

\sphinxAtStartPar
如非必要，建议不要添加此选项，以免导致作业无法及时运行。


\subsection{提交MPI作业：bsub \sphinxhyphen{}n NUM mpijob}
\label{\detokenize{lsf/lsf:mpi-bsub-n-num-mpijob}}
\sphinxAtStartPar
如果需要运行MPI作业，需要利用\sphinxcode{\sphinxupquote{mpijob}}调用MPI可执行程序，并用\sphinxhyphen{}n选项指定所需的CPU核数，比如下面指定利用64颗CPU核运行MPI程序executable\sphinxhyphen{}mpi1：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}q long \sphinxhyphen{}n 64 mpijob executable\sphinxhyphen{}mpi1}}

\sphinxAtStartPar
注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpijob}}命令已经封装了Intel MPI和Open
MPI的运行MPI作业的脚本，用户一般无需再特别按照Intel MPI和Open
MPI的原始\sphinxcode{\sphinxupquote{mpirun}}、\sphinxcode{\sphinxupquote{mpiexec}}等命令使用。

\item {} 
\begin{DUlineblock}{0em}
\item[] 提交作业时在\sphinxcode{\sphinxupquote{mpijob}}之前的参数将传递给LSF，之后的参数将传递给原始的\sphinxcode{\sphinxupquote{mpirun}}或
\item[] \sphinxcode{\sphinxupquote{mpiexec}}等。
\end{DUlineblock}

\item {} 
\sphinxAtStartPar
如用户对LSF和Intel MPI、Open
MPI等不熟悉，请勿擅自添加其它参数，如有需要请与超算中心联系。

\item {} 
\sphinxAtStartPar
如您了解所使用的MPI环境与LSF的配合，也可不用\sphinxcode{\sphinxupquote{mpijob}}提交，如直接用\sphinxcode{\sphinxupquote{mpirun}}等命令运行。

\end{itemize}


\subsection{指明需要某种资源作业提交：bsub \sphinxhyphen{}R}
\label{\detokenize{lsf/lsf:bsub-r}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}R ``res\_req'' {[}\sphinxhyphen{}R ``res\_req'' ...{]}}}可以使得作业在需要满足某种条件的节点上运行，如：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}R ``span{[}hosts=1{]}''}}：指定需要在同一个节点内运行；

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{\sphinxhyphen{}R ``span{[}ptile=8{]}''}}：指定需要在每一个节点内运行多少核，如\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}n 16 \sphinxhyphen{}R ``span{[}ptile=8{]}''}}
\item[] 则会分给2个节点，每个节点8核；
\end{DUlineblock}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}R ``1*\{mem>5000\} + 9*\{mem>1000\}''}}：一个CPU核需要至少5GB内存，另外9个每个至少需要1GB内存。

\end{itemize}


\subsection{提交OpenMP等共享内存作业：bsub \sphinxhyphen{}R “span{[}hosts=1{]}” OMP\_NUM\_THREADS=}
\label{\detokenize{lsf/lsf:openmp-bsub-r-span-hosts-1-omp-num-threads}}
\sphinxAtStartPar
由于只能在同一个节点内部运行OpenMP共享内存的作业，如Gaussian程序，此时需要添加利用\sphinxcode{\sphinxupquote{\sphinxhyphen{}R ``span{[}hosts=1{]}''}}参数指定使用一个节点，并用OMP\_NUM\_THREADS设定指定的线程数，一般应与申请的核数一致 %
\begin{footnote}[1]\sphinxAtStartFootnote
有些程序可以在输入文件中设置，那么可以不填加OMP\_NUM\_THREADS
%
\end{footnote}：

\sphinxAtStartPar
指定利用8 CPU核运行OpenMP程序：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}q normal \sphinxhyphen{}n 8 \sphinxhyphen{}R ``span{[}hosts=1{]}'' OMP\_NUM\_THREADS=8 executable\sphinxhyphen{}omp1}}


\subsection{MPI和OpenMP共享内存混合并行作业}
\label{\detokenize{lsf/lsf:mpiopenmp}}
\sphinxAtStartPar
需要针对需求利用LSF环境变量特殊处理，如果自己不清楚怎么处理，请联系管理人员。


\subsection{给作业起个名字：bsub \sphinxhyphen{}P project\_name}
\label{\detokenize{lsf/lsf:bsub-p-project-name}}
\sphinxAtStartPar
提交时可以利用\sphinxcode{\sphinxupquote{\sphinxhyphen{}P}}选项给作业起个名字方便查看，如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}P VASPJOB}}


\subsection{运行排他性作业：bsub \sphinxhyphen{}x}
\label{\detokenize{lsf/lsf:bsub-x}}
\sphinxAtStartPar
如需要独占节点运行，此时需要添加\sphinxhyphen{}x选项：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}x \sphinxhyphen{}q normal \sphinxhyphen{}n 8 executable\sphinxhyphen{}omp1}}

\sphinxAtStartPar
注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
排他性运行在运行期间，不允许其余的作业提交到运行此作业的节点，并且只有在某节点没有任何其余的作业在运行时才会提交到此节点上运行；

\item {} 
\sphinxAtStartPar
如果不需要采用排他性运行，请不要使用此选项，否则将导致作业必须等待完全空闲的节点才会运行，也许将增加等待时间；

\item {} 
\sphinxAtStartPar
另外使用排他性运行时，哪怕只使用某节点内的一个CPU核，也将按照此节点内的所有CPU核数进行机时计算。

\end{itemize}


\subsection{指明输出、输出文件运行：bsub \sphinxhyphen{}i \sphinxhyphen{}o \sphinxhyphen{}e}
\label{\detokenize{lsf/lsf:bsub-i-o-e}}
\sphinxAtStartPar
作业的正常屏幕输入文件（指的是类似
方式的文件）、正常屏幕输出到的文件和错误屏幕输出的文件可以利用\sphinxhyphen{}i、\sphinxhyphen{}o和\sphinxhyphen{}e选项来分别指定，运行后可以通过查看指定的这些输出文件来查看运行状态，文件名可利用\%J与作业号挂钩。比如指定executable1的输入、正常和错误屏幕输出文件分别为：、和：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}i executable1.input \sphinxhyphen{}o executable1\sphinxhyphen{}\textbackslash{}\%J.log \sphinxhyphen{}e executable1\sphinxhyphen{}\textbackslash{}\%J.err executable1}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}o}}和\sphinxcode{\sphinxupquote{\sphinxhyphen{}e}}及变种\sphinxcode{\sphinxupquote{\sphinxhyphen{}oo}}和\sphinxcode{\sphinxupquote{\sphinxhyphen{}eo}}：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}o：如日志原文件存在，正常屏幕输出将追加到原文件后

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}oo：如日志原文件存在，正常屏幕输出将覆盖原文件

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}e：如日志原文件存在，出错时屏幕输出将追加到原文件后

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}eo：如日志原文件存在，出错时屏幕输出将覆盖原文件

\end{itemize}

\sphinxAtStartPar
建议打开\sphinxhyphen{}o和\sphinxhyphen{}e参数，以便查看作业为什么出问题等。如果需要管理人员协助解决，请告知这些输出，以及运行目录，怎么运行的等，以便管理人员能获取足够的信息及时处理。


\subsection{指明输出目录提交：bsub \sphinxhyphen{}outdir output\_directory}
\label{\detokenize{lsf/lsf:bsub-outdir-output-directory}}
\sphinxAtStartPar
默认情况下，屏幕输出等存放在提交作业时的目录下，如想将其放到其它目录可以采用\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}outdir output\textbackslash{}\_directory}}方式，如：

\sphinxAtStartPar
\sphinxtitleref{bsub \sphinxhyphen{}outdir \%U/\%J\_\%I myprog}

\sphinxAtStartPar
结合以下常用变量，可以方便结合作业号等设置输出目录及日志文件名等：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\%J：作业号

\item {} 
\sphinxAtStartPar
\%JG：作业组

\item {} 
\sphinxAtStartPar
\%I：作业组中的索引

\item {} 
\sphinxAtStartPar
\%EJ：执行作业号

\item {} 
\sphinxAtStartPar
\%EI：作业组中的执行作业索引

\item {} 
\sphinxAtStartPar
\%P：作业名

\item {} 
\sphinxAtStartPar
\%U：用户名

\item {} 
\sphinxAtStartPar
\%G：用户组名

\end{itemize}


\subsection{交互式运行作业：bsub \sphinxhyphen{}I}
\label{\detokenize{lsf/lsf:bsub-i}}
\sphinxAtStartPar
如果需要运行交互式的作业（如在运行期间需要手动输入参数或利用调试器手动调试程序等需要进行交互时），需要结合\sphinxhyphen{}I参数。建议只是在调试期间使用，一般作业还是尽量不要使用此选项，类似选项还有\sphinxhyphen{}Ip和\sphinxhyphen{}Is：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}I executable1}}


\subsection{满足依赖关系运行作业：bsub \sphinxhyphen{}w}
\label{\detokenize{lsf/lsf:bsub-w}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{\sphinxhyphen{}w}}选项可以使得新提交的作业在满足一定条件时才运行，比如与其它作业的关联：
\begin{itemize}
\item {} 
\sphinxAtStartPar
done(job\_ID |“job\_name” …)：作业结束时状态为DONE时运行

\item {} 
\sphinxAtStartPar
ended(job\_ID | “job\_name”)：作业结束时状态为DONE或EXIT时运行

\item {} 
\sphinxAtStartPar
exit(job\_ID | “job\_name” {[},{[}operator{]}
exit\_code{]})：作业结束时状态为EXIT，且退出代码满足一定条件时运行

\item {} 
\sphinxAtStartPar
external(job\_ID | “job\_name”,
“status\_text”)：作业状态变为某状态时运行，如变为SUSP

\item {} 
\sphinxAtStartPar
支持的条件之间的条件表达式：\&\&（和）、||（或）、!（否）

\item {} 
\sphinxAtStartPar
支持的条件内的条件算子：>、 >=、 <、 <=、==、!=

\end{itemize}

\sphinxAtStartPar
如：\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}w ``done(1456)''}}


\subsection{指定时间运行：bsub \sphinxhyphen{}b time}
\label{\detokenize{lsf/lsf:bsub-b-time}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{\sphinxhyphen{}b {[}{[}year:{]}{[}month:{]}day:{]}hour:minute}}可以使得新提交的作业在特定时间运行，系统会预留资源给此作业，如果在时间到达时所需资源满足则会运行，不满足则继续等待。如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}b 2016:01:09:09:20}}


\subsection{指定运行时长：bsub \sphinxhyphen{}W time}
\label{\detokenize{lsf/lsf:bsub-w-time}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{\sphinxhyphen{}W {[}hour:{]}minute}}可以使得提交的作业在运行超过设定时长后终止，如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}W 1:30}}


\subsection{在运行前执行特定命令：bsub \sphinxhyphen{}E “pre\_command”}
\label{\detokenize{lsf/lsf:bsub-e-pre-command}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{\sphinxhyphen{}E ``pre\_exec\_command {[}arguments ...{]}''}}可以使得作业在运行前，在所分配的节点上运行特定命令。

\sphinxAtStartPar
如利用modinput.sh此修改程序输入参数：\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}E `}}./modinput.sh 10’’ \sphinxhyphen{}n 2 exec1`


\subsection{在运行后执行特定命令：bsub \sphinxhyphen{}Ep “post\_command”}
\label{\detokenize{lsf/lsf:bsub-ep-post-command}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{\sphinxhyphen{}Ep ``post\_exec\_command {[}arguments ...{]}''}}可以使得作业在运行结束时，在所分配的节点上运行特定命令。

\sphinxAtStartPar
如利用此删除core文件：\sphinxcode{\sphinxupquote{bsub \sphinxhyphen{}Ep ``bin/rm \sphinxhyphen{}f core.*'' \sphinxhyphen{}n 2 exec1}}


\subsection{LSF作业脚本}
\label{\detokenize{lsf/lsf:id3}}
\sphinxAtStartPar
如果作业比较复杂，还需要设置环境变量，做其它处理等，可用以在LSF脚本中设置队列等参数方式提交，如

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{c+c1}{\PYGZsh{}BSUB \PYGZhy{}q long}
\PYG{c+c1}{\PYGZsh{}BSUB \PYGZhy{}o \PYGZpc{}J.log \PYGZhy{}e \PYGZpc{}J.err}
\PYG{c+c1}{\PYGZsh{}BSUB \PYGZhy{}n 64}
\PYG{n+nb}{source} my.sh
mpijob ./mympi\PYGZhy{}prog1
\PYG{n+nb}{cd} newworkdir
mpijob ./mympi\PYGZhy{}prog2
\end{sphinxVerbatim}

\sphinxAtStartPar
注意，采用此方式时：
\begin{itemize}
\item {} 
\sphinxAtStartPar
不得以直接\sphinxcode{\sphinxupquote{./my\_script.lsf}}等常规脚本运行方式运行。

\item {} 
\sphinxAtStartPar
需要传递给\sphinxcode{\sphinxupquote{bsub}}命令运行：\sphinxcode{\sphinxupquote{bsub < my\_script.lsf}}。

\item {} 
\sphinxAtStartPar
如果bsub后面更\sphinxhyphen{}q等LSF参数，将会覆盖掉LSF脚本中的设置。

\item {} 
\sphinxAtStartPar
一般用户，没必要写此类脚本，直接通过命令行传递LSF参数即可。

\item {} 
\sphinxAtStartPar
对于当前设置满足不了作业需求，且用户比较了解LSF中的各规定，对shell脚本编写比较在行，那么用户完全可自己编写脚本提交作业，比如提交特殊需求的MPI与OpenMP结合的作业。

\end{itemize}

\sphinxAtStartPar
LSF作业脚本主要有以下常见变量比较常用，在作业运行后，这些变量存储对应的作业信息，具体的请参看LSF官方手册：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LS\_JOBPID}}：作业进程号

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LSB\_HOSTS}}：存储系统分配的节点名

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LSB\_JOBFILENAME}}：作业脚本文件名

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LSB\_JOBID}}：作业号

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LSB\_QUEUE}}：作业队列

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LSB\_JOBPGIDS}}：作业进程组号组

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LSB\_JOBPIDS}}：作业进程号组

\end{itemize}


\section{终止作业：bkill}
\label{\detokenize{lsf/lsf:bkill}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{bkill}}命令可以终止某个运行中或者排队中的作业，比如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bkill 79722}}

\sphinxAtStartPar
运行成功后，将显示类似下面的输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Job} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{79722}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{is} \PYG{n}{being} \PYG{n}{terminated}
\end{sphinxVerbatim}


\section{挂起作业：bstop}
\label{\detokenize{lsf/lsf:bstop}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{bstop}}命令可临时挂起某个作业以让别的作业先运行，例如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bstop 79727}}

\sphinxAtStartPar
运行成功后，将显示类似下面的输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Job} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{79727}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{is} \PYG{n}{being} \PYG{n}{stopped}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
此命令可以将排在队列前面的作业临时挂起，以让后面的作业先运行。虽然也可以作用于运行中的作业，但并不会因为此作业被挂起而允许其余作业占用此作业所占用的CPU运行，实际资源不会释放，因此建议不要随便对运行中的作业进行挂起操作，如果运行中的作业不再想继续运行，请用\sphinxcode{\sphinxupquote{bkill}}终止。


\section{继续运行被挂起的作业：bresume}
\label{\detokenize{lsf/lsf:bresume}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{bresume}}命令可继续运行某个挂起某个作业，例如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bresume 79727}}

\sphinxAtStartPar
运行成功后，将显示类似下面的输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Job} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{79727}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{is} \PYG{n}{being} \PYG{n}{resumed}\PYG{o}{.}
\end{sphinxVerbatim}


\section{设置作业最先运行：btop}
\label{\detokenize{lsf/lsf:btop}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{btop}}命令可最先运行排队中的某个作业，例如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{btop 79727}}

\sphinxAtStartPar
运行成功后，将显示类似下面的输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Job} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{79727}\PYG{o}{\PYGZgt{}} \PYG{n}{has} \PYG{n}{been} \PYG{n}{moved} \PYG{n}{to} \PYG{n}{position} \PYG{l+m+mi}{1} \PYG{k+kn}{from} \PYG{n+nn}{top}\PYG{n+nn}{.}
\end{sphinxVerbatim}


\section{设置作业最后运行：bbot}
\label{\detokenize{lsf/lsf:bbot}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{bbot}}命令可设定最后运行排队中的某个作业，例如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bbot 79727}}

\sphinxAtStartPar
运行成功后，将显示类似下面的输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Job} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{79727}\PYG{o}{\PYGZgt{}} \PYG{n}{has} \PYG{n}{been} \PYG{n}{moved} \PYG{n}{to} \PYG{n}{position} \PYG{l+m+mi}{1} \PYG{k+kn}{from} \PYG{n+nn}{bottom}\PYG{n+nn}{.}
\end{sphinxVerbatim}


\section{修改排队中的作业选项：bmod}
\label{\detokenize{lsf/lsf:bmod}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{bmod}}命令可修改排队中的某个作业的选项，比如想将排队中的运行作业号为79727的作业的执行命令修改为executable2并且换到long队列，可以：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bmod \sphinxhyphen{}Z executable2 \sphinxhyphen{}q long 79727}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Parameters} \PYG{n}{of} \PYG{n}{job} \PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{79727}\PYG{o}{\PYGZgt{}} \PYG{n}{are} \PYG{n}{being} \PYG{n}{changed}\PYG{o}{.}
\end{sphinxVerbatim}


\section{查看作业的排队和运行情况：bjobs}
\label{\detokenize{lsf/lsf:bjobs}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{bjobs}}可以查看作业的运行情况，比如有哪些作业在运行，哪些在排队，某个作业运行在哪个节点上，以及为什么没有运行等，例如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bjobs}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{JOBID} \PYG{n}{USER}  \PYG{n}{STAT}  \PYG{n}{QUEUE}    \PYG{n}{FROM\PYGZus{}HOST}   \PYG{n}{EXEC\PYGZus{}HOST} \PYG{n}{JOB\PYGZus{}NAME}   \PYG{n}{SUBMIT\PYGZus{}TIME}
\PYG{l+m+mi}{79726} \PYG{n}{hmli}  \PYG{n}{RUN}   \PYG{n}{normal}   \PYG{n}{tc4600}      \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{node31}  \PYG{o}{*}\PYG{n}{executab1} \PYG{n}{Mar} \PYG{l+m+mi}{12} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{20}
                                       \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{node18}
                                       \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{node4}
\PYG{l+m+mi}{79727} \PYG{n}{hmli}  \PYG{n}{PEND}  \PYG{n}{long}     \PYG{n}{tc4600}                \PYG{o}{*}\PYG{n}{executab2} \PYG{n}{Mar} \PYG{l+m+mi}{12} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{20}
\end{sphinxVerbatim}

\sphinxAtStartPar
上面显示作业79726在运行，分别在node31、node18和node4上运行2、1、1个进程；而作业79727处于排队中尚未运行，查看未运行的原因可以利用：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bjobs \sphinxhyphen{}l 79727}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Job Id \PYGZlt{}79727\PYGZgt{}, tc4600 \PYGZlt{}hmli\PYGZgt{}, Project \PYGZlt{}default\PYGZgt{}, Status \PYGZlt{}PEND\PYGZgt{},
Queue \PYGZlt{}long\PYGZgt{} , Command \PYGZlt{}executab2\PYGZgt{}
Sun Mar 12 14:15:07: Submitted from host \PYGZlt{}tc4600\PYGZgt{},
CWD \PYGZlt{}\PYGZdl{}HOME\PYGZgt{}, Requested Resources \PYGZlt{}type==any \PYGZam{}\PYGZam{} swp\PYGZgt{}35\PYGZgt{};
PENDING REASONS:
SCHEDULING PARAMETERS:
            r15s r1m r15m  ut pg   io  ls   it   tmp   swp   mem
loadSched   \PYGZhy{}    0.7 1.0   \PYGZhy{} 4.0   \PYGZhy{}   \PYGZhy{}    \PYGZhy{}    \PYGZhy{}     \PYGZhy{}     \PYGZhy{}
loadStop    \PYGZhy{}    1.5 2.5   \PYGZhy{} 8.0   \PYGZhy{}   \PYGZhy{}    \PYGZhy{}    \PYGZhy{}     \PYGZhy{}     \PYGZhy{}
\end{sphinxVerbatim}

\sphinxAtStartPar
以下为另外几个常用参数：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}u
username：查看某用户的作业，如username为all，则查看所有用户的作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}q queuename：查看某队列上的作业。

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}m hostname：查看某节点上的作业。

\end{itemize}


\section{查看作业负载：checkjob}
\label{\detokenize{lsf/lsf:checkjob}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{/opt/bin/monitor/checkjob 作业号}}可以查看作业各节点负载等信息，例如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/opt/bin/monitor/checkjob 799374}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{user}\PYG{p}{:} \PYG{n}{hmli}\PYG{p}{,} \PYG{n}{jobid}\PYG{p}{:} \PYG{l+m+mi}{799374}
\PYG{n}{Note}\PYG{p}{:} \PYG{n}{cpu\PYGZus{}load} \PYG{n}{near} \PYG{n}{cpu\PYGZus{}num} \PYG{o+ow}{and} \PYG{n}{swap\PYGZus{}used} \PYG{n}{smaller} \PYG{o+ow}{or} \PYG{n}{zero} \PYG{o+ow}{is} \PYG{n}{better}\PYG{o}{.}
\PYG{n}{node\PYGZus{}name}  \PYG{n}{cpu\PYGZus{}num}  \PYG{n}{cpu\PYGZus{}load}  \PYG{n}{memory}\PYG{p}{(}\PYG{o}{\PYGZpc{}}\PYG{p}{)}  \PYG{n}{swap\PYGZus{}used}\PYG{p}{(}\PYG{n}{GB}\PYG{p}{)}
\PYG{n}{node491}     \PYG{l+m+mi}{144}      \PYG{l+m+mf}{109.03}    \PYG{l+m+mf}{23.00}          \PYG{l+m+mi}{0}
\PYG{n}{node493}     \PYG{l+m+mi}{144}      \PYG{l+m+mf}{115.52}    \PYG{l+m+mf}{23.00}          \PYG{l+m+mi}{0}
\end{sphinxVerbatim}


\section{查看运行中作业的屏幕正常输出：bpeek}
\label{\detokenize{lsf/lsf:bpeek}}
\sphinxAtStartPar
利用\sphinxcode{\sphinxupquote{bpeek}}命令可查看运行中作业的屏幕正常输出，例如：

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bpeek 79727}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{output} \PYG{k+kn}{from} \PYG{n+nn}{stdout} \PYG{o}{\PYGZgt{}\PYGZgt{}}
\PYG{n}{Energy}\PYG{p}{:} \PYG{l+m+mf}{3.0}\PYG{n}{keV}
\PYG{n}{Angles}\PYG{p}{:} \PYG{l+m+mf}{13.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}
\end{sphinxVerbatim}

\sphinxAtStartPar
如果在运行中用\sphinxhyphen{}o和\sphinxhyphen{}e分别指定了正常和错误屏幕输出，也可以通过直接查看指定的文件的内容来查看屏幕输出。

\sphinxAtStartPar
如果想连续查看某个作业的输出，请添加\sphinxhyphen{}f参数。

\sphinxstepscope


\chapter{LaTeX pdf版}
\label{\detokenize{latex:latex-pdf}}\label{\detokenize{latex::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://scc.ustc.edu.cn/zlsc/user\_doc/html/userdocument-scc-ustc.pdf}{中国科大超级计算中心用户使用手册}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://scc.ustc.edu.cn/zlsc/hanhai20/瀚海20超级计算系统用户使用指南.pdf}{瀚海20超级计算系统用户使用指南} （不再更新）

\item {} 
\sphinxAtStartPar
\sphinxhref{https://scc.ustc.edu.cn/zlsc/tc4600/曙光TC4600百万亿次超级计算系统用户使用指南.pdf}{曙光TC4600百万亿次超级计算系统用户使用指南} （不再更新）

\end{itemize}

\sphinxstepscope


\chapter{联系方式}
\label{\detokenize{contact:id1}}\label{\detokenize{contact::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
信箱：\sphinxhref{mailto:sccadmin@ustc.edu.cn}{sccadmin@ustc.edu.cn}

\item {} 
\sphinxAtStartPar
超算中心主页：\sphinxurl{http://scc.ustc.edu.cn}

\end{itemize}



\renewcommand{\indexname}{索引}
\printindex
\end{document}